/**
 * JavaScript integration layer for the WASM Signal Protocol implementation.
 * This module provides the `makeLibSignalRepository` function that creates
 * a SignalRepository using the Rust WASM backend.
 */

import type { 
    SignalRepository, 
    SignalKeyStore, 
    EncryptResult, 
    DecryptResult,
    PreKeyBundle 
} from '../Types/Signal.js';

// WASM module import - this will be generated by wasm-pack
import init, { WasmSignalRepository } from '../../wacore-wasm/pkg/wacore_wasm.js';

/**
 * Initialize the WASM module (should be called once before using the repository)
 */
export async function initSignalWasm(): Promise<void> {
    await init();
}

/**
 * Implementation of SignalRepository that bridges to the WASM backend
 */
class WasmSignalRepositoryImpl implements SignalRepository {
    private wasmRepo: WasmSignalRepository;

    constructor(signalStorage: SignalKeyStore) {
        // Create the WASM repository with the JavaScript store
        this.wasmRepo = new WasmSignalRepository(signalStorage);
    }

    async encryptMessage(jid: string, plaintext: Uint8Array): Promise<EncryptResult> {
        const result = await this.wasmRepo.encryptMessage(jid, plaintext);
        return result as EncryptResult;
    }

    async decryptMessage(
        jid: string, 
        ciphertext: Uint8Array, 
        messageType: number
    ): Promise<DecryptResult> {
        const result = await this.wasmRepo.decryptMessage(jid, ciphertext, messageType);
        return result as DecryptResult;
    }

    async encryptGroupMessage(
        groupId: string,
        senderKeyId: string,
        plaintext: Uint8Array
    ): Promise<EncryptResult> {
        // For now, delegate to the basic encrypt_message until group methods are implemented
        const result = await this.wasmRepo.encryptMessage(`${groupId}:${senderKeyId}`, plaintext);
        return result as EncryptResult;
    }

    async decryptGroupMessage(
        groupId: string,
        senderKeyId: string,
        ciphertext: Uint8Array
    ): Promise<DecryptResult> {
        // For now, delegate to the basic decrypt_message until group methods are implemented
        const result = await this.wasmRepo.decryptMessage(`${groupId}:${senderKeyId}`, ciphertext, 3);
        return result as DecryptResult;
    }

    async injectE2ESession(jid: string, preKeyBundle: PreKeyBundle): Promise<void> {
        // For now, this is a placeholder until the WASM implementation is complete
        console.log(`Injecting E2E session for ${jid}`, preKeyBundle);
        // await this.wasmRepo.injectE2ESession(jid, preKeyBundle);
    }

    async processSenderKeyDistributionMessage(
        senderKeyId: string,
        distributionMessage: Uint8Array
    ): Promise<void> {
        // For now, this is a placeholder until the WASM implementation is complete
        console.log(`Processing sender key distribution for ${senderKeyId}`, distributionMessage);
        // await this.wasmRepo.processSenderKeyDistributionMessage(senderKeyId, distributionMessage);
    }
}

/**
 * Factory function to create a SignalRepository using the WASM backend.
 * This maintains API compatibility with the existing JavaScript implementation.
 * 
 * @param signalStorage - The JavaScript implementation of the key store
 * @returns A SignalRepository instance backed by the WASM implementation
 */
export function makeLibSignalRepository(signalStorage: SignalKeyStore): SignalRepository {
    return new WasmSignalRepositoryImpl(signalStorage);
}

/**
 * Example implementation of a SignalKeyStore for testing/demo purposes.
 * In a real application, this would be backed by a database or secure storage.
 */
export class MemorySignalKeyStore implements SignalKeyStore {
    private identityKeyPair: { publicKey: Uint8Array; privateKey: Uint8Array } | null = null;
    private registrationId: number = Math.floor(Math.random() * 16384);
    private identities = new Map<string, Uint8Array>();
    private sessions = new Map<string, Uint8Array>();
    private preKeys = new Map<number, Uint8Array>();
    private signedPreKeys = new Map<number, Uint8Array>();
    private senderKeys = new Map<string, Uint8Array>();

    private getAddressKey(address: { name: string; deviceId: number }): string {
        return `${address.name}.${address.deviceId}`;
    }

    private getSenderKeyKey(senderKeyName: { groupId: string; senderName: string }): string {
        return `${senderKeyName.groupId}:${senderKeyName.senderName}`;
    }

    async getIdentityKeyPair(): Promise<{ publicKey: Uint8Array; privateKey: Uint8Array }> {
        if (!this.identityKeyPair) {
            // Generate a dummy key pair for testing
            this.identityKeyPair = {
                publicKey: new Uint8Array(32),
                privateKey: new Uint8Array(32)
            };
            // Fill with some pseudo-random data
            crypto.getRandomValues(this.identityKeyPair.publicKey);
            crypto.getRandomValues(this.identityKeyPair.privateKey);
        }
        return this.identityKeyPair;
    }

    async getLocalRegistrationId(): Promise<number> {
        return this.registrationId;
    }

    async saveIdentity(address: { name: string; deviceId: number }, identityKey: Uint8Array): Promise<void> {
        this.identities.set(this.getAddressKey(address), identityKey);
    }

    async isTrustedIdentity(address: { name: string; deviceId: number }, identityKey: Uint8Array): Promise<boolean> {
        const stored = this.identities.get(this.getAddressKey(address));
        if (!stored) return true; // Trust on first encounter
        return stored.every((byte, index) => byte === identityKey[index]);
    }

    async loadSession(address: { name: string; deviceId: number }): Promise<Uint8Array | null> {
        return this.sessions.get(this.getAddressKey(address)) || null;
    }

    async storeSession(address: { name: string; deviceId: number }, record: Uint8Array): Promise<void> {
        this.sessions.set(this.getAddressKey(address), record);
    }

    async containsSession(address: { name: string; deviceId: number }): Promise<boolean> {
        return this.sessions.has(this.getAddressKey(address));
    }

    async deleteSession(address: { name: string; deviceId: number }): Promise<void> {
        this.sessions.delete(this.getAddressKey(address));
    }

    async deleteAllSessions(name: string): Promise<void> {
        for (const key of this.sessions.keys()) {
            if (key.startsWith(name + '.')) {
                this.sessions.delete(key);
            }
        }
    }

    async getSubDeviceSessions(name: string): Promise<number[]> {
        const devices: number[] = [];
        for (const key of this.sessions.keys()) {
            if (key.startsWith(name + '.')) {
                const deviceId = parseInt(key.split('.')[1]);
                if (!isNaN(deviceId)) {
                    devices.push(deviceId);
                }
            }
        }
        return devices;
    }

    async loadPreKey(keyId: number): Promise<Uint8Array | null> {
        return this.preKeys.get(keyId) || null;
    }

    async storePreKey(keyId: number, record: Uint8Array): Promise<void> {
        this.preKeys.set(keyId, record);
    }

    async containsPreKey(keyId: number): Promise<boolean> {
        return this.preKeys.has(keyId);
    }

    async removePreKey(keyId: number): Promise<void> {
        this.preKeys.delete(keyId);
    }

    async loadSignedPreKey(keyId: number): Promise<Uint8Array | null> {
        return this.signedPreKeys.get(keyId) || null;
    }

    async loadSignedPreKeys(): Promise<Uint8Array[]> {
        return Array.from(this.signedPreKeys.values());
    }

    async storeSignedPreKey(keyId: number, record: Uint8Array): Promise<void> {
        this.signedPreKeys.set(keyId, record);
    }

    async containsSignedPreKey(keyId: number): Promise<boolean> {
        return this.signedPreKeys.has(keyId);
    }

    async removeSignedPreKey(keyId: number): Promise<void> {
        this.signedPreKeys.delete(keyId);
    }

    async storeSenderKey(senderKeyName: { groupId: string; senderName: string }, record: Uint8Array): Promise<void> {
        this.senderKeys.set(this.getSenderKeyKey(senderKeyName), record);
    }

    async loadSenderKey(senderKeyName: { groupId: string; senderName: string }): Promise<Uint8Array> {
        const record = this.senderKeys.get(this.getSenderKeyKey(senderKeyName));
        if (!record) {
            throw new Error(`No sender key found for ${this.getSenderKeyKey(senderKeyName)}`);
        }
        return record;
    }

    async deleteSenderKey(senderKeyName: { groupId: string; senderName: string }): Promise<void> {
        this.senderKeys.delete(this.getSenderKeyKey(senderKeyName));
    }
}