// This file is @generated by prost-build.
// / WhatsApp Version: 2.3000.1023047013

#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AdvDeviceIdentity {
    #[prost(uint32, optional, tag="1")]
    pub raw_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="2")]
    pub timestamp: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="3")]
    pub key_index: ::core::option::Option<u32>,
    #[prost(enumeration="AdvEncryptionType", optional, tag="4")]
    pub account_type: ::core::option::Option<i32>,
    #[prost(enumeration="AdvEncryptionType", optional, tag="5")]
    pub device_type: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AdvKeyIndexList {
    #[prost(uint32, optional, tag="1")]
    pub raw_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="2")]
    pub timestamp: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="3")]
    pub current_index: ::core::option::Option<u32>,
    #[prost(uint32, repeated, tag="4")]
    pub valid_indexes: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration="AdvEncryptionType", optional, tag="5")]
    pub account_type: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AdvSignedDeviceIdentity {
    #[prost(bytes="vec", optional, tag="1")]
    pub details: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="2")]
    pub account_signature_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="3")]
    pub account_signature: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="4")]
    pub device_signature: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AdvSignedDeviceIdentityHmac {
    #[prost(bytes="vec", optional, tag="1")]
    pub details: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="2")]
    pub hmac: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(enumeration="AdvEncryptionType", optional, tag="3")]
    pub account_type: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AdvSignedKeyIndexList {
    #[prost(bytes="vec", optional, tag="1")]
    pub details: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="2")]
    pub account_signature: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="3")]
    pub account_signature_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AiQueryFanout {
    #[prost(message, optional, tag="1")]
    pub message_key: ::core::option::Option<MessageKey>,
    #[prost(message, optional, boxed, tag="2")]
    pub message: ::core::option::Option<::prost::alloc::boxed::Box<Message>>,
    #[prost(int64, optional, tag="3")]
    pub timestamp: ::core::option::Option<i64>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AiRichResponseMessage {
    #[prost(enumeration="ai_rich_response_message::AiRichResponseMessageType", optional, tag="1")]
    pub message_type: ::core::option::Option<i32>,
    #[prost(message, repeated, tag="2")]
    pub submessages: ::prost::alloc::vec::Vec<ai_rich_response_message::AiRichResponseSubMessage>,
    #[prost(message, optional, tag="3")]
    pub unified_response: ::core::option::Option<ai_rich_response_message::AiRichResponseUnifiedResponse>,
}
/// Nested message and enum types in `AIRichResponseMessage`.
pub mod ai_rich_response_message {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AiRichResponseCodeMetadata {
        #[prost(string, optional, tag="1")]
        pub code_language: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="2")]
        pub code_blocks: ::prost::alloc::vec::Vec<ai_rich_response_code_metadata::AiRichResponseCodeBlock>,
    }
    /// Nested message and enum types in `AIRichResponseCodeMetadata`.
    pub mod ai_rich_response_code_metadata {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AiRichResponseCodeBlock {
            #[prost(enumeration="AiRichResponseCodeHighlightType", optional, tag="1")]
            pub highlight_type: ::core::option::Option<i32>,
            #[prost(string, optional, tag="2")]
            pub code_content: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum AiRichResponseCodeHighlightType {
            AiRichResponseCodeHighlightDefault = 0,
            AiRichResponseCodeHighlightKeyword = 1,
            AiRichResponseCodeHighlightMethod = 2,
            AiRichResponseCodeHighlightString = 3,
            AiRichResponseCodeHighlightNumber = 4,
            AiRichResponseCodeHighlightComment = 5,
        }
        impl AiRichResponseCodeHighlightType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::AiRichResponseCodeHighlightDefault => "AI_RICH_RESPONSE_CODE_HIGHLIGHT_DEFAULT",
                    Self::AiRichResponseCodeHighlightKeyword => "AI_RICH_RESPONSE_CODE_HIGHLIGHT_KEYWORD",
                    Self::AiRichResponseCodeHighlightMethod => "AI_RICH_RESPONSE_CODE_HIGHLIGHT_METHOD",
                    Self::AiRichResponseCodeHighlightString => "AI_RICH_RESPONSE_CODE_HIGHLIGHT_STRING",
                    Self::AiRichResponseCodeHighlightNumber => "AI_RICH_RESPONSE_CODE_HIGHLIGHT_NUMBER",
                    Self::AiRichResponseCodeHighlightComment => "AI_RICH_RESPONSE_CODE_HIGHLIGHT_COMMENT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "AI_RICH_RESPONSE_CODE_HIGHLIGHT_DEFAULT" => Some(Self::AiRichResponseCodeHighlightDefault),
                    "AI_RICH_RESPONSE_CODE_HIGHLIGHT_KEYWORD" => Some(Self::AiRichResponseCodeHighlightKeyword),
                    "AI_RICH_RESPONSE_CODE_HIGHLIGHT_METHOD" => Some(Self::AiRichResponseCodeHighlightMethod),
                    "AI_RICH_RESPONSE_CODE_HIGHLIGHT_STRING" => Some(Self::AiRichResponseCodeHighlightString),
                    "AI_RICH_RESPONSE_CODE_HIGHLIGHT_NUMBER" => Some(Self::AiRichResponseCodeHighlightNumber),
                    "AI_RICH_RESPONSE_CODE_HIGHLIGHT_COMMENT" => Some(Self::AiRichResponseCodeHighlightComment),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AiRichResponseContentItemsMetadata {
        #[prost(message, repeated, tag="1")]
        pub items_metadata: ::prost::alloc::vec::Vec<ai_rich_response_content_items_metadata::AiRichResponseContentItemMetadata>,
        #[prost(enumeration="ai_rich_response_content_items_metadata::ContentType", optional, tag="2")]
        pub content_type: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `AIRichResponseContentItemsMetadata`.
    pub mod ai_rich_response_content_items_metadata {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AiRichResponseContentItemMetadata {
            #[prost(oneof="ai_rich_response_content_item_metadata::AIRichResponseContentItem", tags="1")]
            pub a_i_rich_response_content_item: ::core::option::Option<ai_rich_response_content_item_metadata::AIRichResponseContentItem>,
        }
        /// Nested message and enum types in `AIRichResponseContentItemMetadata`.
        pub mod ai_rich_response_content_item_metadata {
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
            pub enum AIRichResponseContentItem {
                #[prost(message, tag="1")]
                ReelItem(super::AiRichResponseReelItem),
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AiRichResponseReelItem {
            #[prost(string, optional, tag="1")]
            pub title: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="2")]
            pub profile_icon_url: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="3")]
            pub thumbnail_url: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="4")]
            pub video_url: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum ContentType {
            Default = 0,
            Carousel = 1,
        }
        impl ContentType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Default => "DEFAULT",
                    Self::Carousel => "CAROUSEL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DEFAULT" => Some(Self::Default),
                    "CAROUSEL" => Some(Self::Carousel),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AiRichResponseDynamicMetadata {
        #[prost(enumeration="ai_rich_response_dynamic_metadata::AiRichResponseDynamicMetadataType", optional, tag="1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(uint64, optional, tag="2")]
        pub version: ::core::option::Option<u64>,
        #[prost(string, optional, tag="3")]
        pub url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag="4")]
        pub loop_count: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `AIRichResponseDynamicMetadata`.
    pub mod ai_rich_response_dynamic_metadata {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum AiRichResponseDynamicMetadataType {
            Unknown = 0,
            Image = 1,
            Gif = 2,
        }
        impl AiRichResponseDynamicMetadataType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "AI_RICH_RESPONSE_DYNAMIC_METADATA_TYPE_UNKNOWN",
                    Self::Image => "AI_RICH_RESPONSE_DYNAMIC_METADATA_TYPE_IMAGE",
                    Self::Gif => "AI_RICH_RESPONSE_DYNAMIC_METADATA_TYPE_GIF",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "AI_RICH_RESPONSE_DYNAMIC_METADATA_TYPE_UNKNOWN" => Some(Self::Unknown),
                    "AI_RICH_RESPONSE_DYNAMIC_METADATA_TYPE_IMAGE" => Some(Self::Image),
                    "AI_RICH_RESPONSE_DYNAMIC_METADATA_TYPE_GIF" => Some(Self::Gif),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AiRichResponseGridImageMetadata {
        #[prost(message, optional, tag="1")]
        pub grid_image_url: ::core::option::Option<AiRichResponseImageUrl>,
        #[prost(message, repeated, tag="2")]
        pub image_urls: ::prost::alloc::vec::Vec<AiRichResponseImageUrl>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AiRichResponseImageUrl {
        #[prost(string, optional, tag="1")]
        pub image_preview_url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub image_high_res_url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="3")]
        pub source_url: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AiRichResponseInlineImageMetadata {
        #[prost(message, optional, tag="1")]
        pub image_url: ::core::option::Option<AiRichResponseImageUrl>,
        #[prost(string, optional, tag="2")]
        pub image_text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration="ai_rich_response_inline_image_metadata::AiRichResponseImageAlignment", optional, tag="3")]
        pub alignment: ::core::option::Option<i32>,
        #[prost(string, optional, tag="4")]
        pub tap_link_url: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `AIRichResponseInlineImageMetadata`.
    pub mod ai_rich_response_inline_image_metadata {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum AiRichResponseImageAlignment {
            AiRichResponseImageLayoutLeadingAligned = 0,
            AiRichResponseImageLayoutTrailingAligned = 1,
            AiRichResponseImageLayoutCenterAligned = 2,
        }
        impl AiRichResponseImageAlignment {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::AiRichResponseImageLayoutLeadingAligned => "AI_RICH_RESPONSE_IMAGE_LAYOUT_LEADING_ALIGNED",
                    Self::AiRichResponseImageLayoutTrailingAligned => "AI_RICH_RESPONSE_IMAGE_LAYOUT_TRAILING_ALIGNED",
                    Self::AiRichResponseImageLayoutCenterAligned => "AI_RICH_RESPONSE_IMAGE_LAYOUT_CENTER_ALIGNED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "AI_RICH_RESPONSE_IMAGE_LAYOUT_LEADING_ALIGNED" => Some(Self::AiRichResponseImageLayoutLeadingAligned),
                    "AI_RICH_RESPONSE_IMAGE_LAYOUT_TRAILING_ALIGNED" => Some(Self::AiRichResponseImageLayoutTrailingAligned),
                    "AI_RICH_RESPONSE_IMAGE_LAYOUT_CENTER_ALIGNED" => Some(Self::AiRichResponseImageLayoutCenterAligned),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AiRichResponseLatexMetadata {
        #[prost(string, optional, tag="1")]
        pub text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="2")]
        pub expressions: ::prost::alloc::vec::Vec<ai_rich_response_latex_metadata::AiRichResponseLatexExpression>,
    }
    /// Nested message and enum types in `AIRichResponseLatexMetadata`.
    pub mod ai_rich_response_latex_metadata {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AiRichResponseLatexExpression {
            #[prost(string, optional, tag="1")]
            pub latex_expression: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="2")]
            pub url: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(double, optional, tag="3")]
            pub width: ::core::option::Option<f64>,
            #[prost(double, optional, tag="4")]
            pub height: ::core::option::Option<f64>,
            #[prost(double, optional, tag="5")]
            pub font_height: ::core::option::Option<f64>,
            #[prost(double, optional, tag="6")]
            pub image_top_padding: ::core::option::Option<f64>,
            #[prost(double, optional, tag="7")]
            pub image_leading_padding: ::core::option::Option<f64>,
            #[prost(double, optional, tag="8")]
            pub image_bottom_padding: ::core::option::Option<f64>,
            #[prost(double, optional, tag="9")]
            pub image_trailing_padding: ::core::option::Option<f64>,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AiRichResponseMapMetadata {
        #[prost(double, optional, tag="1")]
        pub center_latitude: ::core::option::Option<f64>,
        #[prost(double, optional, tag="2")]
        pub center_longitude: ::core::option::Option<f64>,
        #[prost(double, optional, tag="3")]
        pub latitude_delta: ::core::option::Option<f64>,
        #[prost(double, optional, tag="4")]
        pub longitude_delta: ::core::option::Option<f64>,
        #[prost(message, repeated, tag="5")]
        pub annotations: ::prost::alloc::vec::Vec<ai_rich_response_map_metadata::AiRichResponseMapAnnotation>,
        #[prost(bool, optional, tag="6")]
        pub show_info_list: ::core::option::Option<bool>,
    }
    /// Nested message and enum types in `AIRichResponseMapMetadata`.
    pub mod ai_rich_response_map_metadata {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AiRichResponseMapAnnotation {
            #[prost(uint32, optional, tag="1")]
            pub annotation_number: ::core::option::Option<u32>,
            #[prost(double, optional, tag="2")]
            pub latitude: ::core::option::Option<f64>,
            #[prost(double, optional, tag="3")]
            pub longitude: ::core::option::Option<f64>,
            #[prost(string, optional, tag="4")]
            pub title: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="5")]
            pub body: ::core::option::Option<::prost::alloc::string::String>,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AiRichResponseSubMessage {
        #[prost(enumeration="AiRichResponseSubMessageType", optional, tag="1")]
        pub message_type: ::core::option::Option<i32>,
        #[prost(message, optional, tag="2")]
        pub grid_image_metadata: ::core::option::Option<AiRichResponseGridImageMetadata>,
        #[prost(string, optional, tag="3")]
        pub message_text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, tag="4")]
        pub image_metadata: ::core::option::Option<AiRichResponseInlineImageMetadata>,
        #[prost(message, optional, tag="5")]
        pub code_metadata: ::core::option::Option<AiRichResponseCodeMetadata>,
        #[prost(message, optional, tag="6")]
        pub table_metadata: ::core::option::Option<AiRichResponseTableMetadata>,
        #[prost(message, optional, tag="7")]
        pub dynamic_metadata: ::core::option::Option<AiRichResponseDynamicMetadata>,
        #[prost(message, optional, tag="8")]
        pub latex_metadata: ::core::option::Option<AiRichResponseLatexMetadata>,
        #[prost(message, optional, tag="9")]
        pub map_metadata: ::core::option::Option<AiRichResponseMapMetadata>,
        #[prost(message, optional, tag="10")]
        pub content_items_metadata: ::core::option::Option<AiRichResponseContentItemsMetadata>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AiRichResponseTableMetadata {
        #[prost(message, repeated, tag="1")]
        pub rows: ::prost::alloc::vec::Vec<ai_rich_response_table_metadata::AiRichResponseTableRow>,
    }
    /// Nested message and enum types in `AIRichResponseTableMetadata`.
    pub mod ai_rich_response_table_metadata {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AiRichResponseTableRow {
            #[prost(string, repeated, tag="1")]
            pub items: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(bool, optional, tag="2")]
            pub is_heading: ::core::option::Option<bool>,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AiRichResponseUnifiedResponse {
        #[prost(bytes="vec", optional, tag="1")]
        pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AiRichResponseMessageType {
        AiRichResponseTypeUnknown = 0,
        AiRichResponseTypeStandard = 1,
    }
    impl AiRichResponseMessageType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::AiRichResponseTypeUnknown => "AI_RICH_RESPONSE_TYPE_UNKNOWN",
                Self::AiRichResponseTypeStandard => "AI_RICH_RESPONSE_TYPE_STANDARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AI_RICH_RESPONSE_TYPE_UNKNOWN" => Some(Self::AiRichResponseTypeUnknown),
                "AI_RICH_RESPONSE_TYPE_STANDARD" => Some(Self::AiRichResponseTypeStandard),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AiRichResponseSubMessageType {
        AiRichResponseUnknown = 0,
        AiRichResponseGridImage = 1,
        AiRichResponseText = 2,
        AiRichResponseInlineImage = 3,
        AiRichResponseTable = 4,
        AiRichResponseCode = 5,
        AiRichResponseDynamic = 6,
        AiRichResponseMap = 7,
        AiRichResponseLatex = 8,
        AiRichResponseContentItems = 9,
    }
    impl AiRichResponseSubMessageType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::AiRichResponseUnknown => "AI_RICH_RESPONSE_UNKNOWN",
                Self::AiRichResponseGridImage => "AI_RICH_RESPONSE_GRID_IMAGE",
                Self::AiRichResponseText => "AI_RICH_RESPONSE_TEXT",
                Self::AiRichResponseInlineImage => "AI_RICH_RESPONSE_INLINE_IMAGE",
                Self::AiRichResponseTable => "AI_RICH_RESPONSE_TABLE",
                Self::AiRichResponseCode => "AI_RICH_RESPONSE_CODE",
                Self::AiRichResponseDynamic => "AI_RICH_RESPONSE_DYNAMIC",
                Self::AiRichResponseMap => "AI_RICH_RESPONSE_MAP",
                Self::AiRichResponseLatex => "AI_RICH_RESPONSE_LATEX",
                Self::AiRichResponseContentItems => "AI_RICH_RESPONSE_CONTENT_ITEMS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AI_RICH_RESPONSE_UNKNOWN" => Some(Self::AiRichResponseUnknown),
                "AI_RICH_RESPONSE_GRID_IMAGE" => Some(Self::AiRichResponseGridImage),
                "AI_RICH_RESPONSE_TEXT" => Some(Self::AiRichResponseText),
                "AI_RICH_RESPONSE_INLINE_IMAGE" => Some(Self::AiRichResponseInlineImage),
                "AI_RICH_RESPONSE_TABLE" => Some(Self::AiRichResponseTable),
                "AI_RICH_RESPONSE_CODE" => Some(Self::AiRichResponseCode),
                "AI_RICH_RESPONSE_DYNAMIC" => Some(Self::AiRichResponseDynamic),
                "AI_RICH_RESPONSE_MAP" => Some(Self::AiRichResponseMap),
                "AI_RICH_RESPONSE_LATEX" => Some(Self::AiRichResponseLatex),
                "AI_RICH_RESPONSE_CONTENT_ITEMS" => Some(Self::AiRichResponseContentItems),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Account {
    #[prost(string, optional, tag="1")]
    pub lid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub username: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub country_code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="4")]
    pub is_username_deleted: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ActionLink {
    #[prost(string, optional, tag="1")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub button_title: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AutoDownloadSettings {
    #[prost(bool, optional, tag="1")]
    pub download_images: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="2")]
    pub download_audio: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="3")]
    pub download_video: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="4")]
    pub download_documents: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AvatarUserSettings {
    #[prost(string, optional, tag="1")]
    pub fbid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub password: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BizAccountLinkInfo {
    #[prost(uint64, optional, tag="1")]
    pub whatsapp_biz_acct_fbid: ::core::option::Option<u64>,
    #[prost(string, optional, tag="2")]
    pub whatsapp_acct_number: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag="3")]
    pub issue_time: ::core::option::Option<u64>,
    #[prost(enumeration="biz_account_link_info::HostStorageType", optional, tag="4")]
    pub host_storage: ::core::option::Option<i32>,
    #[prost(enumeration="biz_account_link_info::AccountType", optional, tag="5")]
    pub account_type: ::core::option::Option<i32>,
}
/// Nested message and enum types in `BizAccountLinkInfo`.
pub mod biz_account_link_info {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AccountType {
        Enterprise = 0,
    }
    impl AccountType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Enterprise => "ENTERPRISE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENTERPRISE" => Some(Self::Enterprise),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum HostStorageType {
        OnPremise = 0,
        Facebook = 1,
    }
    impl HostStorageType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::OnPremise => "ON_PREMISE",
                Self::Facebook => "FACEBOOK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ON_PREMISE" => Some(Self::OnPremise),
                "FACEBOOK" => Some(Self::Facebook),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BizAccountPayload {
    #[prost(message, optional, tag="1")]
    pub vname_cert: ::core::option::Option<VerifiedNameCertificate>,
    #[prost(bytes="vec", optional, tag="2")]
    pub biz_acct_link_info: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BizIdentityInfo {
    #[prost(enumeration="biz_identity_info::VerifiedLevelValue", optional, tag="1")]
    pub vlevel: ::core::option::Option<i32>,
    #[prost(message, optional, tag="2")]
    pub vname_cert: ::core::option::Option<VerifiedNameCertificate>,
    #[prost(bool, optional, tag="3")]
    pub signed: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="4")]
    pub revoked: ::core::option::Option<bool>,
    #[prost(enumeration="biz_identity_info::HostStorageType", optional, tag="5")]
    pub host_storage: ::core::option::Option<i32>,
    #[prost(enumeration="biz_identity_info::ActualActorsType", optional, tag="6")]
    pub actual_actors: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag="7")]
    pub privacy_mode_ts: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="8")]
    pub feature_controls: ::core::option::Option<u64>,
}
/// Nested message and enum types in `BizIdentityInfo`.
pub mod biz_identity_info {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ActualActorsType {
        Self_ = 0,
        Bsp = 1,
    }
    impl ActualActorsType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Self_ => "SELF",
                Self::Bsp => "BSP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SELF" => Some(Self::Self_),
                "BSP" => Some(Self::Bsp),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum HostStorageType {
        OnPremise = 0,
        Facebook = 1,
    }
    impl HostStorageType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::OnPremise => "ON_PREMISE",
                Self::Facebook => "FACEBOOK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ON_PREMISE" => Some(Self::OnPremise),
                "FACEBOOK" => Some(Self::Facebook),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum VerifiedLevelValue {
        Unknown = 0,
        Low = 1,
        High = 2,
    }
    impl VerifiedLevelValue {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Low => "LOW",
                Self::High => "HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "LOW" => Some(Self::Low),
                "HIGH" => Some(Self::High),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotAgeCollectionMetadata {
    #[prost(bool, optional, tag="1")]
    pub age_collection_eligible: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="2")]
    pub should_trigger_age_collection_on_client: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotAvatarMetadata {
    #[prost(uint32, optional, tag="1")]
    pub sentiment: ::core::option::Option<u32>,
    #[prost(string, optional, tag="2")]
    pub behavior_graph: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="3")]
    pub action: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub intensity: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub word_count: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotCapabilityMetadata {
    #[prost(enumeration="bot_capability_metadata::BotCapabilityType", repeated, packed="false", tag="1")]
    pub capabilities: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `BotCapabilityMetadata`.
pub mod bot_capability_metadata {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum BotCapabilityType {
        Unknown = 0,
        ProgressIndicator = 1,
        RichResponseHeading = 2,
        RichResponseNestedList = 3,
        AiMemory = 4,
        RichResponseThreadSurfing = 5,
        RichResponseTable = 6,
        RichResponseCode = 7,
        RichResponseStructuredResponse = 8,
        RichResponseInlineImage = 9,
        WaIg1pPluginRankingControl = 10,
        WaIg1pPluginRankingUpdate1 = 11,
        WaIg1pPluginRankingUpdate2 = 12,
        WaIg1pPluginRankingUpdate3 = 13,
        WaIg1pPluginRankingUpdate4 = 14,
        WaIg1pPluginRankingUpdate5 = 15,
        WaIg1pPluginRankingUpdate6 = 16,
        WaIg1pPluginRankingUpdate7 = 17,
        WaIg1pPluginRankingUpdate8 = 18,
        WaIg1pPluginRankingUpdate9 = 19,
        WaIg1pPluginRankingUpdate10 = 20,
        RichResponseSubHeading = 21,
        RichResponseGridImage = 22,
        AiStudioUgcMemory = 23,
        RichResponseLatex = 24,
        RichResponseMaps = 25,
        RichResponseInlineReels = 26,
        AgenticPlanning = 27,
        AccountLinking = 28,
        StreamingDisaggregation = 29,
        RichResponseGridImage3p = 30,
        RichResponseLatexInline = 31,
        QueryPlan = 32,
        ProactiveMessage = 33,
        RichResponseUnifiedResponse = 34,
        PromotionMessage = 35,
    }
    impl BotCapabilityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::ProgressIndicator => "PROGRESS_INDICATOR",
                Self::RichResponseHeading => "RICH_RESPONSE_HEADING",
                Self::RichResponseNestedList => "RICH_RESPONSE_NESTED_LIST",
                Self::AiMemory => "AI_MEMORY",
                Self::RichResponseThreadSurfing => "RICH_RESPONSE_THREAD_SURFING",
                Self::RichResponseTable => "RICH_RESPONSE_TABLE",
                Self::RichResponseCode => "RICH_RESPONSE_CODE",
                Self::RichResponseStructuredResponse => "RICH_RESPONSE_STRUCTURED_RESPONSE",
                Self::RichResponseInlineImage => "RICH_RESPONSE_INLINE_IMAGE",
                Self::WaIg1pPluginRankingControl => "WA_IG_1P_PLUGIN_RANKING_CONTROL",
                Self::WaIg1pPluginRankingUpdate1 => "WA_IG_1P_PLUGIN_RANKING_UPDATE_1",
                Self::WaIg1pPluginRankingUpdate2 => "WA_IG_1P_PLUGIN_RANKING_UPDATE_2",
                Self::WaIg1pPluginRankingUpdate3 => "WA_IG_1P_PLUGIN_RANKING_UPDATE_3",
                Self::WaIg1pPluginRankingUpdate4 => "WA_IG_1P_PLUGIN_RANKING_UPDATE_4",
                Self::WaIg1pPluginRankingUpdate5 => "WA_IG_1P_PLUGIN_RANKING_UPDATE_5",
                Self::WaIg1pPluginRankingUpdate6 => "WA_IG_1P_PLUGIN_RANKING_UPDATE_6",
                Self::WaIg1pPluginRankingUpdate7 => "WA_IG_1P_PLUGIN_RANKING_UPDATE_7",
                Self::WaIg1pPluginRankingUpdate8 => "WA_IG_1P_PLUGIN_RANKING_UPDATE_8",
                Self::WaIg1pPluginRankingUpdate9 => "WA_IG_1P_PLUGIN_RANKING_UPDATE_9",
                Self::WaIg1pPluginRankingUpdate10 => "WA_IG_1P_PLUGIN_RANKING_UPDATE_10",
                Self::RichResponseSubHeading => "RICH_RESPONSE_SUB_HEADING",
                Self::RichResponseGridImage => "RICH_RESPONSE_GRID_IMAGE",
                Self::AiStudioUgcMemory => "AI_STUDIO_UGC_MEMORY",
                Self::RichResponseLatex => "RICH_RESPONSE_LATEX",
                Self::RichResponseMaps => "RICH_RESPONSE_MAPS",
                Self::RichResponseInlineReels => "RICH_RESPONSE_INLINE_REELS",
                Self::AgenticPlanning => "AGENTIC_PLANNING",
                Self::AccountLinking => "ACCOUNT_LINKING",
                Self::StreamingDisaggregation => "STREAMING_DISAGGREGATION",
                Self::RichResponseGridImage3p => "RICH_RESPONSE_GRID_IMAGE_3P",
                Self::RichResponseLatexInline => "RICH_RESPONSE_LATEX_INLINE",
                Self::QueryPlan => "QUERY_PLAN",
                Self::ProactiveMessage => "PROACTIVE_MESSAGE",
                Self::RichResponseUnifiedResponse => "RICH_RESPONSE_UNIFIED_RESPONSE",
                Self::PromotionMessage => "PROMOTION_MESSAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "PROGRESS_INDICATOR" => Some(Self::ProgressIndicator),
                "RICH_RESPONSE_HEADING" => Some(Self::RichResponseHeading),
                "RICH_RESPONSE_NESTED_LIST" => Some(Self::RichResponseNestedList),
                "AI_MEMORY" => Some(Self::AiMemory),
                "RICH_RESPONSE_THREAD_SURFING" => Some(Self::RichResponseThreadSurfing),
                "RICH_RESPONSE_TABLE" => Some(Self::RichResponseTable),
                "RICH_RESPONSE_CODE" => Some(Self::RichResponseCode),
                "RICH_RESPONSE_STRUCTURED_RESPONSE" => Some(Self::RichResponseStructuredResponse),
                "RICH_RESPONSE_INLINE_IMAGE" => Some(Self::RichResponseInlineImage),
                "WA_IG_1P_PLUGIN_RANKING_CONTROL" => Some(Self::WaIg1pPluginRankingControl),
                "WA_IG_1P_PLUGIN_RANKING_UPDATE_1" => Some(Self::WaIg1pPluginRankingUpdate1),
                "WA_IG_1P_PLUGIN_RANKING_UPDATE_2" => Some(Self::WaIg1pPluginRankingUpdate2),
                "WA_IG_1P_PLUGIN_RANKING_UPDATE_3" => Some(Self::WaIg1pPluginRankingUpdate3),
                "WA_IG_1P_PLUGIN_RANKING_UPDATE_4" => Some(Self::WaIg1pPluginRankingUpdate4),
                "WA_IG_1P_PLUGIN_RANKING_UPDATE_5" => Some(Self::WaIg1pPluginRankingUpdate5),
                "WA_IG_1P_PLUGIN_RANKING_UPDATE_6" => Some(Self::WaIg1pPluginRankingUpdate6),
                "WA_IG_1P_PLUGIN_RANKING_UPDATE_7" => Some(Self::WaIg1pPluginRankingUpdate7),
                "WA_IG_1P_PLUGIN_RANKING_UPDATE_8" => Some(Self::WaIg1pPluginRankingUpdate8),
                "WA_IG_1P_PLUGIN_RANKING_UPDATE_9" => Some(Self::WaIg1pPluginRankingUpdate9),
                "WA_IG_1P_PLUGIN_RANKING_UPDATE_10" => Some(Self::WaIg1pPluginRankingUpdate10),
                "RICH_RESPONSE_SUB_HEADING" => Some(Self::RichResponseSubHeading),
                "RICH_RESPONSE_GRID_IMAGE" => Some(Self::RichResponseGridImage),
                "AI_STUDIO_UGC_MEMORY" => Some(Self::AiStudioUgcMemory),
                "RICH_RESPONSE_LATEX" => Some(Self::RichResponseLatex),
                "RICH_RESPONSE_MAPS" => Some(Self::RichResponseMaps),
                "RICH_RESPONSE_INLINE_REELS" => Some(Self::RichResponseInlineReels),
                "AGENTIC_PLANNING" => Some(Self::AgenticPlanning),
                "ACCOUNT_LINKING" => Some(Self::AccountLinking),
                "STREAMING_DISAGGREGATION" => Some(Self::StreamingDisaggregation),
                "RICH_RESPONSE_GRID_IMAGE_3P" => Some(Self::RichResponseGridImage3p),
                "RICH_RESPONSE_LATEX_INLINE" => Some(Self::RichResponseLatexInline),
                "QUERY_PLAN" => Some(Self::QueryPlan),
                "PROACTIVE_MESSAGE" => Some(Self::ProactiveMessage),
                "RICH_RESPONSE_UNIFIED_RESPONSE" => Some(Self::RichResponseUnifiedResponse),
                "PROMOTION_MESSAGE" => Some(Self::PromotionMessage),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotImagineMetadata {
    #[prost(enumeration="bot_imagine_metadata::ImagineType", optional, tag="1")]
    pub imagine_type: ::core::option::Option<i32>,
}
/// Nested message and enum types in `BotImagineMetadata`.
pub mod bot_imagine_metadata {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ImagineType {
        Unknown = 0,
        Imagine = 1,
        Memu = 2,
        Flash = 3,
        Edit = 4,
    }
    impl ImagineType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Imagine => "IMAGINE",
                Self::Memu => "MEMU",
                Self::Flash => "FLASH",
                Self::Edit => "EDIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "IMAGINE" => Some(Self::Imagine),
                "MEMU" => Some(Self::Memu),
                "FLASH" => Some(Self::Flash),
                "EDIT" => Some(Self::Edit),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotLinkedAccount {
    #[prost(enumeration="bot_linked_account::BotLinkedAccountType", optional, tag="1")]
    pub r#type: ::core::option::Option<i32>,
}
/// Nested message and enum types in `BotLinkedAccount`.
pub mod bot_linked_account {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum BotLinkedAccountType {
        BotLinkedAccountType1p = 0,
    }
    impl BotLinkedAccountType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::BotLinkedAccountType1p => "BOT_LINKED_ACCOUNT_TYPE_1P",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BOT_LINKED_ACCOUNT_TYPE_1P" => Some(Self::BotLinkedAccountType1p),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BotLinkedAccountsMetadata {
    #[prost(message, repeated, tag="1")]
    pub accounts: ::prost::alloc::vec::Vec<BotLinkedAccount>,
    #[prost(bytes="vec", optional, tag="2")]
    pub ac_auth_tokens: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag="3")]
    pub ac_error_code: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotMediaMetadata {
    #[prost(string, optional, tag="1")]
    pub file_sha256: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub media_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub file_enc_sha256: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub direct_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag="5")]
    pub media_key_timestamp: ::core::option::Option<i64>,
    #[prost(string, optional, tag="6")]
    pub mimetype: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration="bot_media_metadata::OrientationType", optional, tag="7")]
    pub orientation_type: ::core::option::Option<i32>,
}
/// Nested message and enum types in `BotMediaMetadata`.
pub mod bot_media_metadata {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum OrientationType {
        Center = 1,
        Left = 2,
        Right = 3,
    }
    impl OrientationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Center => "CENTER",
                Self::Left => "LEFT",
                Self::Right => "RIGHT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CENTER" => Some(Self::Center),
                "LEFT" => Some(Self::Left),
                "RIGHT" => Some(Self::Right),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotMemoryFact {
    #[prost(string, optional, tag="1")]
    pub fact: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub fact_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BotMemoryMetadata {
    #[prost(message, repeated, tag="1")]
    pub added_facts: ::prost::alloc::vec::Vec<BotMemoryFact>,
    #[prost(message, repeated, tag="2")]
    pub removed_facts: ::prost::alloc::vec::Vec<BotMemoryFact>,
    #[prost(string, optional, tag="3")]
    pub disclaimer: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BotMemuMetadata {
    #[prost(message, repeated, tag="1")]
    pub face_images: ::prost::alloc::vec::Vec<BotMediaMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BotMetadata {
    #[prost(message, optional, tag="1")]
    pub avatar_metadata: ::core::option::Option<BotAvatarMetadata>,
    #[prost(string, optional, tag="2")]
    pub persona_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="3")]
    pub plugin_metadata: ::core::option::Option<BotPluginMetadata>,
    #[prost(message, optional, tag="4")]
    pub suggested_prompt_metadata: ::core::option::Option<BotSuggestedPromptMetadata>,
    #[prost(string, optional, tag="5")]
    pub invoker_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="6")]
    pub session_metadata: ::core::option::Option<BotSessionMetadata>,
    #[prost(message, optional, tag="7")]
    pub memu_metadata: ::core::option::Option<BotMemuMetadata>,
    #[prost(string, optional, tag="8")]
    pub timezone: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="9")]
    pub reminder_metadata: ::core::option::Option<BotReminderMetadata>,
    #[prost(message, optional, tag="10")]
    pub model_metadata: ::core::option::Option<BotModelMetadata>,
    #[prost(string, optional, tag="11")]
    pub message_disclaimer_text: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="12")]
    pub progress_indicator_metadata: ::core::option::Option<BotProgressIndicatorMetadata>,
    #[prost(message, optional, tag="13")]
    pub capability_metadata: ::core::option::Option<BotCapabilityMetadata>,
    #[prost(message, optional, tag="14")]
    pub imagine_metadata: ::core::option::Option<BotImagineMetadata>,
    #[prost(message, optional, tag="15")]
    pub memory_metadata: ::core::option::Option<BotMemoryMetadata>,
    #[prost(message, optional, tag="16")]
    pub rendering_metadata: ::core::option::Option<BotRenderingMetadata>,
    #[prost(message, optional, tag="17")]
    pub bot_metrics_metadata: ::core::option::Option<BotMetricsMetadata>,
    #[prost(message, optional, tag="18")]
    pub bot_linked_accounts_metadata: ::core::option::Option<BotLinkedAccountsMetadata>,
    #[prost(message, optional, tag="19")]
    pub rich_response_sources_metadata: ::core::option::Option<BotSourcesMetadata>,
    #[prost(bytes="vec", optional, tag="20")]
    pub ai_conversation_context: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag="21")]
    pub bot_promotion_message_metadata: ::core::option::Option<BotPromotionMessageMetadata>,
    #[prost(message, optional, tag="22")]
    pub bot_mode_selection_metadata: ::core::option::Option<BotModeSelectionMetadata>,
    #[prost(message, optional, tag="23")]
    pub bot_quota_metadata: ::core::option::Option<BotQuotaMetadata>,
    #[prost(message, optional, tag="24")]
    pub bot_age_collection_metadata: ::core::option::Option<BotAgeCollectionMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotMetricsMetadata {
    #[prost(string, optional, tag="1")]
    pub destination_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration="BotMetricsEntryPoint", optional, tag="2")]
    pub destination_entry_point: ::core::option::Option<i32>,
    #[prost(enumeration="BotMetricsThreadEntryPoint", optional, tag="3")]
    pub thread_origin: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotModeSelectionMetadata {
    #[prost(enumeration="bot_mode_selection_metadata::BotUserSelectionMode", repeated, packed="false", tag="1")]
    pub mode: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `BotModeSelectionMetadata`.
pub mod bot_mode_selection_metadata {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum BotUserSelectionMode {
        UnknownMode = 0,
        ReasoningMode = 1,
    }
    impl BotUserSelectionMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownMode => "UNKNOWN_MODE",
                Self::ReasoningMode => "REASONING_MODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_MODE" => Some(Self::UnknownMode),
                "REASONING_MODE" => Some(Self::ReasoningMode),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotModelMetadata {
    #[prost(enumeration="bot_model_metadata::ModelType", optional, tag="1")]
    pub model_type: ::core::option::Option<i32>,
    #[prost(enumeration="bot_model_metadata::PremiumModelStatus", optional, tag="2")]
    pub premium_model_status: ::core::option::Option<i32>,
}
/// Nested message and enum types in `BotModelMetadata`.
pub mod bot_model_metadata {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ModelType {
        UnknownType = 0,
        LlamaProd = 1,
        LlamaProdPremium = 2,
    }
    impl ModelType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownType => "UNKNOWN_TYPE",
                Self::LlamaProd => "LLAMA_PROD",
                Self::LlamaProdPremium => "LLAMA_PROD_PREMIUM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_TYPE" => Some(Self::UnknownType),
                "LLAMA_PROD" => Some(Self::LlamaProd),
                "LLAMA_PROD_PREMIUM" => Some(Self::LlamaProdPremium),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum PremiumModelStatus {
        UnknownStatus = 0,
        Available = 1,
        QuotaExceedLimit = 2,
    }
    impl PremiumModelStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownStatus => "UNKNOWN_STATUS",
                Self::Available => "AVAILABLE",
                Self::QuotaExceedLimit => "QUOTA_EXCEED_LIMIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_STATUS" => Some(Self::UnknownStatus),
                "AVAILABLE" => Some(Self::Available),
                "QUOTA_EXCEED_LIMIT" => Some(Self::QuotaExceedLimit),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotPluginMetadata {
    #[prost(enumeration="bot_plugin_metadata::SearchProvider", optional, tag="1")]
    pub provider: ::core::option::Option<i32>,
    #[prost(enumeration="bot_plugin_metadata::PluginType", optional, tag="2")]
    pub plugin_type: ::core::option::Option<i32>,
    #[prost(string, optional, tag="3")]
    pub thumbnail_cdn_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub profile_photo_cdn_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="5")]
    pub search_provider_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="6")]
    pub reference_index: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="7")]
    pub expected_links_count: ::core::option::Option<u32>,
    #[prost(string, optional, tag="9")]
    pub search_query: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="10")]
    pub parent_plugin_message_key: ::core::option::Option<MessageKey>,
    #[prost(enumeration="bot_plugin_metadata::PluginType", optional, tag="11")]
    pub deprecated_field: ::core::option::Option<i32>,
    #[prost(enumeration="bot_plugin_metadata::PluginType", optional, tag="12")]
    pub parent_plugin_type: ::core::option::Option<i32>,
    #[prost(string, optional, tag="13")]
    pub favicon_cdn_url: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `BotPluginMetadata`.
pub mod bot_plugin_metadata {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum PluginType {
        UnknownPlugin = 0,
        Reels = 1,
        Search = 2,
    }
    impl PluginType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownPlugin => "UNKNOWN_PLUGIN",
                Self::Reels => "REELS",
                Self::Search => "SEARCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_PLUGIN" => Some(Self::UnknownPlugin),
                "REELS" => Some(Self::Reels),
                "SEARCH" => Some(Self::Search),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SearchProvider {
        Unknown = 0,
        Bing = 1,
        Google = 2,
        Support = 3,
    }
    impl SearchProvider {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Bing => "BING",
                Self::Google => "GOOGLE",
                Self::Support => "SUPPORT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "BING" => Some(Self::Bing),
                "GOOGLE" => Some(Self::Google),
                "SUPPORT" => Some(Self::Support),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BotProgressIndicatorMetadata {
    #[prost(string, optional, tag="1")]
    pub progress_description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="2")]
    pub steps_metadata: ::prost::alloc::vec::Vec<bot_progress_indicator_metadata::BotPlanningStepMetadata>,
}
/// Nested message and enum types in `BotProgressIndicatorMetadata`.
pub mod bot_progress_indicator_metadata {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BotPlanningStepMetadata {
        #[prost(string, optional, tag="1")]
        pub status_title: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub status_body: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="3")]
        pub sources_metadata: ::prost::alloc::vec::Vec<bot_planning_step_metadata::BotPlanningSearchSourcesMetadata>,
        #[prost(enumeration="bot_planning_step_metadata::PlanningStepStatus", optional, tag="4")]
        pub status: ::core::option::Option<i32>,
        #[prost(bool, optional, tag="5")]
        pub is_reasoning: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="6")]
        pub is_enhanced_search: ::core::option::Option<bool>,
        #[prost(message, repeated, tag="7")]
        pub sections: ::prost::alloc::vec::Vec<bot_planning_step_metadata::BotPlanningStepSectionMetadata>,
    }
    /// Nested message and enum types in `BotPlanningStepMetadata`.
    pub mod bot_planning_step_metadata {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct BotPlanningSearchSourceMetadata {
            #[prost(string, optional, tag="1")]
            pub title: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(enumeration="BotSearchSourceProvider", optional, tag="2")]
            pub provider: ::core::option::Option<i32>,
            #[prost(string, optional, tag="3")]
            pub source_url: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="4")]
            pub fav_icon_url: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct BotPlanningSearchSourcesMetadata {
            #[prost(string, optional, tag="1")]
            pub source_title: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(enumeration="bot_planning_search_sources_metadata::BotPlanningSearchSourceProvider", optional, tag="2")]
            pub provider: ::core::option::Option<i32>,
            #[prost(string, optional, tag="3")]
            pub source_url: ::core::option::Option<::prost::alloc::string::String>,
        }
        /// Nested message and enum types in `BotPlanningSearchSourcesMetadata`.
        pub mod bot_planning_search_sources_metadata {
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
            #[repr(i32)]
            pub enum BotPlanningSearchSourceProvider {
                Unknown = 0,
                Other = 1,
                Google = 2,
                Bing = 3,
            }
            impl BotPlanningSearchSourceProvider {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unknown => "UNKNOWN",
                        Self::Other => "OTHER",
                        Self::Google => "GOOGLE",
                        Self::Bing => "BING",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "UNKNOWN" => Some(Self::Unknown),
                        "OTHER" => Some(Self::Other),
                        "GOOGLE" => Some(Self::Google),
                        "BING" => Some(Self::Bing),
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BotPlanningStepSectionMetadata {
            #[prost(string, optional, tag="1")]
            pub section_title: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="2")]
            pub section_body: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(message, repeated, tag="3")]
            pub sources_metadata: ::prost::alloc::vec::Vec<BotPlanningSearchSourceMetadata>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum BotSearchSourceProvider {
            UnknownProvider = 0,
            Other = 1,
            Google = 2,
            Bing = 3,
        }
        impl BotSearchSourceProvider {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::UnknownProvider => "UNKNOWN_PROVIDER",
                    Self::Other => "OTHER",
                    Self::Google => "GOOGLE",
                    Self::Bing => "BING",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN_PROVIDER" => Some(Self::UnknownProvider),
                    "OTHER" => Some(Self::Other),
                    "GOOGLE" => Some(Self::Google),
                    "BING" => Some(Self::Bing),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum PlanningStepStatus {
            Unknown = 0,
            Planned = 1,
            Executing = 2,
            Finished = 3,
        }
        impl PlanningStepStatus {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::Planned => "PLANNED",
                    Self::Executing => "EXECUTING",
                    Self::Finished => "FINISHED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "PLANNED" => Some(Self::Planned),
                    "EXECUTING" => Some(Self::Executing),
                    "FINISHED" => Some(Self::Finished),
                    _ => None,
                }
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotPromotionMessageMetadata {
    #[prost(enumeration="bot_promotion_message_metadata::BotPromotionType", optional, tag="1")]
    pub promotion_type: ::core::option::Option<i32>,
    #[prost(string, optional, tag="2")]
    pub button_title: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `BotPromotionMessageMetadata`.
pub mod bot_promotion_message_metadata {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum BotPromotionType {
        UnknownType = 0,
        C50 = 1,
    }
    impl BotPromotionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownType => "UNKNOWN_TYPE",
                Self::C50 => "C50",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_TYPE" => Some(Self::UnknownType),
                "C50" => Some(Self::C50),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotPromptSuggestion {
    #[prost(string, optional, tag="1")]
    pub prompt: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub prompt_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BotPromptSuggestions {
    #[prost(message, repeated, tag="1")]
    pub suggestions: ::prost::alloc::vec::Vec<BotPromptSuggestion>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BotQuotaMetadata {
    #[prost(message, repeated, tag="1")]
    pub bot_feature_quota_metadata: ::prost::alloc::vec::Vec<bot_quota_metadata::BotFeatureQuotaMetadata>,
}
/// Nested message and enum types in `BotQuotaMetadata`.
pub mod bot_quota_metadata {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BotFeatureQuotaMetadata {
        #[prost(enumeration="bot_feature_quota_metadata::BotFeatureType", optional, tag="1")]
        pub feature_type: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag="2")]
        pub remaining_quota: ::core::option::Option<u32>,
        #[prost(uint64, optional, tag="3")]
        pub expiration_timestamp: ::core::option::Option<u64>,
    }
    /// Nested message and enum types in `BotFeatureQuotaMetadata`.
    pub mod bot_feature_quota_metadata {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum BotFeatureType {
            UnknownFeature = 0,
            ReasoningFeature = 1,
        }
        impl BotFeatureType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::UnknownFeature => "UNKNOWN_FEATURE",
                    Self::ReasoningFeature => "REASONING_FEATURE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN_FEATURE" => Some(Self::UnknownFeature),
                    "REASONING_FEATURE" => Some(Self::ReasoningFeature),
                    _ => None,
                }
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotReminderMetadata {
    #[prost(message, optional, tag="1")]
    pub request_message_key: ::core::option::Option<MessageKey>,
    #[prost(enumeration="bot_reminder_metadata::ReminderAction", optional, tag="2")]
    pub action: ::core::option::Option<i32>,
    #[prost(string, optional, tag="3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag="4")]
    pub next_trigger_timestamp: ::core::option::Option<u64>,
    #[prost(enumeration="bot_reminder_metadata::ReminderFrequency", optional, tag="5")]
    pub frequency: ::core::option::Option<i32>,
}
/// Nested message and enum types in `BotReminderMetadata`.
pub mod bot_reminder_metadata {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ReminderAction {
        Notify = 1,
        Create = 2,
        Delete = 3,
        Update = 4,
    }
    impl ReminderAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Notify => "NOTIFY",
                Self::Create => "CREATE",
                Self::Delete => "DELETE",
                Self::Update => "UPDATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NOTIFY" => Some(Self::Notify),
                "CREATE" => Some(Self::Create),
                "DELETE" => Some(Self::Delete),
                "UPDATE" => Some(Self::Update),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ReminderFrequency {
        Once = 1,
        Daily = 2,
        Weekly = 3,
        Biweekly = 4,
        Monthly = 5,
    }
    impl ReminderFrequency {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Once => "ONCE",
                Self::Daily => "DAILY",
                Self::Weekly => "WEEKLY",
                Self::Biweekly => "BIWEEKLY",
                Self::Monthly => "MONTHLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ONCE" => Some(Self::Once),
                "DAILY" => Some(Self::Daily),
                "WEEKLY" => Some(Self::Weekly),
                "BIWEEKLY" => Some(Self::Biweekly),
                "MONTHLY" => Some(Self::Monthly),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BotRenderingMetadata {
    #[prost(message, repeated, tag="1")]
    pub keywords: ::prost::alloc::vec::Vec<bot_rendering_metadata::Keyword>,
}
/// Nested message and enum types in `BotRenderingMetadata`.
pub mod bot_rendering_metadata {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Keyword {
        #[prost(string, optional, tag="1")]
        pub value: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, repeated, tag="2")]
        pub associated_prompts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotSessionMetadata {
    #[prost(string, optional, tag="1")]
    pub session_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration="BotSessionSource", optional, tag="2")]
    pub session_source: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BotSourcesMetadata {
    #[prost(message, repeated, tag="1")]
    pub sources: ::prost::alloc::vec::Vec<bot_sources_metadata::BotSourceItem>,
}
/// Nested message and enum types in `BotSourcesMetadata`.
pub mod bot_sources_metadata {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BotSourceItem {
        #[prost(enumeration="bot_source_item::SourceProvider", optional, tag="1")]
        pub provider: ::core::option::Option<i32>,
        #[prost(string, optional, tag="2")]
        pub thumbnail_cdn_url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="3")]
        pub source_provider_url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="4")]
        pub source_query: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="5")]
        pub favicon_cdn_url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag="6")]
        pub citation_number: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `BotSourceItem`.
    pub mod bot_source_item {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum SourceProvider {
            Unknown = 0,
            Bing = 1,
            Google = 2,
            Support = 3,
        }
        impl SourceProvider {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::Bing => "BING",
                    Self::Google => "GOOGLE",
                    Self::Support => "SUPPORT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "BING" => Some(Self::Bing),
                    "GOOGLE" => Some(Self::Google),
                    "SUPPORT" => Some(Self::Support),
                    _ => None,
                }
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BotSuggestedPromptMetadata {
    #[prost(string, repeated, tag="1")]
    pub suggested_prompts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="2")]
    pub selected_prompt_index: ::core::option::Option<u32>,
    #[prost(message, optional, tag="3")]
    pub prompt_suggestions: ::core::option::Option<BotPromptSuggestions>,
    #[prost(string, optional, tag="4")]
    pub selected_prompt_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallLogRecord {
    #[prost(enumeration="call_log_record::CallResult", optional, tag="1")]
    pub call_result: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="2")]
    pub is_dnd_mode: ::core::option::Option<bool>,
    #[prost(enumeration="call_log_record::SilenceReason", optional, tag="3")]
    pub silence_reason: ::core::option::Option<i32>,
    #[prost(int64, optional, tag="4")]
    pub duration: ::core::option::Option<i64>,
    #[prost(int64, optional, tag="5")]
    pub start_time: ::core::option::Option<i64>,
    #[prost(bool, optional, tag="6")]
    pub is_incoming: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="7")]
    pub is_video: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="8")]
    pub is_call_link: ::core::option::Option<bool>,
    #[prost(string, optional, tag="9")]
    pub call_link_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="10")]
    pub scheduled_call_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="11")]
    pub call_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="12")]
    pub call_creator_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="13")]
    pub group_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="14")]
    pub participants: ::prost::alloc::vec::Vec<call_log_record::ParticipantInfo>,
    #[prost(enumeration="call_log_record::CallType", optional, tag="15")]
    pub call_type: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CallLogRecord`.
pub mod call_log_record {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ParticipantInfo {
        #[prost(string, optional, tag="1")]
        pub user_jid: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration="CallResult", optional, tag="2")]
        pub call_result: ::core::option::Option<i32>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum CallResult {
        Connected = 0,
        Rejected = 1,
        Cancelled = 2,
        Acceptedelsewhere = 3,
        Missed = 4,
        Invalid = 5,
        Unavailable = 6,
        Upcoming = 7,
        Failed = 8,
        Abandoned = 9,
        Ongoing = 10,
    }
    impl CallResult {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Connected => "CONNECTED",
                Self::Rejected => "REJECTED",
                Self::Cancelled => "CANCELLED",
                Self::Acceptedelsewhere => "ACCEPTEDELSEWHERE",
                Self::Missed => "MISSED",
                Self::Invalid => "INVALID",
                Self::Unavailable => "UNAVAILABLE",
                Self::Upcoming => "UPCOMING",
                Self::Failed => "FAILED",
                Self::Abandoned => "ABANDONED",
                Self::Ongoing => "ONGOING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONNECTED" => Some(Self::Connected),
                "REJECTED" => Some(Self::Rejected),
                "CANCELLED" => Some(Self::Cancelled),
                "ACCEPTEDELSEWHERE" => Some(Self::Acceptedelsewhere),
                "MISSED" => Some(Self::Missed),
                "INVALID" => Some(Self::Invalid),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "UPCOMING" => Some(Self::Upcoming),
                "FAILED" => Some(Self::Failed),
                "ABANDONED" => Some(Self::Abandoned),
                "ONGOING" => Some(Self::Ongoing),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum CallType {
        Regular = 0,
        ScheduledCall = 1,
        VoiceChat = 2,
    }
    impl CallType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Regular => "REGULAR",
                Self::ScheduledCall => "SCHEDULED_CALL",
                Self::VoiceChat => "VOICE_CHAT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REGULAR" => Some(Self::Regular),
                "SCHEDULED_CALL" => Some(Self::ScheduledCall),
                "VOICE_CHAT" => Some(Self::VoiceChat),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SilenceReason {
        None = 0,
        Scheduled = 1,
        Privacy = 2,
        Lightweight = 3,
    }
    impl SilenceReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Scheduled => "SCHEDULED",
                Self::Privacy => "PRIVACY",
                Self::Lightweight => "LIGHTWEIGHT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "SCHEDULED" => Some(Self::Scheduled),
                "PRIVACY" => Some(Self::Privacy),
                "LIGHTWEIGHT" => Some(Self::Lightweight),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CertChain {
    #[prost(message, optional, tag="1")]
    pub leaf: ::core::option::Option<cert_chain::NoiseCertificate>,
    #[prost(message, optional, tag="2")]
    pub intermediate: ::core::option::Option<cert_chain::NoiseCertificate>,
}
/// Nested message and enum types in `CertChain`.
pub mod cert_chain {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct NoiseCertificate {
        #[prost(bytes="vec", optional, tag="1")]
        pub details: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="2")]
        pub signature: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    /// Nested message and enum types in `NoiseCertificate`.
    pub mod noise_certificate {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Details {
            #[prost(uint32, optional, tag="1")]
            pub serial: ::core::option::Option<u32>,
            #[prost(uint32, optional, tag="2")]
            pub issuer_serial: ::core::option::Option<u32>,
            #[prost(bytes="vec", optional, tag="3")]
            pub key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
            #[prost(uint64, optional, tag="4")]
            pub not_before: ::core::option::Option<u64>,
            #[prost(uint64, optional, tag="5")]
            pub not_after: ::core::option::Option<u64>,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatLockSettings {
    #[prost(bool, optional, tag="1")]
    pub hide_locked_chats: ::core::option::Option<bool>,
    #[prost(message, optional, tag="2")]
    pub secret_code: ::core::option::Option<UserPassword>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChatRowOpaqueData {
    #[prost(message, optional, tag="1")]
    pub draft_message: ::core::option::Option<chat_row_opaque_data::DraftMessage>,
}
/// Nested message and enum types in `ChatRowOpaqueData`.
pub mod chat_row_opaque_data {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DraftMessage {
        #[prost(string, optional, tag="1")]
        pub text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub omitted_url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, tag="3")]
        pub ctwa_context_link_data: ::core::option::Option<draft_message::CtwaContextLinkData>,
        #[prost(message, optional, tag="4")]
        pub ctwa_context: ::core::option::Option<draft_message::CtwaContextData>,
        #[prost(int64, optional, tag="5")]
        pub timestamp: ::core::option::Option<i64>,
    }
    /// Nested message and enum types in `DraftMessage`.
    pub mod draft_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CtwaContextData {
            #[prost(string, optional, tag="1")]
            pub conversion_source: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(bytes="vec", optional, tag="2")]
            pub conversion_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
            #[prost(string, optional, tag="3")]
            pub source_url: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="4")]
            pub source_id: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="5")]
            pub source_type: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="6")]
            pub title: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="7")]
            pub description: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="8")]
            pub thumbnail: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="9")]
            pub thumbnail_url: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(enumeration="ctwa_context_data::ContextInfoExternalAdReplyInfoMediaType", optional, tag="10")]
            pub media_type: ::core::option::Option<i32>,
            #[prost(string, optional, tag="11")]
            pub media_url: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(bool, optional, tag="12")]
            pub is_suspicious_link: ::core::option::Option<bool>,
        }
        /// Nested message and enum types in `CtwaContextData`.
        pub mod ctwa_context_data {
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
            #[repr(i32)]
            pub enum ContextInfoExternalAdReplyInfoMediaType {
                None = 0,
                Image = 1,
                Video = 2,
            }
            impl ContextInfoExternalAdReplyInfoMediaType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::None => "NONE",
                        Self::Image => "IMAGE",
                        Self::Video => "VIDEO",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "NONE" => Some(Self::None),
                        "IMAGE" => Some(Self::Image),
                        "VIDEO" => Some(Self::Video),
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CtwaContextLinkData {
            #[prost(string, optional, tag="1")]
            pub context: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="2")]
            pub source_url: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="3")]
            pub icebreaker: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="4")]
            pub phone: ::core::option::Option<::prost::alloc::string::String>,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Citation {
    #[prost(string, required, tag="1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, required, tag="2")]
    pub subtitle: ::prost::alloc::string::String,
    #[prost(string, required, tag="3")]
    pub cms_id: ::prost::alloc::string::String,
    #[prost(string, required, tag="4")]
    pub image_url: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClientPairingProps {
    #[prost(bool, optional, tag="1")]
    pub is_chat_db_lid_migrated: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="2")]
    pub is_syncd_pure_lid_session: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClientPayload {
    #[prost(uint64, optional, tag="1")]
    pub username: ::core::option::Option<u64>,
    #[prost(bool, optional, tag="3")]
    pub passive: ::core::option::Option<bool>,
    #[prost(message, optional, tag="5")]
    pub user_agent: ::core::option::Option<client_payload::UserAgent>,
    #[prost(message, optional, tag="6")]
    pub web_info: ::core::option::Option<client_payload::WebInfo>,
    #[prost(string, optional, tag="7")]
    pub push_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(sfixed32, optional, tag="9")]
    pub session_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="10")]
    pub short_connect: ::core::option::Option<bool>,
    #[prost(enumeration="client_payload::ConnectType", optional, tag="12")]
    pub connect_type: ::core::option::Option<i32>,
    #[prost(enumeration="client_payload::ConnectReason", optional, tag="13")]
    pub connect_reason: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed="false", tag="14")]
    pub shards: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag="15")]
    pub dns_source: ::core::option::Option<client_payload::DnsSource>,
    #[prost(uint32, optional, tag="16")]
    pub connect_attempt_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="18")]
    pub device: ::core::option::Option<u32>,
    #[prost(message, optional, tag="19")]
    pub device_pairing_data: ::core::option::Option<client_payload::DevicePairingRegistrationData>,
    #[prost(enumeration="client_payload::Product", optional, tag="20")]
    pub product: ::core::option::Option<i32>,
    #[prost(bytes="vec", optional, tag="21")]
    pub fb_cat: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="22")]
    pub fb_user_agent: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag="23")]
    pub oc: ::core::option::Option<bool>,
    #[prost(int32, optional, tag="24")]
    pub lc: ::core::option::Option<i32>,
    #[prost(enumeration="client_payload::IosAppExtension", optional, tag="30")]
    pub ios_app_extension: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag="31")]
    pub fb_app_id: ::core::option::Option<u64>,
    #[prost(bytes="vec", optional, tag="32")]
    pub fb_device_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag="33")]
    pub pull: ::core::option::Option<bool>,
    #[prost(bytes="vec", optional, tag="34")]
    pub padding_bytes: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag="36")]
    pub year_class: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="37")]
    pub mem_class: ::core::option::Option<i32>,
    #[prost(message, optional, tag="38")]
    pub interop_data: ::core::option::Option<client_payload::InteropData>,
    #[prost(enumeration="client_payload::TrafficAnonymization", optional, tag="40")]
    pub traffic_anonymization: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="41")]
    pub lid_db_migrated: ::core::option::Option<bool>,
    #[prost(enumeration="client_payload::AccountType", optional, tag="42")]
    pub account_type: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ClientPayload`.
pub mod client_payload {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DnsSource {
        #[prost(enumeration="dns_source::DnsResolutionMethod", optional, tag="15")]
        pub dns_method: ::core::option::Option<i32>,
        #[prost(bool, optional, tag="16")]
        pub app_cached: ::core::option::Option<bool>,
    }
    /// Nested message and enum types in `DNSSource`.
    pub mod dns_source {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum DnsResolutionMethod {
            System = 0,
            Google = 1,
            Hardcoded = 2,
            Override = 3,
            Fallback = 4,
            Mns = 5,
        }
        impl DnsResolutionMethod {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::System => "SYSTEM",
                    Self::Google => "GOOGLE",
                    Self::Hardcoded => "HARDCODED",
                    Self::Override => "OVERRIDE",
                    Self::Fallback => "FALLBACK",
                    Self::Mns => "MNS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SYSTEM" => Some(Self::System),
                    "GOOGLE" => Some(Self::Google),
                    "HARDCODED" => Some(Self::Hardcoded),
                    "OVERRIDE" => Some(Self::Override),
                    "FALLBACK" => Some(Self::Fallback),
                    "MNS" => Some(Self::Mns),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DevicePairingRegistrationData {
        #[prost(bytes="vec", optional, tag="1")]
        pub e_regid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="2")]
        pub e_keytype: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="3")]
        pub e_ident: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="4")]
        pub e_skey_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="5")]
        pub e_skey_val: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="6")]
        pub e_skey_sig: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="7")]
        pub build_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="8")]
        pub device_props: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct InteropData {
        #[prost(uint64, optional, tag="1")]
        pub account_id: ::core::option::Option<u64>,
        #[prost(bytes="vec", optional, tag="2")]
        pub token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bool, optional, tag="3")]
        pub enable_read_receipts: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct UserAgent {
        #[prost(enumeration="user_agent::Platform", optional, tag="1")]
        pub platform: ::core::option::Option<i32>,
        #[prost(message, optional, tag="2")]
        pub app_version: ::core::option::Option<user_agent::AppVersion>,
        #[prost(string, optional, tag="3")]
        pub mcc: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="4")]
        pub mnc: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="5")]
        pub os_version: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="6")]
        pub manufacturer: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="7")]
        pub device: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="8")]
        pub os_build_number: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="9")]
        pub phone_id: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration="user_agent::ReleaseChannel", optional, tag="10")]
        pub release_channel: ::core::option::Option<i32>,
        #[prost(string, optional, tag="11")]
        pub locale_language_iso6391: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="12")]
        pub locale_country_iso31661_alpha2: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="13")]
        pub device_board: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="14")]
        pub device_exp_id: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration="user_agent::DeviceType", optional, tag="15")]
        pub device_type: ::core::option::Option<i32>,
        #[prost(string, optional, tag="16")]
        pub device_model_type: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `UserAgent`.
    pub mod user_agent {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AppVersion {
            #[prost(uint32, optional, tag="1")]
            pub primary: ::core::option::Option<u32>,
            #[prost(uint32, optional, tag="2")]
            pub secondary: ::core::option::Option<u32>,
            #[prost(uint32, optional, tag="3")]
            pub tertiary: ::core::option::Option<u32>,
            #[prost(uint32, optional, tag="4")]
            pub quaternary: ::core::option::Option<u32>,
            #[prost(uint32, optional, tag="5")]
            pub quinary: ::core::option::Option<u32>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum DeviceType {
            Phone = 0,
            Tablet = 1,
            Desktop = 2,
            Wearable = 3,
            Vr = 4,
        }
        impl DeviceType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Phone => "PHONE",
                    Self::Tablet => "TABLET",
                    Self::Desktop => "DESKTOP",
                    Self::Wearable => "WEARABLE",
                    Self::Vr => "VR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PHONE" => Some(Self::Phone),
                    "TABLET" => Some(Self::Tablet),
                    "DESKTOP" => Some(Self::Desktop),
                    "WEARABLE" => Some(Self::Wearable),
                    "VR" => Some(Self::Vr),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum Platform {
            Android = 0,
            Ios = 1,
            WindowsPhone = 2,
            Blackberry = 3,
            Blackberryx = 4,
            S40 = 5,
            S60 = 6,
            PythonClient = 7,
            Tizen = 8,
            Enterprise = 9,
            SmbAndroid = 10,
            Kaios = 11,
            SmbIos = 12,
            Windows = 13,
            Web = 14,
            Portal = 15,
            GreenAndroid = 16,
            GreenIphone = 17,
            BlueAndroid = 18,
            BlueIphone = 19,
            FbliteAndroid = 20,
            MliteAndroid = 21,
            IgliteAndroid = 22,
            Page = 23,
            Macos = 24,
            OculusMsg = 25,
            OculusCall = 26,
            Milan = 27,
            Capi = 28,
            Wearos = 29,
            Ardevice = 30,
            Vrdevice = 31,
            BlueWeb = 32,
            Ipad = 33,
            Test = 34,
            SmartGlasses = 35,
        }
        impl Platform {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Android => "ANDROID",
                    Self::Ios => "IOS",
                    Self::WindowsPhone => "WINDOWS_PHONE",
                    Self::Blackberry => "BLACKBERRY",
                    Self::Blackberryx => "BLACKBERRYX",
                    Self::S40 => "S40",
                    Self::S60 => "S60",
                    Self::PythonClient => "PYTHON_CLIENT",
                    Self::Tizen => "TIZEN",
                    Self::Enterprise => "ENTERPRISE",
                    Self::SmbAndroid => "SMB_ANDROID",
                    Self::Kaios => "KAIOS",
                    Self::SmbIos => "SMB_IOS",
                    Self::Windows => "WINDOWS",
                    Self::Web => "WEB",
                    Self::Portal => "PORTAL",
                    Self::GreenAndroid => "GREEN_ANDROID",
                    Self::GreenIphone => "GREEN_IPHONE",
                    Self::BlueAndroid => "BLUE_ANDROID",
                    Self::BlueIphone => "BLUE_IPHONE",
                    Self::FbliteAndroid => "FBLITE_ANDROID",
                    Self::MliteAndroid => "MLITE_ANDROID",
                    Self::IgliteAndroid => "IGLITE_ANDROID",
                    Self::Page => "PAGE",
                    Self::Macos => "MACOS",
                    Self::OculusMsg => "OCULUS_MSG",
                    Self::OculusCall => "OCULUS_CALL",
                    Self::Milan => "MILAN",
                    Self::Capi => "CAPI",
                    Self::Wearos => "WEAROS",
                    Self::Ardevice => "ARDEVICE",
                    Self::Vrdevice => "VRDEVICE",
                    Self::BlueWeb => "BLUE_WEB",
                    Self::Ipad => "IPAD",
                    Self::Test => "TEST",
                    Self::SmartGlasses => "SMART_GLASSES",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ANDROID" => Some(Self::Android),
                    "IOS" => Some(Self::Ios),
                    "WINDOWS_PHONE" => Some(Self::WindowsPhone),
                    "BLACKBERRY" => Some(Self::Blackberry),
                    "BLACKBERRYX" => Some(Self::Blackberryx),
                    "S40" => Some(Self::S40),
                    "S60" => Some(Self::S60),
                    "PYTHON_CLIENT" => Some(Self::PythonClient),
                    "TIZEN" => Some(Self::Tizen),
                    "ENTERPRISE" => Some(Self::Enterprise),
                    "SMB_ANDROID" => Some(Self::SmbAndroid),
                    "KAIOS" => Some(Self::Kaios),
                    "SMB_IOS" => Some(Self::SmbIos),
                    "WINDOWS" => Some(Self::Windows),
                    "WEB" => Some(Self::Web),
                    "PORTAL" => Some(Self::Portal),
                    "GREEN_ANDROID" => Some(Self::GreenAndroid),
                    "GREEN_IPHONE" => Some(Self::GreenIphone),
                    "BLUE_ANDROID" => Some(Self::BlueAndroid),
                    "BLUE_IPHONE" => Some(Self::BlueIphone),
                    "FBLITE_ANDROID" => Some(Self::FbliteAndroid),
                    "MLITE_ANDROID" => Some(Self::MliteAndroid),
                    "IGLITE_ANDROID" => Some(Self::IgliteAndroid),
                    "PAGE" => Some(Self::Page),
                    "MACOS" => Some(Self::Macos),
                    "OCULUS_MSG" => Some(Self::OculusMsg),
                    "OCULUS_CALL" => Some(Self::OculusCall),
                    "MILAN" => Some(Self::Milan),
                    "CAPI" => Some(Self::Capi),
                    "WEAROS" => Some(Self::Wearos),
                    "ARDEVICE" => Some(Self::Ardevice),
                    "VRDEVICE" => Some(Self::Vrdevice),
                    "BLUE_WEB" => Some(Self::BlueWeb),
                    "IPAD" => Some(Self::Ipad),
                    "TEST" => Some(Self::Test),
                    "SMART_GLASSES" => Some(Self::SmartGlasses),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum ReleaseChannel {
            Release = 0,
            Beta = 1,
            Alpha = 2,
            Debug = 3,
        }
        impl ReleaseChannel {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Release => "RELEASE",
                    Self::Beta => "BETA",
                    Self::Alpha => "ALPHA",
                    Self::Debug => "DEBUG",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "RELEASE" => Some(Self::Release),
                    "BETA" => Some(Self::Beta),
                    "ALPHA" => Some(Self::Alpha),
                    "DEBUG" => Some(Self::Debug),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct WebInfo {
        #[prost(string, optional, tag="1")]
        pub ref_token: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub version: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, tag="3")]
        pub webd_payload: ::core::option::Option<web_info::WebdPayload>,
        #[prost(enumeration="web_info::WebSubPlatform", optional, tag="4")]
        pub web_sub_platform: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `WebInfo`.
    pub mod web_info {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct WebdPayload {
            #[prost(bool, optional, tag="1")]
            pub uses_participant_in_key: ::core::option::Option<bool>,
            #[prost(bool, optional, tag="2")]
            pub supports_starred_messages: ::core::option::Option<bool>,
            #[prost(bool, optional, tag="3")]
            pub supports_document_messages: ::core::option::Option<bool>,
            #[prost(bool, optional, tag="4")]
            pub supports_url_messages: ::core::option::Option<bool>,
            #[prost(bool, optional, tag="5")]
            pub supports_media_retry: ::core::option::Option<bool>,
            #[prost(bool, optional, tag="6")]
            pub supports_e2e_image: ::core::option::Option<bool>,
            #[prost(bool, optional, tag="7")]
            pub supports_e2e_video: ::core::option::Option<bool>,
            #[prost(bool, optional, tag="8")]
            pub supports_e2e_audio: ::core::option::Option<bool>,
            #[prost(bool, optional, tag="9")]
            pub supports_e2e_document: ::core::option::Option<bool>,
            #[prost(string, optional, tag="10")]
            pub document_types: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(bytes="vec", optional, tag="11")]
            pub features: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum WebSubPlatform {
            WebBrowser = 0,
            AppStore = 1,
            WinStore = 2,
            Darwin = 3,
            Win32 = 4,
            WinHybrid = 5,
        }
        impl WebSubPlatform {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::WebBrowser => "WEB_BROWSER",
                    Self::AppStore => "APP_STORE",
                    Self::WinStore => "WIN_STORE",
                    Self::Darwin => "DARWIN",
                    Self::Win32 => "WIN32",
                    Self::WinHybrid => "WIN_HYBRID",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "WEB_BROWSER" => Some(Self::WebBrowser),
                    "APP_STORE" => Some(Self::AppStore),
                    "WIN_STORE" => Some(Self::WinStore),
                    "DARWIN" => Some(Self::Darwin),
                    "WIN32" => Some(Self::Win32),
                    "WIN_HYBRID" => Some(Self::WinHybrid),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AccountType {
        Default = 0,
        Guest = 1,
    }
    impl AccountType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Default => "DEFAULT",
                Self::Guest => "GUEST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEFAULT" => Some(Self::Default),
                "GUEST" => Some(Self::Guest),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ConnectReason {
        Push = 0,
        UserActivated = 1,
        Scheduled = 2,
        ErrorReconnect = 3,
        NetworkSwitch = 4,
        PingReconnect = 5,
        Unknown = 6,
    }
    impl ConnectReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Push => "PUSH",
                Self::UserActivated => "USER_ACTIVATED",
                Self::Scheduled => "SCHEDULED",
                Self::ErrorReconnect => "ERROR_RECONNECT",
                Self::NetworkSwitch => "NETWORK_SWITCH",
                Self::PingReconnect => "PING_RECONNECT",
                Self::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PUSH" => Some(Self::Push),
                "USER_ACTIVATED" => Some(Self::UserActivated),
                "SCHEDULED" => Some(Self::Scheduled),
                "ERROR_RECONNECT" => Some(Self::ErrorReconnect),
                "NETWORK_SWITCH" => Some(Self::NetworkSwitch),
                "PING_RECONNECT" => Some(Self::PingReconnect),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ConnectType {
        CellularUnknown = 0,
        WifiUnknown = 1,
        CellularEdge = 100,
        CellularIden = 101,
        CellularUmts = 102,
        CellularEvdo = 103,
        CellularGprs = 104,
        CellularHsdpa = 105,
        CellularHsupa = 106,
        CellularHspa = 107,
        CellularCdma = 108,
        Cellular1xrtt = 109,
        CellularEhrpd = 110,
        CellularLte = 111,
        CellularHspap = 112,
    }
    impl ConnectType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::CellularUnknown => "CELLULAR_UNKNOWN",
                Self::WifiUnknown => "WIFI_UNKNOWN",
                Self::CellularEdge => "CELLULAR_EDGE",
                Self::CellularIden => "CELLULAR_IDEN",
                Self::CellularUmts => "CELLULAR_UMTS",
                Self::CellularEvdo => "CELLULAR_EVDO",
                Self::CellularGprs => "CELLULAR_GPRS",
                Self::CellularHsdpa => "CELLULAR_HSDPA",
                Self::CellularHsupa => "CELLULAR_HSUPA",
                Self::CellularHspa => "CELLULAR_HSPA",
                Self::CellularCdma => "CELLULAR_CDMA",
                Self::Cellular1xrtt => "CELLULAR_1XRTT",
                Self::CellularEhrpd => "CELLULAR_EHRPD",
                Self::CellularLte => "CELLULAR_LTE",
                Self::CellularHspap => "CELLULAR_HSPAP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CELLULAR_UNKNOWN" => Some(Self::CellularUnknown),
                "WIFI_UNKNOWN" => Some(Self::WifiUnknown),
                "CELLULAR_EDGE" => Some(Self::CellularEdge),
                "CELLULAR_IDEN" => Some(Self::CellularIden),
                "CELLULAR_UMTS" => Some(Self::CellularUmts),
                "CELLULAR_EVDO" => Some(Self::CellularEvdo),
                "CELLULAR_GPRS" => Some(Self::CellularGprs),
                "CELLULAR_HSDPA" => Some(Self::CellularHsdpa),
                "CELLULAR_HSUPA" => Some(Self::CellularHsupa),
                "CELLULAR_HSPA" => Some(Self::CellularHspa),
                "CELLULAR_CDMA" => Some(Self::CellularCdma),
                "CELLULAR_1XRTT" => Some(Self::Cellular1xrtt),
                "CELLULAR_EHRPD" => Some(Self::CellularEhrpd),
                "CELLULAR_LTE" => Some(Self::CellularLte),
                "CELLULAR_HSPAP" => Some(Self::CellularHspap),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum IosAppExtension {
        ShareExtension = 0,
        ServiceExtension = 1,
        IntentsExtension = 2,
    }
    impl IosAppExtension {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ShareExtension => "SHARE_EXTENSION",
                Self::ServiceExtension => "SERVICE_EXTENSION",
                Self::IntentsExtension => "INTENTS_EXTENSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SHARE_EXTENSION" => Some(Self::ShareExtension),
                "SERVICE_EXTENSION" => Some(Self::ServiceExtension),
                "INTENTS_EXTENSION" => Some(Self::IntentsExtension),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Product {
        Whatsapp = 0,
        Messenger = 1,
        Interop = 2,
        InteropMsgr = 3,
        WhatsappLid = 4,
    }
    impl Product {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Whatsapp => "WHATSAPP",
                Self::Messenger => "MESSENGER",
                Self::Interop => "INTEROP",
                Self::InteropMsgr => "INTEROP_MSGR",
                Self::WhatsappLid => "WHATSAPP_LID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WHATSAPP" => Some(Self::Whatsapp),
                "MESSENGER" => Some(Self::Messenger),
                "INTEROP" => Some(Self::Interop),
                "INTEROP_MSGR" => Some(Self::InteropMsgr),
                "WHATSAPP_LID" => Some(Self::WhatsappLid),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum TrafficAnonymization {
        Off = 0,
        Standard = 1,
    }
    impl TrafficAnonymization {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Off => "OFF",
                Self::Standard => "STANDARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OFF" => Some(Self::Off),
                "STANDARD" => Some(Self::Standard),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CommentMetadata {
    #[prost(message, optional, tag="1")]
    pub comment_parent_key: ::core::option::Option<MessageKey>,
    #[prost(uint32, optional, tag="2")]
    pub reply_count: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CompanionCommitment {
    #[prost(bytes="vec", optional, tag="1")]
    pub hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CompanionEphemeralIdentity {
    #[prost(bytes="vec", optional, tag="1")]
    pub public_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(enumeration="device_props::PlatformType", optional, tag="2")]
    pub device_type: ::core::option::Option<i32>,
    #[prost(string, optional, tag="3")]
    pub r#ref: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Config {
    #[prost(map="uint32, message", tag="1")]
    pub field: ::std::collections::HashMap<u32, Field>,
    #[prost(uint32, optional, tag="2")]
    pub version: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContextInfo {
    #[prost(string, optional, tag="1")]
    pub stanza_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub participant: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, boxed, tag="3")]
    pub quoted_message: ::core::option::Option<::prost::alloc::boxed::Box<Message>>,
    #[prost(string, optional, tag="4")]
    pub remote_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="15")]
    pub mentioned_jid: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag="18")]
    pub conversion_source: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="vec", optional, tag="19")]
    pub conversion_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag="20")]
    pub conversion_delay_seconds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="21")]
    pub forwarding_score: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="22")]
    pub is_forwarded: ::core::option::Option<bool>,
    #[prost(message, optional, tag="23")]
    pub quoted_ad: ::core::option::Option<context_info::AdReplyInfo>,
    #[prost(message, optional, tag="24")]
    pub placeholder_key: ::core::option::Option<MessageKey>,
    #[prost(uint32, optional, tag="25")]
    pub expiration: ::core::option::Option<u32>,
    #[prost(int64, optional, tag="26")]
    pub ephemeral_setting_timestamp: ::core::option::Option<i64>,
    #[prost(bytes="vec", optional, tag="27")]
    pub ephemeral_shared_secret: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag="28")]
    pub external_ad_reply: ::core::option::Option<context_info::ExternalAdReplyInfo>,
    #[prost(string, optional, tag="29")]
    pub entry_point_conversion_source: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="30")]
    pub entry_point_conversion_app: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="31")]
    pub entry_point_conversion_delay_seconds: ::core::option::Option<u32>,
    #[prost(message, optional, tag="32")]
    pub disappearing_mode: ::core::option::Option<DisappearingMode>,
    #[prost(message, optional, tag="33")]
    pub action_link: ::core::option::Option<ActionLink>,
    #[prost(string, optional, tag="34")]
    pub group_subject: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="35")]
    pub parent_group_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="37")]
    pub trust_banner_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="38")]
    pub trust_banner_action: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="39")]
    pub is_sampled: ::core::option::Option<bool>,
    #[prost(message, repeated, tag="40")]
    pub group_mentions: ::prost::alloc::vec::Vec<GroupMention>,
    #[prost(message, optional, tag="41")]
    pub utm: ::core::option::Option<context_info::UtmInfo>,
    #[prost(message, optional, tag="43")]
    pub forwarded_newsletter_message_info: ::core::option::Option<context_info::ForwardedNewsletterMessageInfo>,
    #[prost(message, optional, tag="44")]
    pub business_message_forward_info: ::core::option::Option<context_info::BusinessMessageForwardInfo>,
    #[prost(string, optional, tag="45")]
    pub smb_client_campaign_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="46")]
    pub smb_server_campaign_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="47")]
    pub data_sharing_context: ::core::option::Option<context_info::DataSharingContext>,
    #[prost(bool, optional, tag="48")]
    pub always_show_ad_attribution: ::core::option::Option<bool>,
    #[prost(message, optional, tag="49")]
    pub feature_eligibilities: ::core::option::Option<context_info::FeatureEligibilities>,
    #[prost(string, optional, tag="50")]
    pub entry_point_conversion_external_source: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="51")]
    pub entry_point_conversion_external_medium: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="54")]
    pub ctwa_signals: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="vec", optional, tag="55")]
    pub ctwa_payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag="56")]
    pub forwarded_ai_bot_message_info: ::core::option::Option<context_info::ForwardedAiBotMessageInfo>,
    #[prost(enumeration="context_info::StatusAttributionType", optional, tag="57")]
    pub status_attribution_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag="58")]
    pub url_tracking_map: ::core::option::Option<UrlTrackingMap>,
    #[prost(enumeration="context_info::PairedMediaType", optional, tag="59")]
    pub paired_media_type: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="60")]
    pub ranking_version: ::core::option::Option<u32>,
    #[prost(message, optional, tag="62")]
    pub member_label: ::core::option::Option<MemberLabel>,
    #[prost(bool, optional, tag="63")]
    pub is_question: ::core::option::Option<bool>,
    #[prost(enumeration="context_info::StatusSourceType", optional, tag="64")]
    pub status_source_type: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ContextInfo`.
pub mod context_info {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AdReplyInfo {
        #[prost(string, optional, tag="1")]
        pub advertiser_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration="ad_reply_info::MediaType", optional, tag="2")]
        pub media_type: ::core::option::Option<i32>,
        #[prost(bytes="vec", optional, tag="16")]
        pub jpeg_thumbnail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="17")]
        pub caption: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `AdReplyInfo`.
    pub mod ad_reply_info {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum MediaType {
            None = 0,
            Image = 1,
            Video = 2,
        }
        impl MediaType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::None => "NONE",
                    Self::Image => "IMAGE",
                    Self::Video => "VIDEO",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NONE" => Some(Self::None),
                    "IMAGE" => Some(Self::Image),
                    "VIDEO" => Some(Self::Video),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BusinessMessageForwardInfo {
        #[prost(string, optional, tag="1")]
        pub business_owner_jid: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DataSharingContext {
        #[prost(bool, optional, tag="1")]
        pub show_mm_disclosure: ::core::option::Option<bool>,
        #[prost(string, optional, tag="2")]
        pub encrypted_signal_token_consented: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="3")]
        pub parameters: ::prost::alloc::vec::Vec<data_sharing_context::Parameters>,
    }
    /// Nested message and enum types in `DataSharingContext`.
    pub mod data_sharing_context {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Parameters {
            #[prost(string, optional, tag="1")]
            pub key: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="2")]
            pub string_data: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(int64, optional, tag="3")]
            pub int_data: ::core::option::Option<i64>,
            #[prost(float, optional, tag="4")]
            pub float_data: ::core::option::Option<f32>,
            #[prost(message, optional, boxed, tag="5")]
            pub contents: ::core::option::Option<::prost::alloc::boxed::Box<Parameters>>,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ExternalAdReplyInfo {
        #[prost(string, optional, tag="1")]
        pub title: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub body: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration="external_ad_reply_info::MediaType", optional, tag="3")]
        pub media_type: ::core::option::Option<i32>,
        #[prost(string, optional, tag="4")]
        pub thumbnail_url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="5")]
        pub media_url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="6")]
        pub thumbnail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="7")]
        pub source_type: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="8")]
        pub source_id: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="9")]
        pub source_url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag="10")]
        pub contains_auto_reply: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="11")]
        pub render_larger_thumbnail: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="12")]
        pub show_ad_attribution: ::core::option::Option<bool>,
        #[prost(string, optional, tag="13")]
        pub ctwa_clid: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="14")]
        pub r#ref: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag="15")]
        pub click_to_whatsapp_call: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="16")]
        pub ad_context_preview_dismissed: ::core::option::Option<bool>,
        #[prost(string, optional, tag="17")]
        pub source_app: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag="18")]
        pub automated_greeting_message_shown: ::core::option::Option<bool>,
        #[prost(string, optional, tag="19")]
        pub greeting_message_body: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="20")]
        pub cta_payload: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag="21")]
        pub disable_nudge: ::core::option::Option<bool>,
        #[prost(string, optional, tag="22")]
        pub original_image_url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="23")]
        pub automated_greeting_message_cta_type: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag="24")]
        pub wtwa_ad_format: ::core::option::Option<bool>,
        #[prost(enumeration="external_ad_reply_info::AdType", optional, tag="25")]
        pub ad_type: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `ExternalAdReplyInfo`.
    pub mod external_ad_reply_info {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum AdType {
            Ctwa = 0,
            Cawc = 1,
        }
        impl AdType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Ctwa => "CTWA",
                    Self::Cawc => "CAWC",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CTWA" => Some(Self::Ctwa),
                    "CAWC" => Some(Self::Cawc),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum MediaType {
            None = 0,
            Image = 1,
            Video = 2,
        }
        impl MediaType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::None => "NONE",
                    Self::Image => "IMAGE",
                    Self::Video => "VIDEO",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NONE" => Some(Self::None),
                    "IMAGE" => Some(Self::Image),
                    "VIDEO" => Some(Self::Video),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct FeatureEligibilities {
        #[prost(bool, optional, tag="1")]
        pub cannot_be_reacted_to: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="2")]
        pub cannot_be_ranked: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="3")]
        pub can_request_feedback: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="4")]
        pub can_be_reshared: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ForwardedAiBotMessageInfo {
        #[prost(string, optional, tag="1")]
        pub bot_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub bot_jid: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="3")]
        pub creator_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ForwardedNewsletterMessageInfo {
        #[prost(string, optional, tag="1")]
        pub newsletter_jid: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag="2")]
        pub server_message_id: ::core::option::Option<i32>,
        #[prost(string, optional, tag="3")]
        pub newsletter_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration="forwarded_newsletter_message_info::ContentType", optional, tag="4")]
        pub content_type: ::core::option::Option<i32>,
        #[prost(string, optional, tag="5")]
        pub accessibility_text: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `ForwardedNewsletterMessageInfo`.
    pub mod forwarded_newsletter_message_info {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum ContentType {
            Update = 1,
            UpdateCard = 2,
            LinkCard = 3,
        }
        impl ContentType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Update => "UPDATE",
                    Self::UpdateCard => "UPDATE_CARD",
                    Self::LinkCard => "LINK_CARD",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UPDATE" => Some(Self::Update),
                    "UPDATE_CARD" => Some(Self::UpdateCard),
                    "LINK_CARD" => Some(Self::LinkCard),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct UtmInfo {
        #[prost(string, optional, tag="1")]
        pub utm_source: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub utm_campaign: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum PairedMediaType {
        NotPairedMedia = 0,
        SdVideoParent = 1,
        HdVideoChild = 2,
        SdImageParent = 3,
        HdImageChild = 4,
        MotionPhotoParent = 5,
        MotionPhotoChild = 6,
    }
    impl PairedMediaType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::NotPairedMedia => "NOT_PAIRED_MEDIA",
                Self::SdVideoParent => "SD_VIDEO_PARENT",
                Self::HdVideoChild => "HD_VIDEO_CHILD",
                Self::SdImageParent => "SD_IMAGE_PARENT",
                Self::HdImageChild => "HD_IMAGE_CHILD",
                Self::MotionPhotoParent => "MOTION_PHOTO_PARENT",
                Self::MotionPhotoChild => "MOTION_PHOTO_CHILD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NOT_PAIRED_MEDIA" => Some(Self::NotPairedMedia),
                "SD_VIDEO_PARENT" => Some(Self::SdVideoParent),
                "HD_VIDEO_CHILD" => Some(Self::HdVideoChild),
                "SD_IMAGE_PARENT" => Some(Self::SdImageParent),
                "HD_IMAGE_CHILD" => Some(Self::HdImageChild),
                "MOTION_PHOTO_PARENT" => Some(Self::MotionPhotoParent),
                "MOTION_PHOTO_CHILD" => Some(Self::MotionPhotoChild),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum StatusAttributionType {
        None = 0,
        ResharedFromMention = 1,
        ResharedFromPost = 2,
    }
    impl StatusAttributionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::ResharedFromMention => "RESHARED_FROM_MENTION",
                Self::ResharedFromPost => "RESHARED_FROM_POST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "RESHARED_FROM_MENTION" => Some(Self::ResharedFromMention),
                "RESHARED_FROM_POST" => Some(Self::ResharedFromPost),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum StatusSourceType {
        Image = 0,
        Video = 1,
        Gif = 2,
        Audio = 3,
        Text = 4,
        MusicStandalone = 5,
    }
    impl StatusSourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Image => "IMAGE",
                Self::Video => "VIDEO",
                Self::Gif => "GIF",
                Self::Audio => "AUDIO",
                Self::Text => "TEXT",
                Self::MusicStandalone => "MUSIC_STANDALONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IMAGE" => Some(Self::Image),
                "VIDEO" => Some(Self::Video),
                "GIF" => Some(Self::Gif),
                "AUDIO" => Some(Self::Audio),
                "TEXT" => Some(Self::Text),
                "MUSIC_STANDALONE" => Some(Self::MusicStandalone),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Conversation {
    #[prost(string, required, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="2")]
    pub messages: ::prost::alloc::vec::Vec<HistorySyncMsg>,
    #[prost(string, optional, tag="3")]
    pub new_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub old_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag="5")]
    pub last_msg_timestamp: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="6")]
    pub unread_count: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="7")]
    pub read_only: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="8")]
    pub end_of_history_transfer: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag="9")]
    pub ephemeral_expiration: ::core::option::Option<u32>,
    #[prost(int64, optional, tag="10")]
    pub ephemeral_setting_timestamp: ::core::option::Option<i64>,
    #[prost(enumeration="conversation::EndOfHistoryTransferType", optional, tag="11")]
    pub end_of_history_transfer_type: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag="12")]
    pub conversation_timestamp: ::core::option::Option<u64>,
    #[prost(string, optional, tag="13")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="14")]
    pub p_hash: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="15")]
    pub not_spam: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="16")]
    pub archived: ::core::option::Option<bool>,
    #[prost(message, optional, tag="17")]
    pub disappearing_mode: ::core::option::Option<DisappearingMode>,
    #[prost(uint32, optional, tag="18")]
    pub unread_mention_count: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="19")]
    pub marked_as_unread: ::core::option::Option<bool>,
    #[prost(message, repeated, tag="20")]
    pub participant: ::prost::alloc::vec::Vec<GroupParticipant>,
    #[prost(bytes="vec", optional, tag="21")]
    pub tc_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, optional, tag="22")]
    pub tc_token_timestamp: ::core::option::Option<u64>,
    #[prost(bytes="vec", optional, tag="23")]
    pub contact_primary_identity_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag="24")]
    pub pinned: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="25")]
    pub mute_end_time: ::core::option::Option<u64>,
    #[prost(message, optional, tag="26")]
    pub wallpaper: ::core::option::Option<WallpaperSettings>,
    #[prost(enumeration="MediaVisibility", optional, tag="27")]
    pub media_visibility: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag="28")]
    pub tc_token_sender_timestamp: ::core::option::Option<u64>,
    #[prost(bool, optional, tag="29")]
    pub suspended: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="30")]
    pub terminated: ::core::option::Option<bool>,
    #[prost(uint64, optional, tag="31")]
    pub created_at: ::core::option::Option<u64>,
    #[prost(string, optional, tag="32")]
    pub created_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="33")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="34")]
    pub support: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="35")]
    pub is_parent_group: ::core::option::Option<bool>,
    #[prost(string, optional, tag="37")]
    pub parent_group_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="36")]
    pub is_default_subgroup: ::core::option::Option<bool>,
    #[prost(string, optional, tag="38")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="39")]
    pub pn_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="40")]
    pub share_own_pn: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="41")]
    pub pnh_duplicate_lid_thread: ::core::option::Option<bool>,
    #[prost(string, optional, tag="42")]
    pub lid_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="43")]
    pub username: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="44")]
    pub lid_origin_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="45")]
    pub comments_count: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="46")]
    pub locked: ::core::option::Option<bool>,
    #[prost(enumeration="PrivacySystemMessage", optional, tag="47")]
    pub system_message_to_insert: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="48")]
    pub capi_created_group: ::core::option::Option<bool>,
    #[prost(string, optional, tag="49")]
    pub account_lid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="50")]
    pub limit_sharing: ::core::option::Option<bool>,
    #[prost(int64, optional, tag="51")]
    pub limit_sharing_setting_timestamp: ::core::option::Option<i64>,
    #[prost(enumeration="limit_sharing::TriggerType", optional, tag="52")]
    pub limit_sharing_trigger: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="53")]
    pub limit_sharing_initiated_by_me: ::core::option::Option<bool>,
}
/// Nested message and enum types in `Conversation`.
pub mod conversation {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum EndOfHistoryTransferType {
        CompleteButMoreMessagesRemainOnPrimary = 0,
        CompleteAndNoMoreMessageRemainOnPrimary = 1,
        CompleteOnDemandSyncButMoreMsgRemainOnPrimary = 2,
    }
    impl EndOfHistoryTransferType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::CompleteButMoreMessagesRemainOnPrimary => "COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY",
                Self::CompleteAndNoMoreMessageRemainOnPrimary => "COMPLETE_AND_NO_MORE_MESSAGE_REMAIN_ON_PRIMARY",
                Self::CompleteOnDemandSyncButMoreMsgRemainOnPrimary => "COMPLETE_ON_DEMAND_SYNC_BUT_MORE_MSG_REMAIN_ON_PRIMARY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY" => Some(Self::CompleteButMoreMessagesRemainOnPrimary),
                "COMPLETE_AND_NO_MORE_MESSAGE_REMAIN_ON_PRIMARY" => Some(Self::CompleteAndNoMoreMessageRemainOnPrimary),
                "COMPLETE_ON_DEMAND_SYNC_BUT_MORE_MSG_REMAIN_ON_PRIMARY" => Some(Self::CompleteOnDemandSyncButMoreMsgRemainOnPrimary),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceCapabilities {
    #[prost(enumeration="device_capabilities::ChatLockSupportLevel", optional, tag="1")]
    pub chat_lock_support_level: ::core::option::Option<i32>,
    #[prost(message, optional, tag="2")]
    pub lid_migration: ::core::option::Option<device_capabilities::LidMigration>,
}
/// Nested message and enum types in `DeviceCapabilities`.
pub mod device_capabilities {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct LidMigration {
        #[prost(uint64, optional, tag="1")]
        pub chat_db_migration_timestamp: ::core::option::Option<u64>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ChatLockSupportLevel {
        None = 0,
        Minimal = 1,
        Full = 2,
    }
    impl ChatLockSupportLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Minimal => "MINIMAL",
                Self::Full => "FULL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "MINIMAL" => Some(Self::Minimal),
                "FULL" => Some(Self::Full),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceConsistencyCodeMessage {
    #[prost(uint32, optional, tag="1")]
    pub generation: ::core::option::Option<u32>,
    #[prost(bytes="vec", optional, tag="2")]
    pub signature: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceListMetadata {
    #[prost(bytes="vec", optional, tag="1")]
    pub sender_key_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, optional, tag="2")]
    pub sender_timestamp: ::core::option::Option<u64>,
    #[prost(uint32, repeated, tag="3")]
    pub sender_key_indexes: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration="AdvEncryptionType", optional, tag="4")]
    pub sender_account_type: ::core::option::Option<i32>,
    #[prost(enumeration="AdvEncryptionType", optional, tag="5")]
    pub receiver_account_type: ::core::option::Option<i32>,
    #[prost(bytes="vec", optional, tag="8")]
    pub recipient_key_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, optional, tag="9")]
    pub recipient_timestamp: ::core::option::Option<u64>,
    #[prost(uint32, repeated, tag="10")]
    pub recipient_key_indexes: ::prost::alloc::vec::Vec<u32>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceProps {
    #[prost(string, optional, tag="1")]
    pub os: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="2")]
    pub version: ::core::option::Option<device_props::AppVersion>,
    #[prost(enumeration="device_props::PlatformType", optional, tag="3")]
    pub platform_type: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="4")]
    pub require_full_sync: ::core::option::Option<bool>,
    #[prost(message, optional, tag="5")]
    pub history_sync_config: ::core::option::Option<device_props::HistorySyncConfig>,
}
/// Nested message and enum types in `DeviceProps`.
pub mod device_props {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AppVersion {
        #[prost(uint32, optional, tag="1")]
        pub primary: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="2")]
        pub secondary: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="3")]
        pub tertiary: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="4")]
        pub quaternary: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="5")]
        pub quinary: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct HistorySyncConfig {
        #[prost(uint32, optional, tag="1")]
        pub full_sync_days_limit: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="2")]
        pub full_sync_size_mb_limit: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="3")]
        pub storage_quota_mb: ::core::option::Option<u32>,
        #[prost(bool, optional, tag="4")]
        pub inline_initial_payload_in_e2_ee_msg: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag="5")]
        pub recent_sync_days_limit: ::core::option::Option<u32>,
        #[prost(bool, optional, tag="6")]
        pub support_call_log_history: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="7")]
        pub support_bot_user_agent_chat_history: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="8")]
        pub support_cag_reactions_and_polls: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="9")]
        pub support_biz_hosted_msg: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="10")]
        pub support_recent_sync_chunk_message_count_tuning: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="11")]
        pub support_hosted_group_msg: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="12")]
        pub support_fbid_bot_chat_history: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="13")]
        pub support_add_on_history_sync_migration: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="14")]
        pub support_message_association: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum PlatformType {
        Unknown = 0,
        Chrome = 1,
        Firefox = 2,
        Ie = 3,
        Opera = 4,
        Safari = 5,
        Edge = 6,
        Desktop = 7,
        Ipad = 8,
        AndroidTablet = 9,
        Ohana = 10,
        Aloha = 11,
        Catalina = 12,
        TclTv = 13,
        IosPhone = 14,
        IosCatalyst = 15,
        AndroidPhone = 16,
        AndroidAmbiguous = 17,
        WearOs = 18,
        ArWrist = 19,
        ArDevice = 20,
        Uwp = 21,
        Vr = 22,
        CloudApi = 23,
        Smartglasses = 24,
    }
    impl PlatformType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Chrome => "CHROME",
                Self::Firefox => "FIREFOX",
                Self::Ie => "IE",
                Self::Opera => "OPERA",
                Self::Safari => "SAFARI",
                Self::Edge => "EDGE",
                Self::Desktop => "DESKTOP",
                Self::Ipad => "IPAD",
                Self::AndroidTablet => "ANDROID_TABLET",
                Self::Ohana => "OHANA",
                Self::Aloha => "ALOHA",
                Self::Catalina => "CATALINA",
                Self::TclTv => "TCL_TV",
                Self::IosPhone => "IOS_PHONE",
                Self::IosCatalyst => "IOS_CATALYST",
                Self::AndroidPhone => "ANDROID_PHONE",
                Self::AndroidAmbiguous => "ANDROID_AMBIGUOUS",
                Self::WearOs => "WEAR_OS",
                Self::ArWrist => "AR_WRIST",
                Self::ArDevice => "AR_DEVICE",
                Self::Uwp => "UWP",
                Self::Vr => "VR",
                Self::CloudApi => "CLOUD_API",
                Self::Smartglasses => "SMARTGLASSES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "CHROME" => Some(Self::Chrome),
                "FIREFOX" => Some(Self::Firefox),
                "IE" => Some(Self::Ie),
                "OPERA" => Some(Self::Opera),
                "SAFARI" => Some(Self::Safari),
                "EDGE" => Some(Self::Edge),
                "DESKTOP" => Some(Self::Desktop),
                "IPAD" => Some(Self::Ipad),
                "ANDROID_TABLET" => Some(Self::AndroidTablet),
                "OHANA" => Some(Self::Ohana),
                "ALOHA" => Some(Self::Aloha),
                "CATALINA" => Some(Self::Catalina),
                "TCL_TV" => Some(Self::TclTv),
                "IOS_PHONE" => Some(Self::IosPhone),
                "IOS_CATALYST" => Some(Self::IosCatalyst),
                "ANDROID_PHONE" => Some(Self::AndroidPhone),
                "ANDROID_AMBIGUOUS" => Some(Self::AndroidAmbiguous),
                "WEAR_OS" => Some(Self::WearOs),
                "AR_WRIST" => Some(Self::ArWrist),
                "AR_DEVICE" => Some(Self::ArDevice),
                "UWP" => Some(Self::Uwp),
                "VR" => Some(Self::Vr),
                "CLOUD_API" => Some(Self::CloudApi),
                "SMARTGLASSES" => Some(Self::Smartglasses),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DisappearingMode {
    #[prost(enumeration="disappearing_mode::Initiator", optional, tag="1")]
    pub initiator: ::core::option::Option<i32>,
    #[prost(enumeration="disappearing_mode::Trigger", optional, tag="2")]
    pub trigger: ::core::option::Option<i32>,
    #[prost(string, optional, tag="3")]
    pub initiator_device_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="4")]
    pub initiated_by_me: ::core::option::Option<bool>,
}
/// Nested message and enum types in `DisappearingMode`.
pub mod disappearing_mode {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Initiator {
        ChangedInChat = 0,
        InitiatedByMe = 1,
        InitiatedByOther = 2,
        BizUpgradeFbHosting = 3,
    }
    impl Initiator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ChangedInChat => "CHANGED_IN_CHAT",
                Self::InitiatedByMe => "INITIATED_BY_ME",
                Self::InitiatedByOther => "INITIATED_BY_OTHER",
                Self::BizUpgradeFbHosting => "BIZ_UPGRADE_FB_HOSTING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHANGED_IN_CHAT" => Some(Self::ChangedInChat),
                "INITIATED_BY_ME" => Some(Self::InitiatedByMe),
                "INITIATED_BY_OTHER" => Some(Self::InitiatedByOther),
                "BIZ_UPGRADE_FB_HOSTING" => Some(Self::BizUpgradeFbHosting),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Trigger {
        Unknown = 0,
        ChatSetting = 1,
        AccountSetting = 2,
        BulkChange = 3,
        BizSupportsFbHosting = 4,
        UnknownGroups = 5,
    }
    impl Trigger {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::ChatSetting => "CHAT_SETTING",
                Self::AccountSetting => "ACCOUNT_SETTING",
                Self::BulkChange => "BULK_CHANGE",
                Self::BizSupportsFbHosting => "BIZ_SUPPORTS_FB_HOSTING",
                Self::UnknownGroups => "UNKNOWN_GROUPS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "CHAT_SETTING" => Some(Self::ChatSetting),
                "ACCOUNT_SETTING" => Some(Self::AccountSetting),
                "BULK_CHANGE" => Some(Self::BulkChange),
                "BIZ_SUPPORTS_FB_HOSTING" => Some(Self::BizSupportsFbHosting),
                "UNKNOWN_GROUPS" => Some(Self::UnknownGroups),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmbeddedContent {
    #[prost(oneof="embedded_content::Content", tags="1, 2")]
    pub content: ::core::option::Option<embedded_content::Content>,
}
/// Nested message and enum types in `EmbeddedContent`.
pub mod embedded_content {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        #[prost(message, tag="1")]
        EmbeddedMessage(super::EmbeddedMessage),
        #[prost(message, tag="2")]
        EmbeddedMusic(super::EmbeddedMusic),
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmbeddedMessage {
    #[prost(string, optional, tag="1")]
    pub stanza_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="2")]
    pub message: ::core::option::Option<Message>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EmbeddedMusic {
    #[prost(string, optional, tag="1")]
    pub music_content_media_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub song_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub author: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub title: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="5")]
    pub artwork_direct_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="vec", optional, tag="6")]
    pub artwork_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="7")]
    pub artwork_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="11")]
    pub artwork_media_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag="8")]
    pub artist_attribution: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="vec", optional, tag="9")]
    pub country_blocklist: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag="10")]
    pub is_explicit: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EncryptedPairingRequest {
    #[prost(bytes="vec", optional, tag="1")]
    pub encrypted_payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="2")]
    pub iv: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EphemeralSetting {
    #[prost(sfixed32, optional, tag="1")]
    pub duration: ::core::option::Option<i32>,
    #[prost(sfixed64, optional, tag="2")]
    pub timestamp: ::core::option::Option<i64>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventAdditionalMetadata {
    #[prost(bool, optional, tag="1")]
    pub is_stale: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventResponse {
    #[prost(message, optional, tag="1")]
    pub event_response_message_key: ::core::option::Option<MessageKey>,
    #[prost(int64, optional, tag="2")]
    pub timestamp_ms: ::core::option::Option<i64>,
    #[prost(message, optional, tag="3")]
    pub event_response_message: ::core::option::Option<message::EventResponseMessage>,
    #[prost(bool, optional, tag="4")]
    pub unread: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExitCode {
    #[prost(uint64, optional, tag="1")]
    pub code: ::core::option::Option<u64>,
    #[prost(string, optional, tag="2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExternalBlobReference {
    #[prost(bytes="vec", optional, tag="1")]
    pub media_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag="2")]
    pub direct_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub handle: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag="4")]
    pub file_size_bytes: ::core::option::Option<u64>,
    #[prost(bytes="vec", optional, tag="5")]
    pub file_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="6")]
    pub file_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Field {
    #[prost(uint32, optional, tag="1")]
    pub min_version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub max_version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub not_reportable_min_version: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="4")]
    pub is_message: ::core::option::Option<bool>,
    #[prost(map="uint32, message", tag="5")]
    pub subfield: ::std::collections::HashMap<u32, Field>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalSettings {
    #[prost(message, optional, tag="1")]
    pub light_theme_wallpaper: ::core::option::Option<WallpaperSettings>,
    #[prost(enumeration="MediaVisibility", optional, tag="2")]
    pub media_visibility: ::core::option::Option<i32>,
    #[prost(message, optional, tag="3")]
    pub dark_theme_wallpaper: ::core::option::Option<WallpaperSettings>,
    #[prost(message, optional, tag="4")]
    pub auto_download_wi_fi: ::core::option::Option<AutoDownloadSettings>,
    #[prost(message, optional, tag="5")]
    pub auto_download_cellular: ::core::option::Option<AutoDownloadSettings>,
    #[prost(message, optional, tag="6")]
    pub auto_download_roaming: ::core::option::Option<AutoDownloadSettings>,
    #[prost(bool, optional, tag="7")]
    pub show_individual_notifications_preview: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="8")]
    pub show_group_notifications_preview: ::core::option::Option<bool>,
    #[prost(int32, optional, tag="9")]
    pub disappearing_mode_duration: ::core::option::Option<i32>,
    #[prost(int64, optional, tag="10")]
    pub disappearing_mode_timestamp: ::core::option::Option<i64>,
    #[prost(message, optional, tag="11")]
    pub avatar_user_settings: ::core::option::Option<AvatarUserSettings>,
    #[prost(int32, optional, tag="12")]
    pub font_size: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="13")]
    pub security_notifications: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="14")]
    pub auto_unarchive_chats: ::core::option::Option<bool>,
    #[prost(int32, optional, tag="15")]
    pub video_quality_mode: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="16")]
    pub photo_quality_mode: ::core::option::Option<i32>,
    #[prost(message, optional, tag="17")]
    pub individual_notification_settings: ::core::option::Option<NotificationSettings>,
    #[prost(message, optional, tag="18")]
    pub group_notification_settings: ::core::option::Option<NotificationSettings>,
    #[prost(message, optional, tag="19")]
    pub chat_lock_settings: ::core::option::Option<ChatLockSettings>,
    #[prost(int64, optional, tag="20")]
    pub chat_db_lid_migration_timestamp: ::core::option::Option<i64>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupMention {
    #[prost(string, optional, tag="1")]
    pub group_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub group_subject: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupParticipant {
    #[prost(string, required, tag="1")]
    pub user_jid: ::prost::alloc::string::String,
    #[prost(enumeration="group_participant::Rank", optional, tag="2")]
    pub rank: ::core::option::Option<i32>,
}
/// Nested message and enum types in `GroupParticipant`.
pub mod group_participant {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Rank {
        Regular = 0,
        Admin = 1,
        Superadmin = 2,
    }
    impl Rank {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Regular => "REGULAR",
                Self::Admin => "ADMIN",
                Self::Superadmin => "SUPERADMIN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REGULAR" => Some(Self::Regular),
                "ADMIN" => Some(Self::Admin),
                "SUPERADMIN" => Some(Self::Superadmin),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HandshakeMessage {
    #[prost(message, optional, tag="2")]
    pub client_hello: ::core::option::Option<handshake_message::ClientHello>,
    #[prost(message, optional, tag="3")]
    pub server_hello: ::core::option::Option<handshake_message::ServerHello>,
    #[prost(message, optional, tag="4")]
    pub client_finish: ::core::option::Option<handshake_message::ClientFinish>,
}
/// Nested message and enum types in `HandshakeMessage`.
pub mod handshake_message {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ClientFinish {
        #[prost(bytes="vec", optional, tag="1")]
        pub r#static: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="2")]
        pub payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ClientHello {
        #[prost(bytes="vec", optional, tag="1")]
        pub ephemeral: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="2")]
        pub r#static: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="3")]
        pub payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ServerHello {
        #[prost(bytes="vec", optional, tag="1")]
        pub ephemeral: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="2")]
        pub r#static: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="3")]
        pub payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistorySync {
    #[prost(enumeration="history_sync::HistorySyncType", required, tag="1")]
    pub sync_type: i32,
    #[prost(message, repeated, tag="2")]
    pub conversations: ::prost::alloc::vec::Vec<Conversation>,
    #[prost(message, repeated, tag="3")]
    pub status_v3_messages: ::prost::alloc::vec::Vec<WebMessageInfo>,
    #[prost(uint32, optional, tag="5")]
    pub chunk_order: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub progress: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="7")]
    pub pushnames: ::prost::alloc::vec::Vec<Pushname>,
    #[prost(message, optional, tag="8")]
    pub global_settings: ::core::option::Option<GlobalSettings>,
    #[prost(bytes="vec", optional, tag="9")]
    pub thread_id_user_secret: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag="10")]
    pub thread_ds_timeframe_offset: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="11")]
    pub recent_stickers: ::prost::alloc::vec::Vec<StickerMetadata>,
    #[prost(message, repeated, tag="12")]
    pub past_participants: ::prost::alloc::vec::Vec<PastParticipants>,
    #[prost(message, repeated, tag="13")]
    pub call_log_records: ::prost::alloc::vec::Vec<CallLogRecord>,
    #[prost(enumeration="history_sync::BotAiWaitListState", optional, tag="14")]
    pub ai_wait_list_state: ::core::option::Option<i32>,
    #[prost(message, repeated, tag="15")]
    pub phone_number_to_lid_mappings: ::prost::alloc::vec::Vec<PhoneNumberToLidMapping>,
    #[prost(string, optional, tag="16")]
    pub companion_meta_nonce: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="vec", optional, tag="17")]
    pub shareable_chat_identifier_encryption_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag="18")]
    pub accounts: ::prost::alloc::vec::Vec<Account>,
}
/// Nested message and enum types in `HistorySync`.
pub mod history_sync {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum BotAiWaitListState {
        InWaitlist = 0,
        AiAvailable = 1,
    }
    impl BotAiWaitListState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::InWaitlist => "IN_WAITLIST",
                Self::AiAvailable => "AI_AVAILABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IN_WAITLIST" => Some(Self::InWaitlist),
                "AI_AVAILABLE" => Some(Self::AiAvailable),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum HistorySyncType {
        InitialBootstrap = 0,
        InitialStatusV3 = 1,
        Full = 2,
        Recent = 3,
        PushName = 4,
        NonBlockingData = 5,
        OnDemand = 6,
    }
    impl HistorySyncType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::InitialBootstrap => "INITIAL_BOOTSTRAP",
                Self::InitialStatusV3 => "INITIAL_STATUS_V3",
                Self::Full => "FULL",
                Self::Recent => "RECENT",
                Self::PushName => "PUSH_NAME",
                Self::NonBlockingData => "NON_BLOCKING_DATA",
                Self::OnDemand => "ON_DEMAND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INITIAL_BOOTSTRAP" => Some(Self::InitialBootstrap),
                "INITIAL_STATUS_V3" => Some(Self::InitialStatusV3),
                "FULL" => Some(Self::Full),
                "RECENT" => Some(Self::Recent),
                "PUSH_NAME" => Some(Self::PushName),
                "NON_BLOCKING_DATA" => Some(Self::NonBlockingData),
                "ON_DEMAND" => Some(Self::OnDemand),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistorySyncMsg {
    #[prost(message, optional, tag="1")]
    pub message: ::core::option::Option<WebMessageInfo>,
    #[prost(uint64, optional, tag="2")]
    pub msg_order_id: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HydratedTemplateButton {
    #[prost(uint32, optional, tag="4")]
    pub index: ::core::option::Option<u32>,
    #[prost(oneof="hydrated_template_button::HydratedButton", tags="1, 2, 3")]
    pub hydrated_button: ::core::option::Option<hydrated_template_button::HydratedButton>,
}
/// Nested message and enum types in `HydratedTemplateButton`.
pub mod hydrated_template_button {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct HydratedCallButton {
        #[prost(string, optional, tag="1")]
        pub display_text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub phone_number: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct HydratedQuickReplyButton {
        #[prost(string, optional, tag="1")]
        pub display_text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub id: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct HydratedUrlButton {
        #[prost(string, optional, tag="1")]
        pub display_text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="3")]
        pub consented_users_url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration="hydrated_url_button::WebviewPresentationType", optional, tag="4")]
        pub webview_presentation: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `HydratedURLButton`.
    pub mod hydrated_url_button {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum WebviewPresentationType {
            Full = 1,
            Tall = 2,
            Compact = 3,
        }
        impl WebviewPresentationType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Full => "FULL",
                    Self::Tall => "TALL",
                    Self::Compact => "COMPACT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FULL" => Some(Self::Full),
                    "TALL" => Some(Self::Tall),
                    "COMPACT" => Some(Self::Compact),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum HydratedButton {
        #[prost(message, tag="1")]
        QuickReplyButton(HydratedQuickReplyButton),
        #[prost(message, tag="2")]
        UrlButton(HydratedUrlButton),
        #[prost(message, tag="3")]
        CallButton(HydratedCallButton),
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IdentityKeyPairStructure {
    #[prost(bytes="vec", optional, tag="1")]
    pub public_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="2")]
    pub private_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InteractiveAnnotation {
    #[prost(message, repeated, tag="1")]
    pub polygon_vertices: ::prost::alloc::vec::Vec<Point>,
    #[prost(bool, optional, tag="4")]
    pub should_skip_confirmation: ::core::option::Option<bool>,
    #[prost(message, optional, tag="5")]
    pub embedded_content: ::core::option::Option<EmbeddedContent>,
    #[prost(enumeration="interactive_annotation::StatusLinkType", optional, tag="8")]
    pub status_link_type: ::core::option::Option<i32>,
    #[prost(oneof="interactive_annotation::Action", tags="2, 3, 6, 7")]
    pub action: ::core::option::Option<interactive_annotation::Action>,
}
/// Nested message and enum types in `InteractiveAnnotation`.
pub mod interactive_annotation {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum StatusLinkType {
        RasterizedLinkPreview = 1,
        RasterizedLinkTruncated = 2,
        RasterizedLinkFullUrl = 3,
    }
    impl StatusLinkType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::RasterizedLinkPreview => "RASTERIZED_LINK_PREVIEW",
                Self::RasterizedLinkTruncated => "RASTERIZED_LINK_TRUNCATED",
                Self::RasterizedLinkFullUrl => "RASTERIZED_LINK_FULL_URL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RASTERIZED_LINK_PREVIEW" => Some(Self::RasterizedLinkPreview),
                "RASTERIZED_LINK_TRUNCATED" => Some(Self::RasterizedLinkTruncated),
                "RASTERIZED_LINK_FULL_URL" => Some(Self::RasterizedLinkFullUrl),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Action {
        #[prost(message, tag="2")]
        Location(super::Location),
        #[prost(message, tag="3")]
        Newsletter(super::context_info::ForwardedNewsletterMessageInfo),
        #[prost(bool, tag="6")]
        EmbeddedAction(bool),
        #[prost(message, tag="7")]
        TapAction(super::TapLinkAction),
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct KeepInChat {
    #[prost(enumeration="KeepType", optional, tag="1")]
    pub keep_type: ::core::option::Option<i32>,
    #[prost(int64, optional, tag="2")]
    pub server_timestamp: ::core::option::Option<i64>,
    #[prost(message, optional, tag="3")]
    pub key: ::core::option::Option<MessageKey>,
    #[prost(string, optional, tag="4")]
    pub device_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag="5")]
    pub client_timestamp_ms: ::core::option::Option<i64>,
    #[prost(int64, optional, tag="6")]
    pub server_timestamp_ms: ::core::option::Option<i64>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct KeyExchangeMessage {
    #[prost(uint32, optional, tag="1")]
    pub id: ::core::option::Option<u32>,
    #[prost(bytes="vec", optional, tag="2")]
    pub base_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="3")]
    pub ratchet_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="4")]
    pub identity_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="5")]
    pub base_key_signature: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct KeyId {
    #[prost(bytes="vec", optional, tag="1")]
    pub id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LidMigrationMapping {
    #[prost(uint64, required, tag="1")]
    pub pn: u64,
    #[prost(uint64, required, tag="2")]
    pub assigned_lid: u64,
    #[prost(uint64, optional, tag="3")]
    pub latest_lid: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LidMigrationMappingSyncMessage {
    #[prost(bytes="vec", optional, tag="1")]
    pub encoded_mapping_payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LidMigrationMappingSyncPayload {
    #[prost(message, repeated, tag="1")]
    pub pn_to_lid_mappings: ::prost::alloc::vec::Vec<LidMigrationMapping>,
    #[prost(uint64, optional, tag="2")]
    pub chat_db_migration_timestamp: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LegacyMessage {
    #[prost(message, optional, tag="1")]
    pub event_response_message: ::core::option::Option<message::EventResponseMessage>,
    #[prost(message, optional, tag="2")]
    pub poll_vote: ::core::option::Option<message::PollVoteMessage>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LimitSharing {
    #[prost(bool, optional, tag="1")]
    pub sharing_limited: ::core::option::Option<bool>,
    #[prost(enumeration="limit_sharing::TriggerType", optional, tag="2")]
    pub trigger: ::core::option::Option<i32>,
    #[prost(int64, optional, tag="3")]
    pub limit_sharing_setting_timestamp: ::core::option::Option<i64>,
    #[prost(bool, optional, tag="4")]
    pub initiated_by_me: ::core::option::Option<bool>,
}
/// Nested message and enum types in `LimitSharing`.
pub mod limit_sharing {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum TriggerType {
        Unknown = 0,
        ChatSetting = 1,
        BizSupportsFbHosting = 2,
        UnknownGroup = 3,
    }
    impl TriggerType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::ChatSetting => "CHAT_SETTING",
                Self::BizSupportsFbHosting => "BIZ_SUPPORTS_FB_HOSTING",
                Self::UnknownGroup => "UNKNOWN_GROUP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "CHAT_SETTING" => Some(Self::ChatSetting),
                "BIZ_SUPPORTS_FB_HOSTING" => Some(Self::BizSupportsFbHosting),
                "UNKNOWN_GROUP" => Some(Self::UnknownGroup),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LocalizedName {
    #[prost(string, optional, tag="1")]
    pub lg: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub lc: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub verified_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Location {
    #[prost(double, optional, tag="1")]
    pub degrees_latitude: ::core::option::Option<f64>,
    #[prost(double, optional, tag="2")]
    pub degrees_longitude: ::core::option::Option<f64>,
    #[prost(string, optional, tag="3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MediaData {
    #[prost(string, optional, tag="1")]
    pub local_path: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MediaNotifyMessage {
    #[prost(string, optional, tag="1")]
    pub express_path_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="vec", optional, tag="2")]
    pub file_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, optional, tag="3")]
    pub file_length: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MediaRetryNotification {
    #[prost(string, optional, tag="1")]
    pub stanza_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub direct_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration="media_retry_notification::ResultType", optional, tag="3")]
    pub result: ::core::option::Option<i32>,
    #[prost(bytes="vec", optional, tag="4")]
    pub message_secret: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `MediaRetryNotification`.
pub mod media_retry_notification {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ResultType {
        GeneralError = 0,
        Success = 1,
        NotFound = 2,
        DecryptionError = 3,
    }
    impl ResultType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::GeneralError => "GENERAL_ERROR",
                Self::Success => "SUCCESS",
                Self::NotFound => "NOT_FOUND",
                Self::DecryptionError => "DECRYPTION_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GENERAL_ERROR" => Some(Self::GeneralError),
                "SUCCESS" => Some(Self::Success),
                "NOT_FOUND" => Some(Self::NotFound),
                "DECRYPTION_ERROR" => Some(Self::DecryptionError),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MemberLabel {
    #[prost(string, optional, tag="1")]
    pub label: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag="2")]
    pub label_timestamp: ::core::option::Option<i64>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Message {
    #[prost(string, optional, tag="1")]
    pub conversation: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="2")]
    pub sender_key_distribution_message: ::core::option::Option<message::SenderKeyDistributionMessage>,
    #[prost(message, optional, boxed, tag="3")]
    pub image_message: ::core::option::Option<::prost::alloc::boxed::Box<message::ImageMessage>>,
    #[prost(message, optional, boxed, tag="4")]
    pub contact_message: ::core::option::Option<::prost::alloc::boxed::Box<message::ContactMessage>>,
    #[prost(message, optional, boxed, tag="5")]
    pub location_message: ::core::option::Option<::prost::alloc::boxed::Box<message::LocationMessage>>,
    #[prost(message, optional, boxed, tag="6")]
    pub extended_text_message: ::core::option::Option<::prost::alloc::boxed::Box<message::ExtendedTextMessage>>,
    #[prost(message, optional, boxed, tag="7")]
    pub document_message: ::core::option::Option<::prost::alloc::boxed::Box<message::DocumentMessage>>,
    #[prost(message, optional, boxed, tag="8")]
    pub audio_message: ::core::option::Option<::prost::alloc::boxed::Box<message::AudioMessage>>,
    #[prost(message, optional, boxed, tag="9")]
    pub video_message: ::core::option::Option<::prost::alloc::boxed::Box<message::VideoMessage>>,
    #[prost(message, optional, boxed, tag="10")]
    pub call: ::core::option::Option<::prost::alloc::boxed::Box<message::Call>>,
    #[prost(message, optional, tag="11")]
    pub chat: ::core::option::Option<message::Chat>,
    #[prost(message, optional, boxed, tag="12")]
    pub protocol_message: ::core::option::Option<::prost::alloc::boxed::Box<message::ProtocolMessage>>,
    #[prost(message, optional, boxed, tag="13")]
    pub contacts_array_message: ::core::option::Option<::prost::alloc::boxed::Box<message::ContactsArrayMessage>>,
    #[prost(message, optional, boxed, tag="14")]
    pub highly_structured_message: ::core::option::Option<::prost::alloc::boxed::Box<message::HighlyStructuredMessage>>,
    #[prost(message, optional, tag="15")]
    pub fast_ratchet_key_sender_key_distribution_message: ::core::option::Option<message::SenderKeyDistributionMessage>,
    #[prost(message, optional, boxed, tag="16")]
    pub send_payment_message: ::core::option::Option<::prost::alloc::boxed::Box<message::SendPaymentMessage>>,
    #[prost(message, optional, boxed, tag="18")]
    pub live_location_message: ::core::option::Option<::prost::alloc::boxed::Box<message::LiveLocationMessage>>,
    #[prost(message, optional, boxed, tag="22")]
    pub request_payment_message: ::core::option::Option<::prost::alloc::boxed::Box<message::RequestPaymentMessage>>,
    #[prost(message, optional, tag="23")]
    pub decline_payment_request_message: ::core::option::Option<message::DeclinePaymentRequestMessage>,
    #[prost(message, optional, tag="24")]
    pub cancel_payment_request_message: ::core::option::Option<message::CancelPaymentRequestMessage>,
    #[prost(message, optional, boxed, tag="25")]
    pub template_message: ::core::option::Option<::prost::alloc::boxed::Box<message::TemplateMessage>>,
    #[prost(message, optional, boxed, tag="26")]
    pub sticker_message: ::core::option::Option<::prost::alloc::boxed::Box<message::StickerMessage>>,
    #[prost(message, optional, boxed, tag="28")]
    pub group_invite_message: ::core::option::Option<::prost::alloc::boxed::Box<message::GroupInviteMessage>>,
    #[prost(message, optional, boxed, tag="29")]
    pub template_button_reply_message: ::core::option::Option<::prost::alloc::boxed::Box<message::TemplateButtonReplyMessage>>,
    #[prost(message, optional, boxed, tag="30")]
    pub product_message: ::core::option::Option<::prost::alloc::boxed::Box<message::ProductMessage>>,
    #[prost(message, optional, boxed, tag="31")]
    pub device_sent_message: ::core::option::Option<::prost::alloc::boxed::Box<message::DeviceSentMessage>>,
    #[prost(message, optional, tag="35")]
    pub message_context_info: ::core::option::Option<MessageContextInfo>,
    #[prost(message, optional, boxed, tag="36")]
    pub list_message: ::core::option::Option<::prost::alloc::boxed::Box<message::ListMessage>>,
    #[prost(message, optional, boxed, tag="37")]
    pub view_once_message: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, boxed, tag="38")]
    pub order_message: ::core::option::Option<::prost::alloc::boxed::Box<message::OrderMessage>>,
    #[prost(message, optional, boxed, tag="39")]
    pub list_response_message: ::core::option::Option<::prost::alloc::boxed::Box<message::ListResponseMessage>>,
    #[prost(message, optional, boxed, tag="40")]
    pub ephemeral_message: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, tag="41")]
    pub invoice_message: ::core::option::Option<message::InvoiceMessage>,
    #[prost(message, optional, boxed, tag="42")]
    pub buttons_message: ::core::option::Option<::prost::alloc::boxed::Box<message::ButtonsMessage>>,
    #[prost(message, optional, boxed, tag="43")]
    pub buttons_response_message: ::core::option::Option<::prost::alloc::boxed::Box<message::ButtonsResponseMessage>>,
    #[prost(message, optional, tag="44")]
    pub payment_invite_message: ::core::option::Option<message::PaymentInviteMessage>,
    #[prost(message, optional, boxed, tag="45")]
    pub interactive_message: ::core::option::Option<::prost::alloc::boxed::Box<message::InteractiveMessage>>,
    #[prost(message, optional, tag="46")]
    pub reaction_message: ::core::option::Option<message::ReactionMessage>,
    #[prost(message, optional, tag="47")]
    pub sticker_sync_rmr_message: ::core::option::Option<message::StickerSyncRmrMessage>,
    #[prost(message, optional, boxed, tag="48")]
    pub interactive_response_message: ::core::option::Option<::prost::alloc::boxed::Box<message::InteractiveResponseMessage>>,
    #[prost(message, optional, boxed, tag="49")]
    pub poll_creation_message: ::core::option::Option<::prost::alloc::boxed::Box<message::PollCreationMessage>>,
    #[prost(message, optional, tag="50")]
    pub poll_update_message: ::core::option::Option<message::PollUpdateMessage>,
    #[prost(message, optional, tag="51")]
    pub keep_in_chat_message: ::core::option::Option<message::KeepInChatMessage>,
    #[prost(message, optional, boxed, tag="53")]
    pub document_with_caption_message: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, boxed, tag="54")]
    pub request_phone_number_message: ::core::option::Option<::prost::alloc::boxed::Box<message::RequestPhoneNumberMessage>>,
    #[prost(message, optional, boxed, tag="55")]
    pub view_once_message_v2: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, tag="56")]
    pub enc_reaction_message: ::core::option::Option<message::EncReactionMessage>,
    #[prost(message, optional, boxed, tag="58")]
    pub edited_message: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, boxed, tag="59")]
    pub view_once_message_v2_extension: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, boxed, tag="60")]
    pub poll_creation_message_v2: ::core::option::Option<::prost::alloc::boxed::Box<message::PollCreationMessage>>,
    #[prost(message, optional, tag="61")]
    pub scheduled_call_creation_message: ::core::option::Option<message::ScheduledCallCreationMessage>,
    #[prost(message, optional, boxed, tag="62")]
    pub group_mentioned_message: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, tag="63")]
    pub pin_in_chat_message: ::core::option::Option<message::PinInChatMessage>,
    #[prost(message, optional, boxed, tag="64")]
    pub poll_creation_message_v3: ::core::option::Option<::prost::alloc::boxed::Box<message::PollCreationMessage>>,
    #[prost(message, optional, tag="65")]
    pub scheduled_call_edit_message: ::core::option::Option<message::ScheduledCallEditMessage>,
    #[prost(message, optional, boxed, tag="66")]
    pub ptv_message: ::core::option::Option<::prost::alloc::boxed::Box<message::VideoMessage>>,
    #[prost(message, optional, boxed, tag="67")]
    pub bot_invoke_message: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, tag="69")]
    pub call_log_messsage: ::core::option::Option<message::CallLogMessage>,
    #[prost(message, optional, boxed, tag="70")]
    pub message_history_bundle: ::core::option::Option<::prost::alloc::boxed::Box<message::MessageHistoryBundle>>,
    #[prost(message, optional, tag="71")]
    pub enc_comment_message: ::core::option::Option<message::EncCommentMessage>,
    #[prost(message, optional, tag="72")]
    pub bcall_message: ::core::option::Option<message::BCallMessage>,
    #[prost(message, optional, boxed, tag="74")]
    pub lottie_sticker_message: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, boxed, tag="75")]
    pub event_message: ::core::option::Option<::prost::alloc::boxed::Box<message::EventMessage>>,
    #[prost(message, optional, tag="76")]
    pub enc_event_response_message: ::core::option::Option<message::EncEventResponseMessage>,
    #[prost(message, optional, boxed, tag="77")]
    pub comment_message: ::core::option::Option<::prost::alloc::boxed::Box<message::CommentMessage>>,
    #[prost(message, optional, boxed, tag="78")]
    pub newsletter_admin_invite_message: ::core::option::Option<::prost::alloc::boxed::Box<message::NewsletterAdminInviteMessage>>,
    #[prost(message, optional, tag="80")]
    pub placeholder_message: ::core::option::Option<message::PlaceholderMessage>,
    #[prost(message, optional, tag="82")]
    pub secret_encrypted_message: ::core::option::Option<message::SecretEncryptedMessage>,
    #[prost(message, optional, boxed, tag="83")]
    pub album_message: ::core::option::Option<::prost::alloc::boxed::Box<message::AlbumMessage>>,
    #[prost(message, optional, boxed, tag="85")]
    pub event_cover_image: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, boxed, tag="86")]
    pub sticker_pack_message: ::core::option::Option<::prost::alloc::boxed::Box<message::StickerPackMessage>>,
    #[prost(message, optional, boxed, tag="87")]
    pub status_mention_message: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, boxed, tag="88")]
    pub poll_result_snapshot_message: ::core::option::Option<::prost::alloc::boxed::Box<message::PollResultSnapshotMessage>>,
    #[prost(message, optional, boxed, tag="90")]
    pub poll_creation_option_image_message: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, boxed, tag="91")]
    pub associated_child_message: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, boxed, tag="92")]
    pub group_status_mention_message: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, boxed, tag="93")]
    pub poll_creation_message_v4: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, boxed, tag="94")]
    pub poll_creation_message_v5: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, boxed, tag="95")]
    pub status_add_yours: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, boxed, tag="96")]
    pub group_status_message: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, tag="97")]
    pub rich_response_message: ::core::option::Option<AiRichResponseMessage>,
    #[prost(message, optional, tag="98")]
    pub status_notification_message: ::core::option::Option<message::StatusNotificationMessage>,
    #[prost(message, optional, boxed, tag="99")]
    pub limit_sharing_message: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, boxed, tag="100")]
    pub bot_task_message: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, boxed, tag="101")]
    pub question_message: ::core::option::Option<::prost::alloc::boxed::Box<message::FutureProofMessage>>,
    #[prost(message, optional, boxed, tag="102")]
    pub message_history_notice: ::core::option::Option<::prost::alloc::boxed::Box<message::MessageHistoryNotice>>,
}
/// Nested message and enum types in `Message`.
pub mod message {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AlbumMessage {
        #[prost(uint32, optional, tag="2")]
        pub expected_image_count: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="3")]
        pub expected_video_count: ::core::option::Option<u32>,
        #[prost(message, optional, boxed, tag="17")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AppStateFatalExceptionNotification {
        #[prost(string, repeated, tag="1")]
        pub collection_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(int64, optional, tag="2")]
        pub timestamp: ::core::option::Option<i64>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AppStateSyncKey {
        #[prost(message, optional, tag="1")]
        pub key_id: ::core::option::Option<AppStateSyncKeyId>,
        #[prost(message, optional, tag="2")]
        pub key_data: ::core::option::Option<AppStateSyncKeyData>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AppStateSyncKeyData {
        #[prost(bytes="vec", optional, tag="1")]
        pub key_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(message, optional, tag="2")]
        pub fingerprint: ::core::option::Option<AppStateSyncKeyFingerprint>,
        #[prost(int64, optional, tag="3")]
        pub timestamp: ::core::option::Option<i64>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AppStateSyncKeyFingerprint {
        #[prost(uint32, optional, tag="1")]
        pub raw_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="2")]
        pub current_index: ::core::option::Option<u32>,
        #[prost(uint32, repeated, tag="3")]
        pub device_indexes: ::prost::alloc::vec::Vec<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AppStateSyncKeyId {
        #[prost(bytes="vec", optional, tag="1")]
        pub key_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AppStateSyncKeyRequest {
        #[prost(message, repeated, tag="1")]
        pub key_ids: ::prost::alloc::vec::Vec<AppStateSyncKeyId>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AppStateSyncKeyShare {
        #[prost(message, repeated, tag="1")]
        pub keys: ::prost::alloc::vec::Vec<AppStateSyncKey>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AudioMessage {
        #[prost(string, optional, tag="1")]
        pub url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub mimetype: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="3")]
        pub file_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(uint64, optional, tag="4")]
        pub file_length: ::core::option::Option<u64>,
        #[prost(uint32, optional, tag="5")]
        pub seconds: ::core::option::Option<u32>,
        #[prost(bool, optional, tag="6")]
        pub ptt: ::core::option::Option<bool>,
        #[prost(bytes="vec", optional, tag="7")]
        pub media_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="8")]
        pub file_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="9")]
        pub direct_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int64, optional, tag="10")]
        pub media_key_timestamp: ::core::option::Option<i64>,
        #[prost(message, optional, boxed, tag="17")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(bytes="vec", optional, tag="18")]
        pub streaming_sidecar: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="19")]
        pub waveform: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(fixed32, optional, tag="20")]
        pub background_argb: ::core::option::Option<u32>,
        #[prost(bool, optional, tag="21")]
        pub view_once: ::core::option::Option<bool>,
        #[prost(string, optional, tag="22")]
        pub accessibility_label: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BCallMessage {
        #[prost(string, optional, tag="1")]
        pub session_id: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration="b_call_message::MediaType", optional, tag="2")]
        pub media_type: ::core::option::Option<i32>,
        #[prost(bytes="vec", optional, tag="3")]
        pub master_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="4")]
        pub caption: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `BCallMessage`.
    pub mod b_call_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum MediaType {
            Unknown = 0,
            Audio = 1,
            Video = 2,
        }
        impl MediaType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::Audio => "AUDIO",
                    Self::Video => "VIDEO",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "AUDIO" => Some(Self::Audio),
                    "VIDEO" => Some(Self::Video),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BotFeedbackMessage {
        #[prost(message, optional, tag="1")]
        pub message_key: ::core::option::Option<super::MessageKey>,
        #[prost(enumeration="bot_feedback_message::BotFeedbackKind", optional, tag="2")]
        pub kind: ::core::option::Option<i32>,
        #[prost(string, optional, tag="3")]
        pub text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint64, optional, tag="4")]
        pub kind_negative: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag="5")]
        pub kind_positive: ::core::option::Option<u64>,
        #[prost(enumeration="bot_feedback_message::ReportKind", optional, tag="6")]
        pub kind_report: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `BotFeedbackMessage`.
    pub mod bot_feedback_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum BotFeedbackKind {
            BotFeedbackPositive = 0,
            BotFeedbackNegativeGeneric = 1,
            BotFeedbackNegativeHelpful = 2,
            BotFeedbackNegativeInteresting = 3,
            BotFeedbackNegativeAccurate = 4,
            BotFeedbackNegativeSafe = 5,
            BotFeedbackNegativeOther = 6,
            BotFeedbackNegativeRefused = 7,
            BotFeedbackNegativeNotVisuallyAppealing = 8,
            BotFeedbackNegativeNotRelevantToText = 9,
            BotFeedbackNegativePersonalized = 10,
            BotFeedbackNegativeClarity = 11,
            BotFeedbackNegativeDoesntLookLikeThePerson = 12,
        }
        impl BotFeedbackKind {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::BotFeedbackPositive => "BOT_FEEDBACK_POSITIVE",
                    Self::BotFeedbackNegativeGeneric => "BOT_FEEDBACK_NEGATIVE_GENERIC",
                    Self::BotFeedbackNegativeHelpful => "BOT_FEEDBACK_NEGATIVE_HELPFUL",
                    Self::BotFeedbackNegativeInteresting => "BOT_FEEDBACK_NEGATIVE_INTERESTING",
                    Self::BotFeedbackNegativeAccurate => "BOT_FEEDBACK_NEGATIVE_ACCURATE",
                    Self::BotFeedbackNegativeSafe => "BOT_FEEDBACK_NEGATIVE_SAFE",
                    Self::BotFeedbackNegativeOther => "BOT_FEEDBACK_NEGATIVE_OTHER",
                    Self::BotFeedbackNegativeRefused => "BOT_FEEDBACK_NEGATIVE_REFUSED",
                    Self::BotFeedbackNegativeNotVisuallyAppealing => "BOT_FEEDBACK_NEGATIVE_NOT_VISUALLY_APPEALING",
                    Self::BotFeedbackNegativeNotRelevantToText => "BOT_FEEDBACK_NEGATIVE_NOT_RELEVANT_TO_TEXT",
                    Self::BotFeedbackNegativePersonalized => "BOT_FEEDBACK_NEGATIVE_PERSONALIZED",
                    Self::BotFeedbackNegativeClarity => "BOT_FEEDBACK_NEGATIVE_CLARITY",
                    Self::BotFeedbackNegativeDoesntLookLikeThePerson => "BOT_FEEDBACK_NEGATIVE_DOESNT_LOOK_LIKE_THE_PERSON",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "BOT_FEEDBACK_POSITIVE" => Some(Self::BotFeedbackPositive),
                    "BOT_FEEDBACK_NEGATIVE_GENERIC" => Some(Self::BotFeedbackNegativeGeneric),
                    "BOT_FEEDBACK_NEGATIVE_HELPFUL" => Some(Self::BotFeedbackNegativeHelpful),
                    "BOT_FEEDBACK_NEGATIVE_INTERESTING" => Some(Self::BotFeedbackNegativeInteresting),
                    "BOT_FEEDBACK_NEGATIVE_ACCURATE" => Some(Self::BotFeedbackNegativeAccurate),
                    "BOT_FEEDBACK_NEGATIVE_SAFE" => Some(Self::BotFeedbackNegativeSafe),
                    "BOT_FEEDBACK_NEGATIVE_OTHER" => Some(Self::BotFeedbackNegativeOther),
                    "BOT_FEEDBACK_NEGATIVE_REFUSED" => Some(Self::BotFeedbackNegativeRefused),
                    "BOT_FEEDBACK_NEGATIVE_NOT_VISUALLY_APPEALING" => Some(Self::BotFeedbackNegativeNotVisuallyAppealing),
                    "BOT_FEEDBACK_NEGATIVE_NOT_RELEVANT_TO_TEXT" => Some(Self::BotFeedbackNegativeNotRelevantToText),
                    "BOT_FEEDBACK_NEGATIVE_PERSONALIZED" => Some(Self::BotFeedbackNegativePersonalized),
                    "BOT_FEEDBACK_NEGATIVE_CLARITY" => Some(Self::BotFeedbackNegativeClarity),
                    "BOT_FEEDBACK_NEGATIVE_DOESNT_LOOK_LIKE_THE_PERSON" => Some(Self::BotFeedbackNegativeDoesntLookLikeThePerson),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum BotFeedbackKindMultipleNegative {
            BotFeedbackMultipleNegativeGeneric = 1,
            BotFeedbackMultipleNegativeHelpful = 2,
            BotFeedbackMultipleNegativeInteresting = 4,
            BotFeedbackMultipleNegativeAccurate = 8,
            BotFeedbackMultipleNegativeSafe = 16,
            BotFeedbackMultipleNegativeOther = 32,
            BotFeedbackMultipleNegativeRefused = 64,
            BotFeedbackMultipleNegativeNotVisuallyAppealing = 128,
            BotFeedbackMultipleNegativeNotRelevantToText = 256,
        }
        impl BotFeedbackKindMultipleNegative {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::BotFeedbackMultipleNegativeGeneric => "BOT_FEEDBACK_MULTIPLE_NEGATIVE_GENERIC",
                    Self::BotFeedbackMultipleNegativeHelpful => "BOT_FEEDBACK_MULTIPLE_NEGATIVE_HELPFUL",
                    Self::BotFeedbackMultipleNegativeInteresting => "BOT_FEEDBACK_MULTIPLE_NEGATIVE_INTERESTING",
                    Self::BotFeedbackMultipleNegativeAccurate => "BOT_FEEDBACK_MULTIPLE_NEGATIVE_ACCURATE",
                    Self::BotFeedbackMultipleNegativeSafe => "BOT_FEEDBACK_MULTIPLE_NEGATIVE_SAFE",
                    Self::BotFeedbackMultipleNegativeOther => "BOT_FEEDBACK_MULTIPLE_NEGATIVE_OTHER",
                    Self::BotFeedbackMultipleNegativeRefused => "BOT_FEEDBACK_MULTIPLE_NEGATIVE_REFUSED",
                    Self::BotFeedbackMultipleNegativeNotVisuallyAppealing => "BOT_FEEDBACK_MULTIPLE_NEGATIVE_NOT_VISUALLY_APPEALING",
                    Self::BotFeedbackMultipleNegativeNotRelevantToText => "BOT_FEEDBACK_MULTIPLE_NEGATIVE_NOT_RELEVANT_TO_TEXT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "BOT_FEEDBACK_MULTIPLE_NEGATIVE_GENERIC" => Some(Self::BotFeedbackMultipleNegativeGeneric),
                    "BOT_FEEDBACK_MULTIPLE_NEGATIVE_HELPFUL" => Some(Self::BotFeedbackMultipleNegativeHelpful),
                    "BOT_FEEDBACK_MULTIPLE_NEGATIVE_INTERESTING" => Some(Self::BotFeedbackMultipleNegativeInteresting),
                    "BOT_FEEDBACK_MULTIPLE_NEGATIVE_ACCURATE" => Some(Self::BotFeedbackMultipleNegativeAccurate),
                    "BOT_FEEDBACK_MULTIPLE_NEGATIVE_SAFE" => Some(Self::BotFeedbackMultipleNegativeSafe),
                    "BOT_FEEDBACK_MULTIPLE_NEGATIVE_OTHER" => Some(Self::BotFeedbackMultipleNegativeOther),
                    "BOT_FEEDBACK_MULTIPLE_NEGATIVE_REFUSED" => Some(Self::BotFeedbackMultipleNegativeRefused),
                    "BOT_FEEDBACK_MULTIPLE_NEGATIVE_NOT_VISUALLY_APPEALING" => Some(Self::BotFeedbackMultipleNegativeNotVisuallyAppealing),
                    "BOT_FEEDBACK_MULTIPLE_NEGATIVE_NOT_RELEVANT_TO_TEXT" => Some(Self::BotFeedbackMultipleNegativeNotRelevantToText),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum BotFeedbackKindMultiplePositive {
            BotFeedbackMultiplePositiveGeneric = 1,
        }
        impl BotFeedbackKindMultiplePositive {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::BotFeedbackMultiplePositiveGeneric => "BOT_FEEDBACK_MULTIPLE_POSITIVE_GENERIC",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "BOT_FEEDBACK_MULTIPLE_POSITIVE_GENERIC" => Some(Self::BotFeedbackMultiplePositiveGeneric),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum ReportKind {
            Generic = 0,
        }
        impl ReportKind {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Generic => "GENERIC",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "GENERIC" => Some(Self::Generic),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ButtonsMessage {
        #[prost(string, optional, tag="6")]
        pub content_text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="7")]
        pub footer_text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, boxed, tag="8")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(message, repeated, tag="9")]
        pub buttons: ::prost::alloc::vec::Vec<buttons_message::Button>,
        #[prost(enumeration="buttons_message::HeaderType", optional, tag="10")]
        pub header_type: ::core::option::Option<i32>,
        #[prost(oneof="buttons_message::Header", tags="1, 2, 3, 4, 5")]
        pub header: ::core::option::Option<buttons_message::Header>,
    }
    /// Nested message and enum types in `ButtonsMessage`.
    pub mod buttons_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Button {
            #[prost(string, optional, tag="1")]
            pub button_id: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(message, optional, tag="2")]
            pub button_text: ::core::option::Option<button::ButtonText>,
            #[prost(enumeration="button::Type", optional, tag="3")]
            pub r#type: ::core::option::Option<i32>,
            #[prost(message, optional, tag="4")]
            pub native_flow_info: ::core::option::Option<button::NativeFlowInfo>,
        }
        /// Nested message and enum types in `Button`.
        pub mod button {
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ButtonText {
                #[prost(string, optional, tag="1")]
                pub display_text: ::core::option::Option<::prost::alloc::string::String>,
            }
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct NativeFlowInfo {
                #[prost(string, optional, tag="1")]
                pub name: ::core::option::Option<::prost::alloc::string::String>,
                #[prost(string, optional, tag="2")]
                pub params_json: ::core::option::Option<::prost::alloc::string::String>,
            }
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
            #[repr(i32)]
            pub enum Type {
                Unknown = 0,
                Response = 1,
                NativeFlow = 2,
            }
            impl Type {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unknown => "UNKNOWN",
                        Self::Response => "RESPONSE",
                        Self::NativeFlow => "NATIVE_FLOW",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "UNKNOWN" => Some(Self::Unknown),
                        "RESPONSE" => Some(Self::Response),
                        "NATIVE_FLOW" => Some(Self::NativeFlow),
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum HeaderType {
            Unknown = 0,
            Empty = 1,
            Text = 2,
            Document = 3,
            Image = 4,
            Video = 5,
            Location = 6,
        }
        impl HeaderType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::Empty => "EMPTY",
                    Self::Text => "TEXT",
                    Self::Document => "DOCUMENT",
                    Self::Image => "IMAGE",
                    Self::Video => "VIDEO",
                    Self::Location => "LOCATION",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "EMPTY" => Some(Self::Empty),
                    "TEXT" => Some(Self::Text),
                    "DOCUMENT" => Some(Self::Document),
                    "IMAGE" => Some(Self::Image),
                    "VIDEO" => Some(Self::Video),
                    "LOCATION" => Some(Self::Location),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Header {
            #[prost(string, tag="1")]
            Text(::prost::alloc::string::String),
            #[prost(message, tag="2")]
            DocumentMessage(::prost::alloc::boxed::Box<super::DocumentMessage>),
            #[prost(message, tag="3")]
            ImageMessage(::prost::alloc::boxed::Box<super::ImageMessage>),
            #[prost(message, tag="4")]
            VideoMessage(::prost::alloc::boxed::Box<super::VideoMessage>),
            #[prost(message, tag="5")]
            LocationMessage(::prost::alloc::boxed::Box<super::LocationMessage>),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ButtonsResponseMessage {
        #[prost(string, optional, tag="1")]
        pub selected_button_id: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, boxed, tag="3")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(enumeration="buttons_response_message::Type", optional, tag="4")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(oneof="buttons_response_message::Response", tags="2")]
        pub response: ::core::option::Option<buttons_response_message::Response>,
    }
    /// Nested message and enum types in `ButtonsResponseMessage`.
    pub mod buttons_response_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum Type {
            Unknown = 0,
            DisplayText = 1,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::DisplayText => "DISPLAY_TEXT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "DISPLAY_TEXT" => Some(Self::DisplayText),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Response {
            #[prost(string, tag="2")]
            SelectedDisplayText(::prost::alloc::string::String),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Call {
        #[prost(bytes="vec", optional, tag="1")]
        pub call_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="2")]
        pub conversion_source: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="3")]
        pub conversion_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(uint32, optional, tag="4")]
        pub conversion_delay_seconds: ::core::option::Option<u32>,
        #[prost(string, optional, tag="5")]
        pub ctwa_signals: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="6")]
        pub ctwa_payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(message, optional, boxed, tag="7")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CallLogMessage {
        #[prost(bool, optional, tag="1")]
        pub is_video: ::core::option::Option<bool>,
        #[prost(enumeration="call_log_message::CallOutcome", optional, tag="2")]
        pub call_outcome: ::core::option::Option<i32>,
        #[prost(int64, optional, tag="3")]
        pub duration_secs: ::core::option::Option<i64>,
        #[prost(enumeration="call_log_message::CallType", optional, tag="4")]
        pub call_type: ::core::option::Option<i32>,
        #[prost(message, repeated, tag="5")]
        pub participants: ::prost::alloc::vec::Vec<call_log_message::CallParticipant>,
    }
    /// Nested message and enum types in `CallLogMessage`.
    pub mod call_log_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CallParticipant {
            #[prost(string, optional, tag="1")]
            pub jid: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(enumeration="CallOutcome", optional, tag="2")]
            pub call_outcome: ::core::option::Option<i32>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum CallOutcome {
            Connected = 0,
            Missed = 1,
            Failed = 2,
            Rejected = 3,
            AcceptedElsewhere = 4,
            Ongoing = 5,
            SilencedByDnd = 6,
            SilencedUnknownCaller = 7,
        }
        impl CallOutcome {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Connected => "CONNECTED",
                    Self::Missed => "MISSED",
                    Self::Failed => "FAILED",
                    Self::Rejected => "REJECTED",
                    Self::AcceptedElsewhere => "ACCEPTED_ELSEWHERE",
                    Self::Ongoing => "ONGOING",
                    Self::SilencedByDnd => "SILENCED_BY_DND",
                    Self::SilencedUnknownCaller => "SILENCED_UNKNOWN_CALLER",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CONNECTED" => Some(Self::Connected),
                    "MISSED" => Some(Self::Missed),
                    "FAILED" => Some(Self::Failed),
                    "REJECTED" => Some(Self::Rejected),
                    "ACCEPTED_ELSEWHERE" => Some(Self::AcceptedElsewhere),
                    "ONGOING" => Some(Self::Ongoing),
                    "SILENCED_BY_DND" => Some(Self::SilencedByDnd),
                    "SILENCED_UNKNOWN_CALLER" => Some(Self::SilencedUnknownCaller),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum CallType {
            Regular = 0,
            ScheduledCall = 1,
            VoiceChat = 2,
        }
        impl CallType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Regular => "REGULAR",
                    Self::ScheduledCall => "SCHEDULED_CALL",
                    Self::VoiceChat => "VOICE_CHAT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "REGULAR" => Some(Self::Regular),
                    "SCHEDULED_CALL" => Some(Self::ScheduledCall),
                    "VOICE_CHAT" => Some(Self::VoiceChat),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct CancelPaymentRequestMessage {
        #[prost(message, optional, tag="1")]
        pub key: ::core::option::Option<super::MessageKey>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Chat {
        #[prost(string, optional, tag="1")]
        pub display_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub id: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct CloudApiThreadControlNotification {
        #[prost(enumeration="cloud_api_thread_control_notification::CloudApiThreadControl", optional, tag="1")]
        pub status: ::core::option::Option<i32>,
        #[prost(int64, optional, tag="2")]
        pub sender_notification_timestamp_ms: ::core::option::Option<i64>,
        #[prost(string, optional, tag="3")]
        pub consumer_lid: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="4")]
        pub consumer_phone_number: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, tag="5")]
        pub notification_content: ::core::option::Option<cloud_api_thread_control_notification::CloudApiThreadControlNotificationContent>,
    }
    /// Nested message and enum types in `CloudAPIThreadControlNotification`.
    pub mod cloud_api_thread_control_notification {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CloudApiThreadControlNotificationContent {
            #[prost(string, optional, tag="1")]
            pub handoff_notification_text: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="2")]
            pub extra_json: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum CloudApiThreadControl {
            Unknown = 0,
            ControlPassed = 1,
            ControlTaken = 2,
        }
        impl CloudApiThreadControl {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::ControlPassed => "CONTROL_PASSED",
                    Self::ControlTaken => "CONTROL_TAKEN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "CONTROL_PASSED" => Some(Self::ControlPassed),
                    "CONTROL_TAKEN" => Some(Self::ControlTaken),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CommentMessage {
        #[prost(message, optional, boxed, tag="1")]
        pub message: ::core::option::Option<::prost::alloc::boxed::Box<super::Message>>,
        #[prost(message, optional, tag="2")]
        pub target_message_key: ::core::option::Option<super::MessageKey>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContactMessage {
        #[prost(string, optional, tag="1")]
        pub display_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="16")]
        pub vcard: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, boxed, tag="17")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContactsArrayMessage {
        #[prost(string, optional, tag="1")]
        pub display_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="2")]
        pub contacts: ::prost::alloc::vec::Vec<ContactMessage>,
        #[prost(message, optional, boxed, tag="17")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DeclinePaymentRequestMessage {
        #[prost(message, optional, tag="1")]
        pub key: ::core::option::Option<super::MessageKey>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeviceSentMessage {
        #[prost(string, optional, tag="1")]
        pub destination_jid: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, boxed, tag="2")]
        pub message: ::core::option::Option<::prost::alloc::boxed::Box<super::Message>>,
        #[prost(string, optional, tag="3")]
        pub phash: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DocumentMessage {
        #[prost(string, optional, tag="1")]
        pub url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub mimetype: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="3")]
        pub title: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="4")]
        pub file_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(uint64, optional, tag="5")]
        pub file_length: ::core::option::Option<u64>,
        #[prost(uint32, optional, tag="6")]
        pub page_count: ::core::option::Option<u32>,
        #[prost(bytes="vec", optional, tag="7")]
        pub media_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="8")]
        pub file_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="9")]
        pub file_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="10")]
        pub direct_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int64, optional, tag="11")]
        pub media_key_timestamp: ::core::option::Option<i64>,
        #[prost(bool, optional, tag="12")]
        pub contact_vcard: ::core::option::Option<bool>,
        #[prost(string, optional, tag="13")]
        pub thumbnail_direct_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="14")]
        pub thumbnail_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="15")]
        pub thumbnail_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="16")]
        pub jpeg_thumbnail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(message, optional, boxed, tag="17")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(uint32, optional, tag="18")]
        pub thumbnail_height: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="19")]
        pub thumbnail_width: ::core::option::Option<u32>,
        #[prost(string, optional, tag="20")]
        pub caption: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="21")]
        pub accessibility_label: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct EncCommentMessage {
        #[prost(message, optional, tag="1")]
        pub target_message_key: ::core::option::Option<super::MessageKey>,
        #[prost(bytes="vec", optional, tag="2")]
        pub enc_payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="3")]
        pub enc_iv: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct EncEventResponseMessage {
        #[prost(message, optional, tag="1")]
        pub event_creation_message_key: ::core::option::Option<super::MessageKey>,
        #[prost(bytes="vec", optional, tag="2")]
        pub enc_payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="3")]
        pub enc_iv: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct EncReactionMessage {
        #[prost(message, optional, tag="1")]
        pub target_message_key: ::core::option::Option<super::MessageKey>,
        #[prost(bytes="vec", optional, tag="2")]
        pub enc_payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="3")]
        pub enc_iv: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EventMessage {
        #[prost(message, optional, boxed, tag="1")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(bool, optional, tag="2")]
        pub is_canceled: ::core::option::Option<bool>,
        #[prost(string, optional, tag="3")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="4")]
        pub description: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, boxed, tag="5")]
        pub location: ::core::option::Option<::prost::alloc::boxed::Box<LocationMessage>>,
        #[prost(string, optional, tag="6")]
        pub join_link: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int64, optional, tag="7")]
        pub start_time: ::core::option::Option<i64>,
        #[prost(int64, optional, tag="8")]
        pub end_time: ::core::option::Option<i64>,
        #[prost(bool, optional, tag="9")]
        pub extra_guests_allowed: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="10")]
        pub is_schedule_call: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct EventResponseMessage {
        #[prost(enumeration="event_response_message::EventResponseType", optional, tag="1")]
        pub response: ::core::option::Option<i32>,
        #[prost(int64, optional, tag="2")]
        pub timestamp_ms: ::core::option::Option<i64>,
        #[prost(int32, optional, tag="3")]
        pub extra_guest_count: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `EventResponseMessage`.
    pub mod event_response_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum EventResponseType {
            Unknown = 0,
            Going = 1,
            NotGoing = 2,
            Maybe = 3,
        }
        impl EventResponseType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::Going => "GOING",
                    Self::NotGoing => "NOT_GOING",
                    Self::Maybe => "MAYBE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "GOING" => Some(Self::Going),
                    "NOT_GOING" => Some(Self::NotGoing),
                    "MAYBE" => Some(Self::Maybe),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExtendedTextMessage {
        #[prost(string, optional, tag="1")]
        pub text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub matched_text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="5")]
        pub description: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="6")]
        pub title: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(fixed32, optional, tag="7")]
        pub text_argb: ::core::option::Option<u32>,
        #[prost(fixed32, optional, tag="8")]
        pub background_argb: ::core::option::Option<u32>,
        #[prost(enumeration="extended_text_message::FontType", optional, tag="9")]
        pub font: ::core::option::Option<i32>,
        #[prost(enumeration="extended_text_message::PreviewType", optional, tag="10")]
        pub preview_type: ::core::option::Option<i32>,
        #[prost(bytes="vec", optional, tag="16")]
        pub jpeg_thumbnail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(message, optional, boxed, tag="17")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(bool, optional, tag="18")]
        pub do_not_play_inline: ::core::option::Option<bool>,
        #[prost(string, optional, tag="19")]
        pub thumbnail_direct_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="20")]
        pub thumbnail_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="21")]
        pub thumbnail_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="22")]
        pub media_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(int64, optional, tag="23")]
        pub media_key_timestamp: ::core::option::Option<i64>,
        #[prost(uint32, optional, tag="24")]
        pub thumbnail_height: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="25")]
        pub thumbnail_width: ::core::option::Option<u32>,
        #[prost(enumeration="extended_text_message::InviteLinkGroupType", optional, tag="26")]
        pub invite_link_group_type: ::core::option::Option<i32>,
        #[prost(string, optional, tag="27")]
        pub invite_link_parent_group_subject_v2: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="28")]
        pub invite_link_parent_group_thumbnail_v2: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(enumeration="extended_text_message::InviteLinkGroupType", optional, tag="29")]
        pub invite_link_group_type_v2: ::core::option::Option<i32>,
        #[prost(bool, optional, tag="30")]
        pub view_once: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag="31")]
        pub video_height: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="32")]
        pub video_width: ::core::option::Option<u32>,
        #[prost(message, optional, tag="33")]
        pub favicon_mms_metadata: ::core::option::Option<MmsThumbnailMetadata>,
        #[prost(message, optional, tag="34")]
        pub link_preview_metadata: ::core::option::Option<LinkPreviewMetadata>,
        #[prost(message, optional, tag="35")]
        pub payment_link_metadata: ::core::option::Option<PaymentLinkMetadata>,
    }
    /// Nested message and enum types in `ExtendedTextMessage`.
    pub mod extended_text_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum FontType {
            System = 0,
            SystemText = 1,
            FbScript = 2,
            SystemBold = 6,
            MorningbreezeRegular = 7,
            CalistogaRegular = 8,
            Exo2Extrabold = 9,
            CourierprimeBold = 10,
        }
        impl FontType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::System => "SYSTEM",
                    Self::SystemText => "SYSTEM_TEXT",
                    Self::FbScript => "FB_SCRIPT",
                    Self::SystemBold => "SYSTEM_BOLD",
                    Self::MorningbreezeRegular => "MORNINGBREEZE_REGULAR",
                    Self::CalistogaRegular => "CALISTOGA_REGULAR",
                    Self::Exo2Extrabold => "EXO2_EXTRABOLD",
                    Self::CourierprimeBold => "COURIERPRIME_BOLD",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SYSTEM" => Some(Self::System),
                    "SYSTEM_TEXT" => Some(Self::SystemText),
                    "FB_SCRIPT" => Some(Self::FbScript),
                    "SYSTEM_BOLD" => Some(Self::SystemBold),
                    "MORNINGBREEZE_REGULAR" => Some(Self::MorningbreezeRegular),
                    "CALISTOGA_REGULAR" => Some(Self::CalistogaRegular),
                    "EXO2_EXTRABOLD" => Some(Self::Exo2Extrabold),
                    "COURIERPRIME_BOLD" => Some(Self::CourierprimeBold),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum InviteLinkGroupType {
            Default = 0,
            Parent = 1,
            Sub = 2,
            DefaultSub = 3,
        }
        impl InviteLinkGroupType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Default => "DEFAULT",
                    Self::Parent => "PARENT",
                    Self::Sub => "SUB",
                    Self::DefaultSub => "DEFAULT_SUB",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DEFAULT" => Some(Self::Default),
                    "PARENT" => Some(Self::Parent),
                    "SUB" => Some(Self::Sub),
                    "DEFAULT_SUB" => Some(Self::DefaultSub),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum PreviewType {
            None = 0,
            Video = 1,
            Placeholder = 4,
            Image = 5,
            PaymentLinks = 6,
            Profile = 7,
        }
        impl PreviewType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::None => "NONE",
                    Self::Video => "VIDEO",
                    Self::Placeholder => "PLACEHOLDER",
                    Self::Image => "IMAGE",
                    Self::PaymentLinks => "PAYMENT_LINKS",
                    Self::Profile => "PROFILE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NONE" => Some(Self::None),
                    "VIDEO" => Some(Self::Video),
                    "PLACEHOLDER" => Some(Self::Placeholder),
                    "IMAGE" => Some(Self::Image),
                    "PAYMENT_LINKS" => Some(Self::PaymentLinks),
                    "PROFILE" => Some(Self::Profile),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct FullHistorySyncOnDemandRequestMetadata {
        #[prost(string, optional, tag="1")]
        pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FutureProofMessage {
        #[prost(message, optional, boxed, tag="1")]
        pub message: ::core::option::Option<::prost::alloc::boxed::Box<super::Message>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GroupInviteMessage {
        #[prost(string, optional, tag="1")]
        pub group_jid: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub invite_code: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int64, optional, tag="3")]
        pub invite_expiration: ::core::option::Option<i64>,
        #[prost(string, optional, tag="4")]
        pub group_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="5")]
        pub jpeg_thumbnail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="6")]
        pub caption: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, boxed, tag="7")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(enumeration="group_invite_message::GroupType", optional, tag="8")]
        pub group_type: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `GroupInviteMessage`.
    pub mod group_invite_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum GroupType {
            Default = 0,
            Parent = 1,
        }
        impl GroupType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Default => "DEFAULT",
                    Self::Parent => "PARENT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DEFAULT" => Some(Self::Default),
                    "PARENT" => Some(Self::Parent),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HighlyStructuredMessage {
        #[prost(string, optional, tag="1")]
        pub namespace: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub element_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, repeated, tag="3")]
        pub params: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, optional, tag="4")]
        pub fallback_lg: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="5")]
        pub fallback_lc: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="6")]
        pub localizable_params: ::prost::alloc::vec::Vec<highly_structured_message::HsmLocalizableParameter>,
        #[prost(string, optional, tag="7")]
        pub deterministic_lg: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="8")]
        pub deterministic_lc: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, boxed, tag="9")]
        pub hydrated_hsm: ::core::option::Option<::prost::alloc::boxed::Box<TemplateMessage>>,
    }
    /// Nested message and enum types in `HighlyStructuredMessage`.
    pub mod highly_structured_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct HsmLocalizableParameter {
            #[prost(string, optional, tag="1")]
            pub default: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(oneof="hsm_localizable_parameter::ParamOneof", tags="2, 3")]
            pub param_oneof: ::core::option::Option<hsm_localizable_parameter::ParamOneof>,
        }
        /// Nested message and enum types in `HSMLocalizableParameter`.
        pub mod hsm_localizable_parameter {
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct HsmCurrency {
                #[prost(string, optional, tag="1")]
                pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
                #[prost(int64, optional, tag="2")]
                pub amount1000: ::core::option::Option<i64>,
            }
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct HsmDateTime {
                #[prost(oneof="hsm_date_time::DatetimeOneof", tags="1, 2")]
                pub datetime_oneof: ::core::option::Option<hsm_date_time::DatetimeOneof>,
            }
            /// Nested message and enum types in `HSMDateTime`.
            pub mod hsm_date_time {
                #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct HsmDateTimeComponent {
                    #[prost(enumeration="hsm_date_time_component::DayOfWeekType", optional, tag="1")]
                    pub day_of_week: ::core::option::Option<i32>,
                    #[prost(uint32, optional, tag="2")]
                    pub year: ::core::option::Option<u32>,
                    #[prost(uint32, optional, tag="3")]
                    pub month: ::core::option::Option<u32>,
                    #[prost(uint32, optional, tag="4")]
                    pub day_of_month: ::core::option::Option<u32>,
                    #[prost(uint32, optional, tag="5")]
                    pub hour: ::core::option::Option<u32>,
                    #[prost(uint32, optional, tag="6")]
                    pub minute: ::core::option::Option<u32>,
                    #[prost(enumeration="hsm_date_time_component::CalendarType", optional, tag="7")]
                    pub calendar: ::core::option::Option<i32>,
                }
                /// Nested message and enum types in `HSMDateTimeComponent`.
                pub mod hsm_date_time_component {
                    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
                    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
                    #[repr(i32)]
                    pub enum CalendarType {
                        Gregorian = 1,
                        SolarHijri = 2,
                    }
                    impl CalendarType {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Gregorian => "GREGORIAN",
                                Self::SolarHijri => "SOLAR_HIJRI",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "GREGORIAN" => Some(Self::Gregorian),
                                "SOLAR_HIJRI" => Some(Self::SolarHijri),
                                _ => None,
                            }
                        }
                    }
                    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
                    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
                    #[repr(i32)]
                    pub enum DayOfWeekType {
                        Monday = 1,
                        Tuesday = 2,
                        Wednesday = 3,
                        Thursday = 4,
                        Friday = 5,
                        Saturday = 6,
                        Sunday = 7,
                    }
                    impl DayOfWeekType {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Monday => "MONDAY",
                                Self::Tuesday => "TUESDAY",
                                Self::Wednesday => "WEDNESDAY",
                                Self::Thursday => "THURSDAY",
                                Self::Friday => "FRIDAY",
                                Self::Saturday => "SATURDAY",
                                Self::Sunday => "SUNDAY",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "MONDAY" => Some(Self::Monday),
                                "TUESDAY" => Some(Self::Tuesday),
                                "WEDNESDAY" => Some(Self::Wednesday),
                                "THURSDAY" => Some(Self::Thursday),
                                "FRIDAY" => Some(Self::Friday),
                                "SATURDAY" => Some(Self::Saturday),
                                "SUNDAY" => Some(Self::Sunday),
                                _ => None,
                            }
                        }
                    }
                }
                #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct HsmDateTimeUnixEpoch {
                    #[prost(int64, optional, tag="1")]
                    pub timestamp: ::core::option::Option<i64>,
                }
                #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
                pub enum DatetimeOneof {
                    #[prost(message, tag="1")]
                    Component(HsmDateTimeComponent),
                    #[prost(message, tag="2")]
                    UnixEpoch(HsmDateTimeUnixEpoch),
                }
            }
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
            pub enum ParamOneof {
                #[prost(message, tag="2")]
                Currency(HsmCurrency),
                #[prost(message, tag="3")]
                DateTime(HsmDateTime),
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct HistorySyncNotification {
        #[prost(bytes="vec", optional, tag="1")]
        pub file_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(uint64, optional, tag="2")]
        pub file_length: ::core::option::Option<u64>,
        #[prost(bytes="vec", optional, tag="3")]
        pub media_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="4")]
        pub file_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="5")]
        pub direct_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration="history_sync_notification::HistorySyncType", optional, tag="6")]
        pub sync_type: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag="7")]
        pub chunk_order: ::core::option::Option<u32>,
        #[prost(string, optional, tag="8")]
        pub original_message_id: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag="9")]
        pub progress: ::core::option::Option<u32>,
        #[prost(int64, optional, tag="10")]
        pub oldest_msg_in_chunk_timestamp_sec: ::core::option::Option<i64>,
        #[prost(bytes="vec", optional, tag="11")]
        pub initial_hist_bootstrap_inline_payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="12")]
        pub peer_data_request_session_id: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, tag="13")]
        pub full_history_sync_on_demand_request_metadata: ::core::option::Option<FullHistorySyncOnDemandRequestMetadata>,
        #[prost(string, optional, tag="14")]
        pub enc_handle: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `HistorySyncNotification`.
    pub mod history_sync_notification {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum HistorySyncType {
            InitialBootstrap = 0,
            InitialStatusV3 = 1,
            Full = 2,
            Recent = 3,
            PushName = 4,
            NonBlockingData = 5,
            OnDemand = 6,
            NoHistory = 7,
        }
        impl HistorySyncType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::InitialBootstrap => "INITIAL_BOOTSTRAP",
                    Self::InitialStatusV3 => "INITIAL_STATUS_V3",
                    Self::Full => "FULL",
                    Self::Recent => "RECENT",
                    Self::PushName => "PUSH_NAME",
                    Self::NonBlockingData => "NON_BLOCKING_DATA",
                    Self::OnDemand => "ON_DEMAND",
                    Self::NoHistory => "NO_HISTORY",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "INITIAL_BOOTSTRAP" => Some(Self::InitialBootstrap),
                    "INITIAL_STATUS_V3" => Some(Self::InitialStatusV3),
                    "FULL" => Some(Self::Full),
                    "RECENT" => Some(Self::Recent),
                    "PUSH_NAME" => Some(Self::PushName),
                    "NON_BLOCKING_DATA" => Some(Self::NonBlockingData),
                    "ON_DEMAND" => Some(Self::OnDemand),
                    "NO_HISTORY" => Some(Self::NoHistory),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImageMessage {
        #[prost(string, optional, tag="1")]
        pub url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub mimetype: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="3")]
        pub caption: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="4")]
        pub file_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(uint64, optional, tag="5")]
        pub file_length: ::core::option::Option<u64>,
        #[prost(uint32, optional, tag="6")]
        pub height: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="7")]
        pub width: ::core::option::Option<u32>,
        #[prost(bytes="vec", optional, tag="8")]
        pub media_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="9")]
        pub file_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(message, repeated, tag="10")]
        pub interactive_annotations: ::prost::alloc::vec::Vec<super::InteractiveAnnotation>,
        #[prost(string, optional, tag="11")]
        pub direct_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int64, optional, tag="12")]
        pub media_key_timestamp: ::core::option::Option<i64>,
        #[prost(bytes="vec", optional, tag="16")]
        pub jpeg_thumbnail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(message, optional, boxed, tag="17")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(bytes="vec", optional, tag="18")]
        pub first_scan_sidecar: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(uint32, optional, tag="19")]
        pub first_scan_length: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="20")]
        pub experiment_group_id: ::core::option::Option<u32>,
        #[prost(bytes="vec", optional, tag="21")]
        pub scans_sidecar: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(uint32, repeated, packed="false", tag="22")]
        pub scan_lengths: ::prost::alloc::vec::Vec<u32>,
        #[prost(bytes="vec", optional, tag="23")]
        pub mid_quality_file_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="24")]
        pub mid_quality_file_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bool, optional, tag="25")]
        pub view_once: ::core::option::Option<bool>,
        #[prost(string, optional, tag="26")]
        pub thumbnail_direct_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="27")]
        pub thumbnail_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="28")]
        pub thumbnail_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="29")]
        pub static_url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="30")]
        pub annotations: ::prost::alloc::vec::Vec<super::InteractiveAnnotation>,
        #[prost(enumeration="image_message::ImageSourceType", optional, tag="31")]
        pub image_source_type: ::core::option::Option<i32>,
        #[prost(string, optional, tag="32")]
        pub accessibility_label: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `ImageMessage`.
    pub mod image_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum ImageSourceType {
            UserImage = 0,
            AiGenerated = 1,
            AiModified = 2,
            RasterizedTextStatus = 3,
        }
        impl ImageSourceType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::UserImage => "USER_IMAGE",
                    Self::AiGenerated => "AI_GENERATED",
                    Self::AiModified => "AI_MODIFIED",
                    Self::RasterizedTextStatus => "RASTERIZED_TEXT_STATUS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "USER_IMAGE" => Some(Self::UserImage),
                    "AI_GENERATED" => Some(Self::AiGenerated),
                    "AI_MODIFIED" => Some(Self::AiModified),
                    "RASTERIZED_TEXT_STATUS" => Some(Self::RasterizedTextStatus),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct InitialSecurityNotificationSettingSync {
        #[prost(bool, optional, tag="1")]
        pub security_notification_enabled: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InteractiveMessage {
        #[prost(message, optional, boxed, tag="1")]
        pub header: ::core::option::Option<::prost::alloc::boxed::Box<interactive_message::Header>>,
        #[prost(message, optional, tag="2")]
        pub body: ::core::option::Option<interactive_message::Body>,
        #[prost(message, optional, tag="3")]
        pub footer: ::core::option::Option<interactive_message::Footer>,
        #[prost(message, optional, boxed, tag="15")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(message, optional, tag="16")]
        pub url_tracking_map: ::core::option::Option<super::UrlTrackingMap>,
        #[prost(oneof="interactive_message::InteractiveMessage", tags="4, 5, 6, 7")]
        pub interactive_message: ::core::option::Option<interactive_message::InteractiveMessage>,
    }
    /// Nested message and enum types in `InteractiveMessage`.
    pub mod interactive_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Body {
            #[prost(string, optional, tag="1")]
            pub text: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CarouselMessage {
            #[prost(message, repeated, tag="1")]
            pub cards: ::prost::alloc::vec::Vec<super::InteractiveMessage>,
            #[prost(int32, optional, tag="2")]
            pub message_version: ::core::option::Option<i32>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CollectionMessage {
            #[prost(string, optional, tag="1")]
            pub biz_jid: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="2")]
            pub id: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(int32, optional, tag="3")]
            pub message_version: ::core::option::Option<i32>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Footer {
            #[prost(string, optional, tag="1")]
            pub text: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Header {
            #[prost(string, optional, tag="1")]
            pub title: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="2")]
            pub subtitle: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(bool, optional, tag="5")]
            pub has_media_attachment: ::core::option::Option<bool>,
            #[prost(oneof="header::Media", tags="3, 4, 6, 7, 8, 9")]
            pub media: ::core::option::Option<header::Media>,
        }
        /// Nested message and enum types in `Header`.
        pub mod header {
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Media {
                #[prost(message, tag="3")]
                DocumentMessage(::prost::alloc::boxed::Box<super::super::DocumentMessage>),
                #[prost(message, tag="4")]
                ImageMessage(::prost::alloc::boxed::Box<super::super::ImageMessage>),
                #[prost(bytes, tag="6")]
                JpegThumbnail(::prost::alloc::vec::Vec<u8>),
                #[prost(message, tag="7")]
                VideoMessage(::prost::alloc::boxed::Box<super::super::VideoMessage>),
                #[prost(message, tag="8")]
                LocationMessage(::prost::alloc::boxed::Box<super::super::LocationMessage>),
                #[prost(message, tag="9")]
                ProductMessage(::prost::alloc::boxed::Box<super::super::ProductMessage>),
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct NativeFlowMessage {
            #[prost(message, repeated, tag="1")]
            pub buttons: ::prost::alloc::vec::Vec<native_flow_message::NativeFlowButton>,
            #[prost(string, optional, tag="2")]
            pub message_params_json: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(int32, optional, tag="3")]
            pub message_version: ::core::option::Option<i32>,
        }
        /// Nested message and enum types in `NativeFlowMessage`.
        pub mod native_flow_message {
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct NativeFlowButton {
                #[prost(string, optional, tag="1")]
                pub name: ::core::option::Option<::prost::alloc::string::String>,
                #[prost(string, optional, tag="2")]
                pub button_params_json: ::core::option::Option<::prost::alloc::string::String>,
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ShopMessage {
            #[prost(string, optional, tag="1")]
            pub id: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(enumeration="shop_message::Surface", optional, tag="2")]
            pub surface: ::core::option::Option<i32>,
            #[prost(int32, optional, tag="3")]
            pub message_version: ::core::option::Option<i32>,
        }
        /// Nested message and enum types in `ShopMessage`.
        pub mod shop_message {
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
            #[repr(i32)]
            pub enum Surface {
                UnknownSurface = 0,
                Fb = 1,
                Ig = 2,
                Wa = 3,
            }
            impl Surface {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::UnknownSurface => "UNKNOWN_SURFACE",
                        Self::Fb => "FB",
                        Self::Ig => "IG",
                        Self::Wa => "WA",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "UNKNOWN_SURFACE" => Some(Self::UnknownSurface),
                        "FB" => Some(Self::Fb),
                        "IG" => Some(Self::Ig),
                        "WA" => Some(Self::Wa),
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum InteractiveMessage {
            #[prost(message, tag="4")]
            ShopStorefrontMessage(ShopMessage),
            #[prost(message, tag="5")]
            CollectionMessage(CollectionMessage),
            #[prost(message, tag="6")]
            NativeFlowMessage(NativeFlowMessage),
            #[prost(message, tag="7")]
            CarouselMessage(CarouselMessage),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InteractiveResponseMessage {
        #[prost(message, optional, tag="1")]
        pub body: ::core::option::Option<interactive_response_message::Body>,
        #[prost(message, optional, boxed, tag="15")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(oneof="interactive_response_message::InteractiveResponseMessage", tags="2")]
        pub interactive_response_message: ::core::option::Option<interactive_response_message::InteractiveResponseMessage>,
    }
    /// Nested message and enum types in `InteractiveResponseMessage`.
    pub mod interactive_response_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Body {
            #[prost(string, optional, tag="1")]
            pub text: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(enumeration="body::Format", optional, tag="2")]
            pub format: ::core::option::Option<i32>,
        }
        /// Nested message and enum types in `Body`.
        pub mod body {
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
            #[repr(i32)]
            pub enum Format {
                Default = 0,
                Extensions1 = 1,
            }
            impl Format {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Default => "DEFAULT",
                        Self::Extensions1 => "EXTENSIONS_1",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "DEFAULT" => Some(Self::Default),
                        "EXTENSIONS_1" => Some(Self::Extensions1),
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct NativeFlowResponseMessage {
            #[prost(string, optional, tag="1")]
            pub name: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="2")]
            pub params_json: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(int32, optional, tag="3")]
            pub version: ::core::option::Option<i32>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum InteractiveResponseMessage {
            #[prost(message, tag="2")]
            NativeFlowResponseMessage(NativeFlowResponseMessage),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct InvoiceMessage {
        #[prost(string, optional, tag="1")]
        pub note: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub token: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration="invoice_message::AttachmentType", optional, tag="3")]
        pub attachment_type: ::core::option::Option<i32>,
        #[prost(string, optional, tag="4")]
        pub attachment_mimetype: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="5")]
        pub attachment_media_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(int64, optional, tag="6")]
        pub attachment_media_key_timestamp: ::core::option::Option<i64>,
        #[prost(bytes="vec", optional, tag="7")]
        pub attachment_file_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="8")]
        pub attachment_file_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="9")]
        pub attachment_direct_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="10")]
        pub attachment_jpeg_thumbnail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    /// Nested message and enum types in `InvoiceMessage`.
    pub mod invoice_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum AttachmentType {
            Image = 0,
            Pdf = 1,
        }
        impl AttachmentType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Image => "IMAGE",
                    Self::Pdf => "PDF",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "IMAGE" => Some(Self::Image),
                    "PDF" => Some(Self::Pdf),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct KeepInChatMessage {
        #[prost(message, optional, tag="1")]
        pub key: ::core::option::Option<super::MessageKey>,
        #[prost(enumeration="super::KeepType", optional, tag="2")]
        pub keep_type: ::core::option::Option<i32>,
        #[prost(int64, optional, tag="3")]
        pub timestamp_ms: ::core::option::Option<i64>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct LinkPreviewMetadata {
        #[prost(message, optional, tag="1")]
        pub payment_link_metadata: ::core::option::Option<PaymentLinkMetadata>,
        #[prost(message, optional, tag="2")]
        pub url_metadata: ::core::option::Option<UrlMetadata>,
        #[prost(uint32, optional, tag="3")]
        pub fb_experiment_id: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListMessage {
        #[prost(string, optional, tag="1")]
        pub title: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub description: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="3")]
        pub button_text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration="list_message::ListType", optional, tag="4")]
        pub list_type: ::core::option::Option<i32>,
        #[prost(message, repeated, tag="5")]
        pub sections: ::prost::alloc::vec::Vec<list_message::Section>,
        #[prost(message, optional, tag="6")]
        pub product_list_info: ::core::option::Option<list_message::ProductListInfo>,
        #[prost(string, optional, tag="7")]
        pub footer_text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, boxed, tag="8")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
    }
    /// Nested message and enum types in `ListMessage`.
    pub mod list_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Product {
            #[prost(string, optional, tag="1")]
            pub product_id: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ProductListHeaderImage {
            #[prost(string, optional, tag="1")]
            pub product_id: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(bytes="vec", optional, tag="2")]
            pub jpeg_thumbnail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ProductListInfo {
            #[prost(message, repeated, tag="1")]
            pub product_sections: ::prost::alloc::vec::Vec<ProductSection>,
            #[prost(message, optional, tag="2")]
            pub header_image: ::core::option::Option<ProductListHeaderImage>,
            #[prost(string, optional, tag="3")]
            pub business_owner_jid: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ProductSection {
            #[prost(string, optional, tag="1")]
            pub title: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(message, repeated, tag="2")]
            pub products: ::prost::alloc::vec::Vec<Product>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Row {
            #[prost(string, optional, tag="1")]
            pub title: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="2")]
            pub description: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="3")]
            pub row_id: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Section {
            #[prost(string, optional, tag="1")]
            pub title: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(message, repeated, tag="2")]
            pub rows: ::prost::alloc::vec::Vec<Row>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum ListType {
            Unknown = 0,
            SingleSelect = 1,
            ProductList = 2,
        }
        impl ListType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::SingleSelect => "SINGLE_SELECT",
                    Self::ProductList => "PRODUCT_LIST",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "SINGLE_SELECT" => Some(Self::SingleSelect),
                    "PRODUCT_LIST" => Some(Self::ProductList),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListResponseMessage {
        #[prost(string, optional, tag="1")]
        pub title: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration="list_response_message::ListType", optional, tag="2")]
        pub list_type: ::core::option::Option<i32>,
        #[prost(message, optional, tag="3")]
        pub single_select_reply: ::core::option::Option<list_response_message::SingleSelectReply>,
        #[prost(message, optional, boxed, tag="4")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(string, optional, tag="5")]
        pub description: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `ListResponseMessage`.
    pub mod list_response_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SingleSelectReply {
            #[prost(string, optional, tag="1")]
            pub selected_row_id: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum ListType {
            Unknown = 0,
            SingleSelect = 1,
        }
        impl ListType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::SingleSelect => "SINGLE_SELECT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "SINGLE_SELECT" => Some(Self::SingleSelect),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LiveLocationMessage {
        #[prost(double, optional, tag="1")]
        pub degrees_latitude: ::core::option::Option<f64>,
        #[prost(double, optional, tag="2")]
        pub degrees_longitude: ::core::option::Option<f64>,
        #[prost(uint32, optional, tag="3")]
        pub accuracy_in_meters: ::core::option::Option<u32>,
        #[prost(float, optional, tag="4")]
        pub speed_in_mps: ::core::option::Option<f32>,
        #[prost(uint32, optional, tag="5")]
        pub degrees_clockwise_from_magnetic_north: ::core::option::Option<u32>,
        #[prost(string, optional, tag="6")]
        pub caption: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int64, optional, tag="7")]
        pub sequence_number: ::core::option::Option<i64>,
        #[prost(uint32, optional, tag="8")]
        pub time_offset: ::core::option::Option<u32>,
        #[prost(bytes="vec", optional, tag="16")]
        pub jpeg_thumbnail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(message, optional, boxed, tag="17")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LocationMessage {
        #[prost(double, optional, tag="1")]
        pub degrees_latitude: ::core::option::Option<f64>,
        #[prost(double, optional, tag="2")]
        pub degrees_longitude: ::core::option::Option<f64>,
        #[prost(string, optional, tag="3")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="4")]
        pub address: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="5")]
        pub url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag="6")]
        pub is_live: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag="7")]
        pub accuracy_in_meters: ::core::option::Option<u32>,
        #[prost(float, optional, tag="8")]
        pub speed_in_mps: ::core::option::Option<f32>,
        #[prost(uint32, optional, tag="9")]
        pub degrees_clockwise_from_magnetic_north: ::core::option::Option<u32>,
        #[prost(string, optional, tag="11")]
        pub comment: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="16")]
        pub jpeg_thumbnail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(message, optional, boxed, tag="17")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct MmsThumbnailMetadata {
        #[prost(string, optional, tag="1")]
        pub thumbnail_direct_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="2")]
        pub thumbnail_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="3")]
        pub thumbnail_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="4")]
        pub media_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(int64, optional, tag="5")]
        pub media_key_timestamp: ::core::option::Option<i64>,
        #[prost(uint32, optional, tag="6")]
        pub thumbnail_height: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="7")]
        pub thumbnail_width: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MessageHistoryBundle {
        #[prost(string, optional, tag="1")]
        pub mimetype: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="2")]
        pub file_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="3")]
        pub media_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="4")]
        pub file_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="5")]
        pub direct_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int64, optional, tag="6")]
        pub media_key_timestamp: ::core::option::Option<i64>,
        #[prost(message, optional, boxed, tag="7")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(message, optional, tag="8")]
        pub message_history_metadata: ::core::option::Option<MessageHistoryMetadata>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct MessageHistoryMetadata {
        #[prost(string, repeated, tag="1")]
        pub history_receivers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(int64, optional, tag="2")]
        pub first_message_timestamp: ::core::option::Option<i64>,
        #[prost(int64, optional, tag="3")]
        pub message_count: ::core::option::Option<i64>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MessageHistoryNotice {
        #[prost(message, optional, boxed, tag="1")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(message, optional, tag="2")]
        pub message_history_metadata: ::core::option::Option<MessageHistoryMetadata>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NewsletterAdminInviteMessage {
        #[prost(string, optional, tag="1")]
        pub newsletter_jid: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub newsletter_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="3")]
        pub jpeg_thumbnail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="4")]
        pub caption: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int64, optional, tag="5")]
        pub invite_expiration: ::core::option::Option<i64>,
        #[prost(message, optional, boxed, tag="6")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OrderMessage {
        #[prost(string, optional, tag="1")]
        pub order_id: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="2")]
        pub thumbnail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(int32, optional, tag="3")]
        pub item_count: ::core::option::Option<i32>,
        #[prost(enumeration="order_message::OrderStatus", optional, tag="4")]
        pub status: ::core::option::Option<i32>,
        #[prost(enumeration="order_message::OrderSurface", optional, tag="5")]
        pub surface: ::core::option::Option<i32>,
        #[prost(string, optional, tag="6")]
        pub message: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="7")]
        pub order_title: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="8")]
        pub seller_jid: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="9")]
        pub token: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int64, optional, tag="10")]
        pub total_amount1000: ::core::option::Option<i64>,
        #[prost(string, optional, tag="11")]
        pub total_currency_code: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, boxed, tag="17")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(int32, optional, tag="12")]
        pub message_version: ::core::option::Option<i32>,
        #[prost(message, optional, tag="13")]
        pub order_request_message_id: ::core::option::Option<super::MessageKey>,
        #[prost(string, optional, tag="15")]
        pub catalog_type: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `OrderMessage`.
    pub mod order_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum OrderStatus {
            Inquiry = 1,
            Accepted = 2,
            Declined = 3,
        }
        impl OrderStatus {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Inquiry => "INQUIRY",
                    Self::Accepted => "ACCEPTED",
                    Self::Declined => "DECLINED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "INQUIRY" => Some(Self::Inquiry),
                    "ACCEPTED" => Some(Self::Accepted),
                    "DECLINED" => Some(Self::Declined),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum OrderSurface {
            Catalog = 1,
        }
        impl OrderSurface {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Catalog => "CATALOG",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CATALOG" => Some(Self::Catalog),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PaymentInviteMessage {
        #[prost(enumeration="payment_invite_message::ServiceType", optional, tag="1")]
        pub service_type: ::core::option::Option<i32>,
        #[prost(int64, optional, tag="2")]
        pub expiry_timestamp: ::core::option::Option<i64>,
    }
    /// Nested message and enum types in `PaymentInviteMessage`.
    pub mod payment_invite_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum ServiceType {
            Unknown = 0,
            Fbpay = 1,
            Novi = 2,
            Upi = 3,
        }
        impl ServiceType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::Fbpay => "FBPAY",
                    Self::Novi => "NOVI",
                    Self::Upi => "UPI",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "FBPAY" => Some(Self::Fbpay),
                    "NOVI" => Some(Self::Novi),
                    "UPI" => Some(Self::Upi),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PaymentLinkMetadata {
        #[prost(message, optional, tag="1")]
        pub button: ::core::option::Option<payment_link_metadata::PaymentLinkButton>,
        #[prost(message, optional, tag="2")]
        pub header: ::core::option::Option<payment_link_metadata::PaymentLinkHeader>,
    }
    /// Nested message and enum types in `PaymentLinkMetadata`.
    pub mod payment_link_metadata {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct PaymentLinkButton {
            #[prost(string, optional, tag="1")]
            pub display_text: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct PaymentLinkHeader {
            #[prost(enumeration="payment_link_header::PaymentLinkHeaderType", optional, tag="1")]
            pub header_type: ::core::option::Option<i32>,
        }
        /// Nested message and enum types in `PaymentLinkHeader`.
        pub mod payment_link_header {
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
            #[repr(i32)]
            pub enum PaymentLinkHeaderType {
                LinkPreview = 0,
                Order = 1,
            }
            impl PaymentLinkHeaderType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::LinkPreview => "LINK_PREVIEW",
                        Self::Order => "ORDER",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "LINK_PREVIEW" => Some(Self::LinkPreview),
                        "ORDER" => Some(Self::Order),
                        _ => None,
                    }
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PeerDataOperationRequestMessage {
        #[prost(enumeration="PeerDataOperationRequestType", optional, tag="1")]
        pub peer_data_operation_request_type: ::core::option::Option<i32>,
        #[prost(message, repeated, tag="2")]
        pub request_sticker_reupload: ::prost::alloc::vec::Vec<peer_data_operation_request_message::RequestStickerReupload>,
        #[prost(message, repeated, tag="3")]
        pub request_url_preview: ::prost::alloc::vec::Vec<peer_data_operation_request_message::RequestUrlPreview>,
        #[prost(message, optional, tag="4")]
        pub history_sync_on_demand_request: ::core::option::Option<peer_data_operation_request_message::HistorySyncOnDemandRequest>,
        #[prost(message, repeated, tag="5")]
        pub placeholder_message_resend_request: ::prost::alloc::vec::Vec<peer_data_operation_request_message::PlaceholderMessageResendRequest>,
        #[prost(message, optional, tag="6")]
        pub full_history_sync_on_demand_request: ::core::option::Option<peer_data_operation_request_message::FullHistorySyncOnDemandRequest>,
        #[prost(message, optional, tag="7")]
        pub syncd_collection_fatal_recovery_request: ::core::option::Option<peer_data_operation_request_message::SyncDCollectionFatalRecoveryRequest>,
    }
    /// Nested message and enum types in `PeerDataOperationRequestMessage`.
    pub mod peer_data_operation_request_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct FullHistorySyncOnDemandRequest {
            #[prost(message, optional, tag="1")]
            pub request_metadata: ::core::option::Option<super::FullHistorySyncOnDemandRequestMetadata>,
            #[prost(message, optional, tag="2")]
            pub history_sync_config: ::core::option::Option<super::super::device_props::HistorySyncConfig>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct HistorySyncOnDemandRequest {
            #[prost(string, optional, tag="1")]
            pub chat_jid: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="2")]
            pub oldest_msg_id: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(bool, optional, tag="3")]
            pub oldest_msg_from_me: ::core::option::Option<bool>,
            #[prost(int32, optional, tag="4")]
            pub on_demand_msg_count: ::core::option::Option<i32>,
            #[prost(int64, optional, tag="5")]
            pub oldest_msg_timestamp_ms: ::core::option::Option<i64>,
            #[prost(string, optional, tag="6")]
            pub account_lid: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct PlaceholderMessageResendRequest {
            #[prost(message, optional, tag="1")]
            pub message_key: ::core::option::Option<super::super::MessageKey>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RequestStickerReupload {
            #[prost(string, optional, tag="1")]
            pub file_sha256: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RequestUrlPreview {
            #[prost(string, optional, tag="1")]
            pub url: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(bool, optional, tag="2")]
            pub include_hq_thumbnail: ::core::option::Option<bool>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SyncDCollectionFatalRecoveryRequest {
            #[prost(string, optional, tag="1")]
            pub collection_name: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(int64, optional, tag="2")]
            pub timestamp: ::core::option::Option<i64>,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PeerDataOperationRequestResponseMessage {
        #[prost(enumeration="PeerDataOperationRequestType", optional, tag="1")]
        pub peer_data_operation_request_type: ::core::option::Option<i32>,
        #[prost(string, optional, tag="2")]
        pub stanza_id: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="3")]
        pub peer_data_operation_result: ::prost::alloc::vec::Vec<peer_data_operation_request_response_message::PeerDataOperationResult>,
    }
    /// Nested message and enum types in `PeerDataOperationRequestResponseMessage`.
    pub mod peer_data_operation_request_response_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PeerDataOperationResult {
            #[prost(enumeration="super::super::media_retry_notification::ResultType", optional, tag="1")]
            pub media_upload_result: ::core::option::Option<i32>,
            #[prost(message, optional, tag="2")]
            pub sticker_message: ::core::option::Option<super::StickerMessage>,
            #[prost(message, optional, tag="3")]
            pub link_preview_response: ::core::option::Option<peer_data_operation_result::LinkPreviewResponse>,
            #[prost(message, optional, tag="4")]
            pub placeholder_message_resend_response: ::core::option::Option<peer_data_operation_result::PlaceholderMessageResendResponse>,
            #[prost(message, optional, tag="5")]
            pub waffle_nonce_fetch_request_response: ::core::option::Option<peer_data_operation_result::WaffleNonceFetchResponse>,
            #[prost(message, optional, tag="6")]
            pub full_history_sync_on_demand_request_response: ::core::option::Option<peer_data_operation_result::FullHistorySyncOnDemandRequestResponse>,
            #[prost(message, optional, tag="7")]
            pub companion_meta_nonce_fetch_request_response: ::core::option::Option<peer_data_operation_result::CompanionMetaNonceFetchResponse>,
            #[prost(message, optional, tag="8")]
            pub syncd_snapshot_fatal_recovery_response: ::core::option::Option<peer_data_operation_result::SyncDSnapshotFatalRecoveryResponse>,
        }
        /// Nested message and enum types in `PeerDataOperationResult`.
        pub mod peer_data_operation_result {
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct CompanionMetaNonceFetchResponse {
                #[prost(string, optional, tag="1")]
                pub nonce: ::core::option::Option<::prost::alloc::string::String>,
            }
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct FullHistorySyncOnDemandRequestResponse {
                #[prost(message, optional, tag="1")]
                pub request_metadata: ::core::option::Option<super::super::FullHistorySyncOnDemandRequestMetadata>,
                #[prost(enumeration="FullHistorySyncOnDemandResponseCode", optional, tag="2")]
                pub response_code: ::core::option::Option<i32>,
            }
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct LinkPreviewResponse {
                #[prost(string, optional, tag="1")]
                pub url: ::core::option::Option<::prost::alloc::string::String>,
                #[prost(string, optional, tag="2")]
                pub title: ::core::option::Option<::prost::alloc::string::String>,
                #[prost(string, optional, tag="3")]
                pub description: ::core::option::Option<::prost::alloc::string::String>,
                #[prost(bytes="vec", optional, tag="4")]
                pub thumb_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                #[prost(string, optional, tag="6")]
                pub match_text: ::core::option::Option<::prost::alloc::string::String>,
                #[prost(string, optional, tag="7")]
                pub preview_type: ::core::option::Option<::prost::alloc::string::String>,
                #[prost(message, optional, tag="8")]
                pub hq_thumbnail: ::core::option::Option<link_preview_response::LinkPreviewHighQualityThumbnail>,
            }
            /// Nested message and enum types in `LinkPreviewResponse`.
            pub mod link_preview_response {
                #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct LinkPreviewHighQualityThumbnail {
                    #[prost(string, optional, tag="1")]
                    pub direct_path: ::core::option::Option<::prost::alloc::string::String>,
                    #[prost(string, optional, tag="2")]
                    pub thumb_hash: ::core::option::Option<::prost::alloc::string::String>,
                    #[prost(string, optional, tag="3")]
                    pub enc_thumb_hash: ::core::option::Option<::prost::alloc::string::String>,
                    #[prost(bytes="vec", optional, tag="4")]
                    pub media_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                    #[prost(int64, optional, tag="5")]
                    pub media_key_timestamp_ms: ::core::option::Option<i64>,
                    #[prost(int32, optional, tag="6")]
                    pub thumb_width: ::core::option::Option<i32>,
                    #[prost(int32, optional, tag="7")]
                    pub thumb_height: ::core::option::Option<i32>,
                }
            }
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct PlaceholderMessageResendResponse {
                #[prost(bytes="vec", optional, tag="1")]
                pub web_message_info_bytes: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
            }
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct SyncDSnapshotFatalRecoveryResponse {
                #[prost(bytes="vec", optional, tag="1")]
                pub collection_snapshot: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                #[prost(bool, optional, tag="2")]
                pub is_compressed: ::core::option::Option<bool>,
            }
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct WaffleNonceFetchResponse {
                #[prost(string, optional, tag="1")]
                pub nonce: ::core::option::Option<::prost::alloc::string::String>,
                #[prost(string, optional, tag="2")]
                pub wa_ent_fbid: ::core::option::Option<::prost::alloc::string::String>,
            }
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
            #[repr(i32)]
            pub enum FullHistorySyncOnDemandResponseCode {
                RequestSuccess = 0,
                RequestTimeExpired = 1,
                DeclinedSharingHistory = 2,
                GenericError = 3,
                ErrorRequestOnNonSmbPrimary = 4,
                ErrorHostedDeviceNotConnected = 5,
                ErrorHostedDeviceLoginTimeNotSet = 6,
            }
            impl FullHistorySyncOnDemandResponseCode {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::RequestSuccess => "REQUEST_SUCCESS",
                        Self::RequestTimeExpired => "REQUEST_TIME_EXPIRED",
                        Self::DeclinedSharingHistory => "DECLINED_SHARING_HISTORY",
                        Self::GenericError => "GENERIC_ERROR",
                        Self::ErrorRequestOnNonSmbPrimary => "ERROR_REQUEST_ON_NON_SMB_PRIMARY",
                        Self::ErrorHostedDeviceNotConnected => "ERROR_HOSTED_DEVICE_NOT_CONNECTED",
                        Self::ErrorHostedDeviceLoginTimeNotSet => "ERROR_HOSTED_DEVICE_LOGIN_TIME_NOT_SET",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "REQUEST_SUCCESS" => Some(Self::RequestSuccess),
                        "REQUEST_TIME_EXPIRED" => Some(Self::RequestTimeExpired),
                        "DECLINED_SHARING_HISTORY" => Some(Self::DeclinedSharingHistory),
                        "GENERIC_ERROR" => Some(Self::GenericError),
                        "ERROR_REQUEST_ON_NON_SMB_PRIMARY" => Some(Self::ErrorRequestOnNonSmbPrimary),
                        "ERROR_HOSTED_DEVICE_NOT_CONNECTED" => Some(Self::ErrorHostedDeviceNotConnected),
                        "ERROR_HOSTED_DEVICE_LOGIN_TIME_NOT_SET" => Some(Self::ErrorHostedDeviceLoginTimeNotSet),
                        _ => None,
                    }
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PinInChatMessage {
        #[prost(message, optional, tag="1")]
        pub key: ::core::option::Option<super::MessageKey>,
        #[prost(enumeration="pin_in_chat_message::Type", optional, tag="2")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(int64, optional, tag="3")]
        pub sender_timestamp_ms: ::core::option::Option<i64>,
    }
    /// Nested message and enum types in `PinInChatMessage`.
    pub mod pin_in_chat_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum Type {
            UnknownType = 0,
            PinForAll = 1,
            UnpinForAll = 2,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::UnknownType => "UNKNOWN_TYPE",
                    Self::PinForAll => "PIN_FOR_ALL",
                    Self::UnpinForAll => "UNPIN_FOR_ALL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN_TYPE" => Some(Self::UnknownType),
                    "PIN_FOR_ALL" => Some(Self::PinForAll),
                    "UNPIN_FOR_ALL" => Some(Self::UnpinForAll),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PlaceholderMessage {
        #[prost(enumeration="placeholder_message::PlaceholderType", optional, tag="1")]
        pub r#type: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `PlaceholderMessage`.
    pub mod placeholder_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum PlaceholderType {
            MaskLinkedDevices = 0,
        }
        impl PlaceholderType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::MaskLinkedDevices => "MASK_LINKED_DEVICES",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MASK_LINKED_DEVICES" => Some(Self::MaskLinkedDevices),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PollCreationMessage {
        #[prost(bytes="vec", optional, tag="1")]
        pub enc_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="3")]
        pub options: ::prost::alloc::vec::Vec<poll_creation_message::Option>,
        #[prost(uint32, optional, tag="4")]
        pub selectable_options_count: ::core::option::Option<u32>,
        #[prost(message, optional, boxed, tag="5")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(enumeration="PollContentType", optional, tag="6")]
        pub poll_content_type: ::core::option::Option<i32>,
        #[prost(enumeration="poll_creation_message::PollType", optional, tag="7")]
        pub poll_type: ::core::option::Option<i32>,
        #[prost(message, optional, tag="8")]
        pub correct_answer: ::core::option::Option<poll_creation_message::Option>,
    }
    /// Nested message and enum types in `PollCreationMessage`.
    pub mod poll_creation_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Option {
            #[prost(string, optional, tag="1")]
            pub option_name: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="2")]
            pub option_hash: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum PollType {
            Poll = 0,
            Quiz = 1,
        }
        impl PollType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Poll => "POLL",
                    Self::Quiz => "QUIZ",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "POLL" => Some(Self::Poll),
                    "QUIZ" => Some(Self::Quiz),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PollEncValue {
        #[prost(bytes="vec", optional, tag="1")]
        pub enc_payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="2")]
        pub enc_iv: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PollResultSnapshotMessage {
        #[prost(string, optional, tag="1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="2")]
        pub poll_votes: ::prost::alloc::vec::Vec<poll_result_snapshot_message::PollVote>,
        #[prost(message, optional, boxed, tag="3")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
    }
    /// Nested message and enum types in `PollResultSnapshotMessage`.
    pub mod poll_result_snapshot_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct PollVote {
            #[prost(string, optional, tag="1")]
            pub option_name: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(int64, optional, tag="2")]
            pub option_vote_count: ::core::option::Option<i64>,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PollUpdateMessage {
        #[prost(message, optional, tag="1")]
        pub poll_creation_message_key: ::core::option::Option<super::MessageKey>,
        #[prost(message, optional, tag="2")]
        pub vote: ::core::option::Option<PollEncValue>,
        #[prost(message, optional, tag="3")]
        pub metadata: ::core::option::Option<PollUpdateMessageMetadata>,
        #[prost(int64, optional, tag="4")]
        pub sender_timestamp_ms: ::core::option::Option<i64>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PollUpdateMessageMetadata {
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PollVoteMessage {
        #[prost(bytes="vec", repeated, tag="1")]
        pub selected_options: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProductMessage {
        #[prost(message, optional, boxed, tag="1")]
        pub product: ::core::option::Option<::prost::alloc::boxed::Box<product_message::ProductSnapshot>>,
        #[prost(string, optional, tag="2")]
        pub business_owner_jid: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, boxed, tag="4")]
        pub catalog: ::core::option::Option<::prost::alloc::boxed::Box<product_message::CatalogSnapshot>>,
        #[prost(string, optional, tag="5")]
        pub body: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="6")]
        pub footer: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, boxed, tag="17")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
    }
    /// Nested message and enum types in `ProductMessage`.
    pub mod product_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CatalogSnapshot {
            #[prost(message, optional, boxed, tag="1")]
            pub catalog_image: ::core::option::Option<::prost::alloc::boxed::Box<super::ImageMessage>>,
            #[prost(string, optional, tag="2")]
            pub title: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="3")]
            pub description: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ProductSnapshot {
            #[prost(message, optional, boxed, tag="1")]
            pub product_image: ::core::option::Option<::prost::alloc::boxed::Box<super::ImageMessage>>,
            #[prost(string, optional, tag="2")]
            pub product_id: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="3")]
            pub title: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="4")]
            pub description: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="5")]
            pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(int64, optional, tag="6")]
            pub price_amount1000: ::core::option::Option<i64>,
            #[prost(string, optional, tag="7")]
            pub retailer_id: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="8")]
            pub url: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(uint32, optional, tag="9")]
            pub product_image_count: ::core::option::Option<u32>,
            #[prost(string, optional, tag="11")]
            pub first_image_id: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(int64, optional, tag="12")]
            pub sale_price_amount1000: ::core::option::Option<i64>,
            #[prost(string, optional, tag="13")]
            pub signed_url: ::core::option::Option<::prost::alloc::string::String>,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProtocolMessage {
        #[prost(message, optional, tag="1")]
        pub key: ::core::option::Option<super::MessageKey>,
        #[prost(enumeration="protocol_message::Type", optional, tag="2")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag="4")]
        pub ephemeral_expiration: ::core::option::Option<u32>,
        #[prost(int64, optional, tag="5")]
        pub ephemeral_setting_timestamp: ::core::option::Option<i64>,
        #[prost(message, optional, tag="6")]
        pub history_sync_notification: ::core::option::Option<HistorySyncNotification>,
        #[prost(message, optional, tag="7")]
        pub app_state_sync_key_share: ::core::option::Option<AppStateSyncKeyShare>,
        #[prost(message, optional, tag="8")]
        pub app_state_sync_key_request: ::core::option::Option<AppStateSyncKeyRequest>,
        #[prost(message, optional, tag="9")]
        pub initial_security_notification_setting_sync: ::core::option::Option<InitialSecurityNotificationSettingSync>,
        #[prost(message, optional, tag="10")]
        pub app_state_fatal_exception_notification: ::core::option::Option<AppStateFatalExceptionNotification>,
        #[prost(message, optional, tag="11")]
        pub disappearing_mode: ::core::option::Option<super::DisappearingMode>,
        #[prost(message, optional, boxed, tag="14")]
        pub edited_message: ::core::option::Option<::prost::alloc::boxed::Box<super::Message>>,
        #[prost(int64, optional, tag="15")]
        pub timestamp_ms: ::core::option::Option<i64>,
        #[prost(message, optional, tag="16")]
        pub peer_data_operation_request_message: ::core::option::Option<PeerDataOperationRequestMessage>,
        #[prost(message, optional, tag="17")]
        pub peer_data_operation_request_response_message: ::core::option::Option<PeerDataOperationRequestResponseMessage>,
        #[prost(message, optional, tag="18")]
        pub bot_feedback_message: ::core::option::Option<BotFeedbackMessage>,
        #[prost(string, optional, tag="19")]
        pub invoker_jid: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, tag="20")]
        pub request_welcome_message_metadata: ::core::option::Option<RequestWelcomeMessageMetadata>,
        #[prost(message, optional, tag="21")]
        pub media_notify_message: ::core::option::Option<super::MediaNotifyMessage>,
        #[prost(message, optional, tag="22")]
        pub cloud_api_thread_control_notification: ::core::option::Option<CloudApiThreadControlNotification>,
        #[prost(message, optional, tag="23")]
        pub lid_migration_mapping_sync_message: ::core::option::Option<super::LidMigrationMappingSyncMessage>,
        #[prost(message, optional, tag="24")]
        pub limit_sharing: ::core::option::Option<super::LimitSharing>,
        #[prost(bytes="vec", optional, tag="25")]
        pub ai_psi_metadata: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(message, optional, boxed, tag="26")]
        pub ai_query_fanout: ::core::option::Option<::prost::alloc::boxed::Box<super::AiQueryFanout>>,
        #[prost(message, optional, tag="27")]
        pub member_label: ::core::option::Option<super::MemberLabel>,
    }
    /// Nested message and enum types in `ProtocolMessage`.
    pub mod protocol_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum Type {
            Revoke = 0,
            EphemeralSetting = 3,
            EphemeralSyncResponse = 4,
            HistorySyncNotification = 5,
            AppStateSyncKeyShare = 6,
            AppStateSyncKeyRequest = 7,
            MsgFanoutBackfillRequest = 8,
            InitialSecurityNotificationSettingSync = 9,
            AppStateFatalExceptionNotification = 10,
            SharePhoneNumber = 11,
            MessageEdit = 14,
            PeerDataOperationRequestMessage = 16,
            PeerDataOperationRequestResponseMessage = 17,
            RequestWelcomeMessage = 18,
            BotFeedbackMessage = 19,
            MediaNotifyMessage = 20,
            CloudApiThreadControlNotification = 21,
            LidMigrationMappingSync = 22,
            ReminderMessage = 23,
            BotMemuOnboardingMessage = 24,
            StatusMentionMessage = 25,
            StopGenerationMessage = 26,
            LimitSharing = 27,
            AiPsiMetadata = 28,
            AiQueryFanout = 29,
            GroupMemberLabelChange = 30,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Revoke => "REVOKE",
                    Self::EphemeralSetting => "EPHEMERAL_SETTING",
                    Self::EphemeralSyncResponse => "EPHEMERAL_SYNC_RESPONSE",
                    Self::HistorySyncNotification => "HISTORY_SYNC_NOTIFICATION",
                    Self::AppStateSyncKeyShare => "APP_STATE_SYNC_KEY_SHARE",
                    Self::AppStateSyncKeyRequest => "APP_STATE_SYNC_KEY_REQUEST",
                    Self::MsgFanoutBackfillRequest => "MSG_FANOUT_BACKFILL_REQUEST",
                    Self::InitialSecurityNotificationSettingSync => "INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC",
                    Self::AppStateFatalExceptionNotification => "APP_STATE_FATAL_EXCEPTION_NOTIFICATION",
                    Self::SharePhoneNumber => "SHARE_PHONE_NUMBER",
                    Self::MessageEdit => "MESSAGE_EDIT",
                    Self::PeerDataOperationRequestMessage => "PEER_DATA_OPERATION_REQUEST_MESSAGE",
                    Self::PeerDataOperationRequestResponseMessage => "PEER_DATA_OPERATION_REQUEST_RESPONSE_MESSAGE",
                    Self::RequestWelcomeMessage => "REQUEST_WELCOME_MESSAGE",
                    Self::BotFeedbackMessage => "BOT_FEEDBACK_MESSAGE",
                    Self::MediaNotifyMessage => "MEDIA_NOTIFY_MESSAGE",
                    Self::CloudApiThreadControlNotification => "CLOUD_API_THREAD_CONTROL_NOTIFICATION",
                    Self::LidMigrationMappingSync => "LID_MIGRATION_MAPPING_SYNC",
                    Self::ReminderMessage => "REMINDER_MESSAGE",
                    Self::BotMemuOnboardingMessage => "BOT_MEMU_ONBOARDING_MESSAGE",
                    Self::StatusMentionMessage => "STATUS_MENTION_MESSAGE",
                    Self::StopGenerationMessage => "STOP_GENERATION_MESSAGE",
                    Self::LimitSharing => "LIMIT_SHARING",
                    Self::AiPsiMetadata => "AI_PSI_METADATA",
                    Self::AiQueryFanout => "AI_QUERY_FANOUT",
                    Self::GroupMemberLabelChange => "GROUP_MEMBER_LABEL_CHANGE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "REVOKE" => Some(Self::Revoke),
                    "EPHEMERAL_SETTING" => Some(Self::EphemeralSetting),
                    "EPHEMERAL_SYNC_RESPONSE" => Some(Self::EphemeralSyncResponse),
                    "HISTORY_SYNC_NOTIFICATION" => Some(Self::HistorySyncNotification),
                    "APP_STATE_SYNC_KEY_SHARE" => Some(Self::AppStateSyncKeyShare),
                    "APP_STATE_SYNC_KEY_REQUEST" => Some(Self::AppStateSyncKeyRequest),
                    "MSG_FANOUT_BACKFILL_REQUEST" => Some(Self::MsgFanoutBackfillRequest),
                    "INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC" => Some(Self::InitialSecurityNotificationSettingSync),
                    "APP_STATE_FATAL_EXCEPTION_NOTIFICATION" => Some(Self::AppStateFatalExceptionNotification),
                    "SHARE_PHONE_NUMBER" => Some(Self::SharePhoneNumber),
                    "MESSAGE_EDIT" => Some(Self::MessageEdit),
                    "PEER_DATA_OPERATION_REQUEST_MESSAGE" => Some(Self::PeerDataOperationRequestMessage),
                    "PEER_DATA_OPERATION_REQUEST_RESPONSE_MESSAGE" => Some(Self::PeerDataOperationRequestResponseMessage),
                    "REQUEST_WELCOME_MESSAGE" => Some(Self::RequestWelcomeMessage),
                    "BOT_FEEDBACK_MESSAGE" => Some(Self::BotFeedbackMessage),
                    "MEDIA_NOTIFY_MESSAGE" => Some(Self::MediaNotifyMessage),
                    "CLOUD_API_THREAD_CONTROL_NOTIFICATION" => Some(Self::CloudApiThreadControlNotification),
                    "LID_MIGRATION_MAPPING_SYNC" => Some(Self::LidMigrationMappingSync),
                    "REMINDER_MESSAGE" => Some(Self::ReminderMessage),
                    "BOT_MEMU_ONBOARDING_MESSAGE" => Some(Self::BotMemuOnboardingMessage),
                    "STATUS_MENTION_MESSAGE" => Some(Self::StatusMentionMessage),
                    "STOP_GENERATION_MESSAGE" => Some(Self::StopGenerationMessage),
                    "LIMIT_SHARING" => Some(Self::LimitSharing),
                    "AI_PSI_METADATA" => Some(Self::AiPsiMetadata),
                    "AI_QUERY_FANOUT" => Some(Self::AiQueryFanout),
                    "GROUP_MEMBER_LABEL_CHANGE" => Some(Self::GroupMemberLabelChange),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ReactionMessage {
        #[prost(message, optional, tag="1")]
        pub key: ::core::option::Option<super::MessageKey>,
        #[prost(string, optional, tag="2")]
        pub text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="3")]
        pub grouping_key: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int64, optional, tag="4")]
        pub sender_timestamp_ms: ::core::option::Option<i64>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RequestPaymentMessage {
        #[prost(message, optional, boxed, tag="4")]
        pub note_message: ::core::option::Option<::prost::alloc::boxed::Box<super::Message>>,
        #[prost(string, optional, tag="1")]
        pub currency_code_iso4217: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint64, optional, tag="2")]
        pub amount1000: ::core::option::Option<u64>,
        #[prost(string, optional, tag="3")]
        pub request_from: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int64, optional, tag="5")]
        pub expiry_timestamp: ::core::option::Option<i64>,
        #[prost(message, optional, tag="6")]
        pub amount: ::core::option::Option<super::Money>,
        #[prost(message, optional, tag="7")]
        pub background: ::core::option::Option<super::PaymentBackground>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RequestPhoneNumberMessage {
        #[prost(message, optional, boxed, tag="1")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct RequestWelcomeMessageMetadata {
        #[prost(enumeration="request_welcome_message_metadata::LocalChatState", optional, tag="1")]
        pub local_chat_state: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `RequestWelcomeMessageMetadata`.
    pub mod request_welcome_message_metadata {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum LocalChatState {
            Empty = 0,
            NonEmpty = 1,
        }
        impl LocalChatState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Empty => "EMPTY",
                    Self::NonEmpty => "NON_EMPTY",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "EMPTY" => Some(Self::Empty),
                    "NON_EMPTY" => Some(Self::NonEmpty),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ScheduledCallCreationMessage {
        #[prost(int64, optional, tag="1")]
        pub scheduled_timestamp_ms: ::core::option::Option<i64>,
        #[prost(enumeration="scheduled_call_creation_message::CallType", optional, tag="2")]
        pub call_type: ::core::option::Option<i32>,
        #[prost(string, optional, tag="3")]
        pub title: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `ScheduledCallCreationMessage`.
    pub mod scheduled_call_creation_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum CallType {
            Unknown = 0,
            Voice = 1,
            Video = 2,
        }
        impl CallType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::Voice => "VOICE",
                    Self::Video => "VIDEO",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "VOICE" => Some(Self::Voice),
                    "VIDEO" => Some(Self::Video),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ScheduledCallEditMessage {
        #[prost(message, optional, tag="1")]
        pub key: ::core::option::Option<super::MessageKey>,
        #[prost(enumeration="scheduled_call_edit_message::EditType", optional, tag="2")]
        pub edit_type: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `ScheduledCallEditMessage`.
    pub mod scheduled_call_edit_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum EditType {
            Unknown = 0,
            Cancel = 1,
        }
        impl EditType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::Cancel => "CANCEL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "CANCEL" => Some(Self::Cancel),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SecretEncryptedMessage {
        #[prost(message, optional, tag="1")]
        pub target_message_key: ::core::option::Option<super::MessageKey>,
        #[prost(bytes="vec", optional, tag="2")]
        pub enc_payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="3")]
        pub enc_iv: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(enumeration="secret_encrypted_message::SecretEncType", optional, tag="4")]
        pub secret_enc_type: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `SecretEncryptedMessage`.
    pub mod secret_encrypted_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum SecretEncType {
            Unknown = 0,
            EventEdit = 1,
            MessageEdit = 2,
        }
        impl SecretEncType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::EventEdit => "EVENT_EDIT",
                    Self::MessageEdit => "MESSAGE_EDIT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "EVENT_EDIT" => Some(Self::EventEdit),
                    "MESSAGE_EDIT" => Some(Self::MessageEdit),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SendPaymentMessage {
        #[prost(message, optional, boxed, tag="2")]
        pub note_message: ::core::option::Option<::prost::alloc::boxed::Box<super::Message>>,
        #[prost(message, optional, tag="3")]
        pub request_message_key: ::core::option::Option<super::MessageKey>,
        #[prost(message, optional, tag="4")]
        pub background: ::core::option::Option<super::PaymentBackground>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SenderKeyDistributionMessage {
        #[prost(string, optional, tag="1")]
        pub group_id: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="2")]
        pub axolotl_sender_key_distribution_message: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct StatusNotificationMessage {
        #[prost(message, optional, tag="1")]
        pub response_message_key: ::core::option::Option<super::MessageKey>,
        #[prost(message, optional, tag="2")]
        pub original_message_key: ::core::option::Option<super::MessageKey>,
        #[prost(enumeration="status_notification_message::StatusNotificationType", optional, tag="3")]
        pub r#type: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `StatusNotificationMessage`.
    pub mod status_notification_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum StatusNotificationType {
            Unknown = 0,
            StatusAddYours = 1,
            StatusReshare = 2,
        }
        impl StatusNotificationType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::StatusAddYours => "STATUS_ADD_YOURS",
                    Self::StatusReshare => "STATUS_RESHARE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "STATUS_ADD_YOURS" => Some(Self::StatusAddYours),
                    "STATUS_RESHARE" => Some(Self::StatusReshare),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StickerMessage {
        #[prost(string, optional, tag="1")]
        pub url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="2")]
        pub file_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="3")]
        pub file_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="4")]
        pub media_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="5")]
        pub mimetype: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag="6")]
        pub height: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="7")]
        pub width: ::core::option::Option<u32>,
        #[prost(string, optional, tag="8")]
        pub direct_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint64, optional, tag="9")]
        pub file_length: ::core::option::Option<u64>,
        #[prost(int64, optional, tag="10")]
        pub media_key_timestamp: ::core::option::Option<i64>,
        #[prost(uint32, optional, tag="11")]
        pub first_frame_length: ::core::option::Option<u32>,
        #[prost(bytes="vec", optional, tag="12")]
        pub first_frame_sidecar: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bool, optional, tag="13")]
        pub is_animated: ::core::option::Option<bool>,
        #[prost(bytes="vec", optional, tag="16")]
        pub png_thumbnail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(message, optional, boxed, tag="17")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(int64, optional, tag="18")]
        pub sticker_sent_ts: ::core::option::Option<i64>,
        #[prost(bool, optional, tag="19")]
        pub is_avatar: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="20")]
        pub is_ai_sticker: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="21")]
        pub is_lottie: ::core::option::Option<bool>,
        #[prost(string, optional, tag="22")]
        pub accessibility_label: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StickerPackMessage {
        #[prost(string, optional, tag="1")]
        pub sticker_pack_id: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="3")]
        pub publisher: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="4")]
        pub stickers: ::prost::alloc::vec::Vec<sticker_pack_message::Sticker>,
        #[prost(uint64, optional, tag="5")]
        pub file_length: ::core::option::Option<u64>,
        #[prost(bytes="vec", optional, tag="6")]
        pub file_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="7")]
        pub file_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="8")]
        pub media_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="9")]
        pub direct_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="10")]
        pub caption: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, boxed, tag="11")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(string, optional, tag="12")]
        pub pack_description: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int64, optional, tag="13")]
        pub media_key_timestamp: ::core::option::Option<i64>,
        #[prost(string, optional, tag="14")]
        pub tray_icon_file_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="15")]
        pub thumbnail_direct_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="16")]
        pub thumbnail_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="17")]
        pub thumbnail_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(uint32, optional, tag="18")]
        pub thumbnail_height: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="19")]
        pub thumbnail_width: ::core::option::Option<u32>,
        #[prost(string, optional, tag="20")]
        pub image_data_hash: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint64, optional, tag="21")]
        pub sticker_pack_size: ::core::option::Option<u64>,
        #[prost(enumeration="sticker_pack_message::StickerPackOrigin", optional, tag="22")]
        pub sticker_pack_origin: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `StickerPackMessage`.
    pub mod sticker_pack_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Sticker {
            #[prost(string, optional, tag="1")]
            pub file_name: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(bool, optional, tag="2")]
            pub is_animated: ::core::option::Option<bool>,
            #[prost(string, repeated, tag="3")]
            pub emojis: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(string, optional, tag="4")]
            pub accessibility_label: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(bool, optional, tag="5")]
            pub is_lottie: ::core::option::Option<bool>,
            #[prost(string, optional, tag="6")]
            pub mimetype: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum StickerPackOrigin {
            FirstParty = 0,
            ThirdParty = 1,
            UserCreated = 2,
        }
        impl StickerPackOrigin {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::FirstParty => "FIRST_PARTY",
                    Self::ThirdParty => "THIRD_PARTY",
                    Self::UserCreated => "USER_CREATED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FIRST_PARTY" => Some(Self::FirstParty),
                    "THIRD_PARTY" => Some(Self::ThirdParty),
                    "USER_CREATED" => Some(Self::UserCreated),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct StickerSyncRmrMessage {
        #[prost(string, repeated, tag="1")]
        pub filehash: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub rmr_source: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int64, optional, tag="3")]
        pub request_timestamp: ::core::option::Option<i64>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TemplateButtonReplyMessage {
        #[prost(string, optional, tag="1")]
        pub selected_id: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub selected_display_text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, boxed, tag="3")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(uint32, optional, tag="4")]
        pub selected_index: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="5")]
        pub selected_carousel_card_index: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TemplateMessage {
        #[prost(message, optional, boxed, tag="3")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(message, optional, boxed, tag="4")]
        pub hydrated_template: ::core::option::Option<::prost::alloc::boxed::Box<template_message::HydratedFourRowTemplate>>,
        #[prost(string, optional, tag="9")]
        pub template_id: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(oneof="template_message::Format", tags="1, 2, 5")]
        pub format: ::core::option::Option<template_message::Format>,
    }
    /// Nested message and enum types in `TemplateMessage`.
    pub mod template_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FourRowTemplate {
            #[prost(message, optional, boxed, tag="6")]
            pub content: ::core::option::Option<::prost::alloc::boxed::Box<super::HighlyStructuredMessage>>,
            #[prost(message, optional, boxed, tag="7")]
            pub footer: ::core::option::Option<::prost::alloc::boxed::Box<super::HighlyStructuredMessage>>,
            #[prost(message, repeated, tag="8")]
            pub buttons: ::prost::alloc::vec::Vec<super::super::TemplateButton>,
            #[prost(oneof="four_row_template::Title", tags="1, 2, 3, 4, 5")]
            pub title: ::core::option::Option<four_row_template::Title>,
        }
        /// Nested message and enum types in `FourRowTemplate`.
        pub mod four_row_template {
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Title {
                #[prost(message, tag="1")]
                DocumentMessage(::prost::alloc::boxed::Box<super::super::DocumentMessage>),
                #[prost(message, tag="2")]
                HighlyStructuredMessage(::prost::alloc::boxed::Box<super::super::HighlyStructuredMessage>),
                #[prost(message, tag="3")]
                ImageMessage(::prost::alloc::boxed::Box<super::super::ImageMessage>),
                #[prost(message, tag="4")]
                VideoMessage(::prost::alloc::boxed::Box<super::super::VideoMessage>),
                #[prost(message, tag="5")]
                LocationMessage(::prost::alloc::boxed::Box<super::super::LocationMessage>),
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct HydratedFourRowTemplate {
            #[prost(string, optional, tag="6")]
            pub hydrated_content_text: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="7")]
            pub hydrated_footer_text: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(message, repeated, tag="8")]
            pub hydrated_buttons: ::prost::alloc::vec::Vec<super::super::HydratedTemplateButton>,
            #[prost(string, optional, tag="9")]
            pub template_id: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(bool, optional, tag="10")]
            pub mask_linked_devices: ::core::option::Option<bool>,
            #[prost(oneof="hydrated_four_row_template::Title", tags="1, 2, 3, 4, 5")]
            pub title: ::core::option::Option<hydrated_four_row_template::Title>,
        }
        /// Nested message and enum types in `HydratedFourRowTemplate`.
        pub mod hydrated_four_row_template {
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Title {
                #[prost(message, tag="1")]
                DocumentMessage(::prost::alloc::boxed::Box<super::super::DocumentMessage>),
                #[prost(string, tag="2")]
                HydratedTitleText(::prost::alloc::string::String),
                #[prost(message, tag="3")]
                ImageMessage(::prost::alloc::boxed::Box<super::super::ImageMessage>),
                #[prost(message, tag="4")]
                VideoMessage(::prost::alloc::boxed::Box<super::super::VideoMessage>),
                #[prost(message, tag="5")]
                LocationMessage(::prost::alloc::boxed::Box<super::super::LocationMessage>),
            }
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Format {
            #[prost(message, tag="1")]
            FourRowTemplate(::prost::alloc::boxed::Box<FourRowTemplate>),
            #[prost(message, tag="2")]
            HydratedFourRowTemplate(::prost::alloc::boxed::Box<HydratedFourRowTemplate>),
            #[prost(message, tag="5")]
            InteractiveMessageTemplate(::prost::alloc::boxed::Box<super::InteractiveMessage>),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct UrlMetadata {
        #[prost(uint32, optional, tag="1")]
        pub fb_experiment_id: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VideoMessage {
        #[prost(string, optional, tag="1")]
        pub url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub mimetype: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="3")]
        pub file_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(uint64, optional, tag="4")]
        pub file_length: ::core::option::Option<u64>,
        #[prost(uint32, optional, tag="5")]
        pub seconds: ::core::option::Option<u32>,
        #[prost(bytes="vec", optional, tag="6")]
        pub media_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="7")]
        pub caption: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag="8")]
        pub gif_playback: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag="9")]
        pub height: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="10")]
        pub width: ::core::option::Option<u32>,
        #[prost(bytes="vec", optional, tag="11")]
        pub file_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(message, repeated, tag="12")]
        pub interactive_annotations: ::prost::alloc::vec::Vec<super::InteractiveAnnotation>,
        #[prost(string, optional, tag="13")]
        pub direct_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int64, optional, tag="14")]
        pub media_key_timestamp: ::core::option::Option<i64>,
        #[prost(bytes="vec", optional, tag="16")]
        pub jpeg_thumbnail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(message, optional, boxed, tag="17")]
        pub context_info: ::core::option::Option<::prost::alloc::boxed::Box<super::ContextInfo>>,
        #[prost(bytes="vec", optional, tag="18")]
        pub streaming_sidecar: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(enumeration="video_message::Attribution", optional, tag="19")]
        pub gif_attribution: ::core::option::Option<i32>,
        #[prost(bool, optional, tag="20")]
        pub view_once: ::core::option::Option<bool>,
        #[prost(string, optional, tag="21")]
        pub thumbnail_direct_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="22")]
        pub thumbnail_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="23")]
        pub thumbnail_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="24")]
        pub static_url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="25")]
        pub annotations: ::prost::alloc::vec::Vec<super::InteractiveAnnotation>,
        #[prost(string, optional, tag="26")]
        pub accessibility_label: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="27")]
        pub processed_videos: ::prost::alloc::vec::Vec<super::ProcessedVideo>,
        #[prost(uint32, optional, tag="28")]
        pub external_share_full_video_duration_in_seconds: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `VideoMessage`.
    pub mod video_message {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum Attribution {
            None = 0,
            Giphy = 1,
            Tenor = 2,
        }
        impl Attribution {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::None => "NONE",
                    Self::Giphy => "GIPHY",
                    Self::Tenor => "TENOR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NONE" => Some(Self::None),
                    "GIPHY" => Some(Self::Giphy),
                    "TENOR" => Some(Self::Tenor),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum PeerDataOperationRequestType {
        UploadSticker = 0,
        SendRecentStickerBootstrap = 1,
        GenerateLinkPreview = 2,
        HistorySyncOnDemand = 3,
        PlaceholderMessageResend = 4,
        WaffleLinkingNonceFetch = 5,
        FullHistorySyncOnDemand = 6,
        CompanionMetaNonceFetch = 7,
        CompanionSyncdSnapshotFatalRecovery = 8,
    }
    impl PeerDataOperationRequestType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UploadSticker => "UPLOAD_STICKER",
                Self::SendRecentStickerBootstrap => "SEND_RECENT_STICKER_BOOTSTRAP",
                Self::GenerateLinkPreview => "GENERATE_LINK_PREVIEW",
                Self::HistorySyncOnDemand => "HISTORY_SYNC_ON_DEMAND",
                Self::PlaceholderMessageResend => "PLACEHOLDER_MESSAGE_RESEND",
                Self::WaffleLinkingNonceFetch => "WAFFLE_LINKING_NONCE_FETCH",
                Self::FullHistorySyncOnDemand => "FULL_HISTORY_SYNC_ON_DEMAND",
                Self::CompanionMetaNonceFetch => "COMPANION_META_NONCE_FETCH",
                Self::CompanionSyncdSnapshotFatalRecovery => "COMPANION_SYNCD_SNAPSHOT_FATAL_RECOVERY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UPLOAD_STICKER" => Some(Self::UploadSticker),
                "SEND_RECENT_STICKER_BOOTSTRAP" => Some(Self::SendRecentStickerBootstrap),
                "GENERATE_LINK_PREVIEW" => Some(Self::GenerateLinkPreview),
                "HISTORY_SYNC_ON_DEMAND" => Some(Self::HistorySyncOnDemand),
                "PLACEHOLDER_MESSAGE_RESEND" => Some(Self::PlaceholderMessageResend),
                "WAFFLE_LINKING_NONCE_FETCH" => Some(Self::WaffleLinkingNonceFetch),
                "FULL_HISTORY_SYNC_ON_DEMAND" => Some(Self::FullHistorySyncOnDemand),
                "COMPANION_META_NONCE_FETCH" => Some(Self::CompanionMetaNonceFetch),
                "COMPANION_SYNCD_SNAPSHOT_FATAL_RECOVERY" => Some(Self::CompanionSyncdSnapshotFatalRecovery),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum PollContentType {
        Unknown = 0,
        Text = 1,
        Image = 2,
    }
    impl PollContentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Text => "TEXT",
                Self::Image => "IMAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "TEXT" => Some(Self::Text),
                "IMAGE" => Some(Self::Image),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageAddOn {
    #[prost(enumeration="message_add_on::MessageAddOnType", optional, tag="1")]
    pub message_add_on_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag="2")]
    pub message_add_on: ::core::option::Option<Message>,
    #[prost(int64, optional, tag="3")]
    pub sender_timestamp_ms: ::core::option::Option<i64>,
    #[prost(int64, optional, tag="4")]
    pub server_timestamp_ms: ::core::option::Option<i64>,
    #[prost(enumeration="web_message_info::Status", optional, tag="5")]
    pub status: ::core::option::Option<i32>,
    #[prost(message, optional, tag="6")]
    pub add_on_context_info: ::core::option::Option<MessageAddOnContextInfo>,
    #[prost(message, optional, tag="7")]
    pub message_add_on_key: ::core::option::Option<MessageKey>,
    #[prost(message, optional, tag="8")]
    pub legacy_message: ::core::option::Option<LegacyMessage>,
}
/// Nested message and enum types in `MessageAddOn`.
pub mod message_add_on {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum MessageAddOnType {
        Undefined = 0,
        Reaction = 1,
        EventResponse = 2,
        PollUpdate = 3,
        PinInChat = 4,
    }
    impl MessageAddOnType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Undefined => "UNDEFINED",
                Self::Reaction => "REACTION",
                Self::EventResponse => "EVENT_RESPONSE",
                Self::PollUpdate => "POLL_UPDATE",
                Self::PinInChat => "PIN_IN_CHAT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED" => Some(Self::Undefined),
                "REACTION" => Some(Self::Reaction),
                "EVENT_RESPONSE" => Some(Self::EventResponse),
                "POLL_UPDATE" => Some(Self::PollUpdate),
                "PIN_IN_CHAT" => Some(Self::PinInChat),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MessageAddOnContextInfo {
    #[prost(uint32, optional, tag="1")]
    pub message_add_on_duration_in_secs: ::core::option::Option<u32>,
    #[prost(enumeration="message_context_info::MessageAddonExpiryType", optional, tag="2")]
    pub message_add_on_expiry_type: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MessageAssociation {
    #[prost(enumeration="message_association::AssociationType", optional, tag="1")]
    pub association_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag="2")]
    pub parent_message_key: ::core::option::Option<MessageKey>,
    #[prost(int32, optional, tag="3")]
    pub message_index: ::core::option::Option<i32>,
}
/// Nested message and enum types in `MessageAssociation`.
pub mod message_association {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AssociationType {
        Unknown = 0,
        MediaAlbum = 1,
        BotPlugin = 2,
        EventCoverImage = 3,
        StatusPoll = 4,
        HdVideoDualUpload = 5,
        StatusExternalReshare = 6,
        MediaPoll = 7,
        StatusAddYours = 8,
        StatusNotification = 9,
        HdImageDualUpload = 10,
        StickerAnnotation = 11,
        MotionPhoto = 12,
        StatusLinkAction = 13,
        ViewAllReplies = 14,
    }
    impl AssociationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::MediaAlbum => "MEDIA_ALBUM",
                Self::BotPlugin => "BOT_PLUGIN",
                Self::EventCoverImage => "EVENT_COVER_IMAGE",
                Self::StatusPoll => "STATUS_POLL",
                Self::HdVideoDualUpload => "HD_VIDEO_DUAL_UPLOAD",
                Self::StatusExternalReshare => "STATUS_EXTERNAL_RESHARE",
                Self::MediaPoll => "MEDIA_POLL",
                Self::StatusAddYours => "STATUS_ADD_YOURS",
                Self::StatusNotification => "STATUS_NOTIFICATION",
                Self::HdImageDualUpload => "HD_IMAGE_DUAL_UPLOAD",
                Self::StickerAnnotation => "STICKER_ANNOTATION",
                Self::MotionPhoto => "MOTION_PHOTO",
                Self::StatusLinkAction => "STATUS_LINK_ACTION",
                Self::ViewAllReplies => "VIEW_ALL_REPLIES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "MEDIA_ALBUM" => Some(Self::MediaAlbum),
                "BOT_PLUGIN" => Some(Self::BotPlugin),
                "EVENT_COVER_IMAGE" => Some(Self::EventCoverImage),
                "STATUS_POLL" => Some(Self::StatusPoll),
                "HD_VIDEO_DUAL_UPLOAD" => Some(Self::HdVideoDualUpload),
                "STATUS_EXTERNAL_RESHARE" => Some(Self::StatusExternalReshare),
                "MEDIA_POLL" => Some(Self::MediaPoll),
                "STATUS_ADD_YOURS" => Some(Self::StatusAddYours),
                "STATUS_NOTIFICATION" => Some(Self::StatusNotification),
                "HD_IMAGE_DUAL_UPLOAD" => Some(Self::HdImageDualUpload),
                "STICKER_ANNOTATION" => Some(Self::StickerAnnotation),
                "MOTION_PHOTO" => Some(Self::MotionPhoto),
                "STATUS_LINK_ACTION" => Some(Self::StatusLinkAction),
                "VIEW_ALL_REPLIES" => Some(Self::ViewAllReplies),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageContextInfo {
    #[prost(message, optional, tag="1")]
    pub device_list_metadata: ::core::option::Option<DeviceListMetadata>,
    #[prost(int32, optional, tag="2")]
    pub device_list_metadata_version: ::core::option::Option<i32>,
    #[prost(bytes="vec", optional, tag="3")]
    pub message_secret: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="4")]
    pub padding_bytes: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag="5")]
    pub message_add_on_duration_in_secs: ::core::option::Option<u32>,
    #[prost(bytes="vec", optional, tag="6")]
    pub bot_message_secret: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag="7")]
    pub bot_metadata: ::core::option::Option<BotMetadata>,
    #[prost(int32, optional, tag="8")]
    pub reporting_token_version: ::core::option::Option<i32>,
    #[prost(enumeration="message_context_info::MessageAddonExpiryType", optional, tag="9")]
    pub message_add_on_expiry_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag="10")]
    pub message_association: ::core::option::Option<MessageAssociation>,
    #[prost(bool, optional, tag="11")]
    pub capi_created_group: ::core::option::Option<bool>,
    #[prost(string, optional, tag="12")]
    pub support_payload: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="13")]
    pub limit_sharing: ::core::option::Option<LimitSharing>,
    #[prost(message, optional, tag="14")]
    pub limit_sharing_v2: ::core::option::Option<LimitSharing>,
}
/// Nested message and enum types in `MessageContextInfo`.
pub mod message_context_info {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum MessageAddonExpiryType {
        Static = 1,
        DependentOnParent = 2,
    }
    impl MessageAddonExpiryType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Static => "STATIC",
                Self::DependentOnParent => "DEPENDENT_ON_PARENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATIC" => Some(Self::Static),
                "DEPENDENT_ON_PARENT" => Some(Self::DependentOnParent),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MessageKey {
    #[prost(string, optional, tag="1")]
    pub remote_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="2")]
    pub from_me: ::core::option::Option<bool>,
    #[prost(string, optional, tag="3")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub participant: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MessageSecretMessage {
    #[prost(sfixed32, optional, tag="1")]
    pub version: ::core::option::Option<i32>,
    #[prost(bytes="vec", optional, tag="2")]
    pub enc_iv: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="3")]
    pub enc_payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Money {
    #[prost(int64, optional, tag="1")]
    pub value: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag="2")]
    pub offset: ::core::option::Option<u32>,
    #[prost(string, optional, tag="3")]
    pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgOpaqueData {
    #[prost(string, optional, tag="1")]
    pub body: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub caption: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(double, optional, tag="5")]
    pub lng: ::core::option::Option<f64>,
    #[prost(bool, optional, tag="6")]
    pub is_live: ::core::option::Option<bool>,
    #[prost(double, optional, tag="7")]
    pub lat: ::core::option::Option<f64>,
    #[prost(int32, optional, tag="8")]
    pub payment_amount1000: ::core::option::Option<i32>,
    #[prost(string, optional, tag="9")]
    pub payment_note_msg_body: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="11")]
    pub matched_text: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="12")]
    pub title: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="13")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="vec", optional, tag="14")]
    pub futureproof_buffer: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag="15")]
    pub client_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="16")]
    pub loc: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="17")]
    pub poll_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="18")]
    pub poll_options: ::prost::alloc::vec::Vec<msg_opaque_data::PollOption>,
    #[prost(uint32, optional, tag="20")]
    pub poll_selectable_options_count: ::core::option::Option<u32>,
    #[prost(bytes="vec", optional, tag="21")]
    pub message_secret: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag="51")]
    pub original_self_author: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag="22")]
    pub sender_timestamp_ms: ::core::option::Option<i64>,
    #[prost(string, optional, tag="23")]
    pub poll_update_parent_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="24")]
    pub enc_poll_vote: ::core::option::Option<PollEncValue>,
    #[prost(bool, optional, tag="28")]
    pub is_sent_cag_poll_creation: ::core::option::Option<bool>,
    #[prost(enumeration="msg_opaque_data::PollContentType", optional, tag="42")]
    pub poll_content_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag="41")]
    pub poll_votes_snapshot: ::core::option::Option<msg_opaque_data::PollVotesSnapshot>,
    #[prost(string, optional, tag="25")]
    pub enc_reaction_target_message_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="vec", optional, tag="26")]
    pub enc_reaction_enc_payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="27")]
    pub enc_reaction_enc_iv: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="29")]
    pub bot_message_secret: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag="30")]
    pub target_message_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="vec", optional, tag="31")]
    pub enc_payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="32")]
    pub enc_iv: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag="33")]
    pub event_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="34")]
    pub is_event_canceled: ::core::option::Option<bool>,
    #[prost(string, optional, tag="35")]
    pub event_description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="36")]
    pub event_join_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag="37")]
    pub event_start_time: ::core::option::Option<i64>,
    #[prost(message, optional, tag="38")]
    pub event_location: ::core::option::Option<msg_opaque_data::EventLocation>,
    #[prost(int64, optional, tag="40")]
    pub event_end_time: ::core::option::Option<i64>,
    #[prost(bytes="vec", optional, tag="43")]
    pub plain_protobuf_bytes: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `MsgOpaqueData`.
pub mod msg_opaque_data {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EventLocation {
        #[prost(double, optional, tag="1")]
        pub degrees_latitude: ::core::option::Option<f64>,
        #[prost(double, optional, tag="2")]
        pub degrees_longitude: ::core::option::Option<f64>,
        #[prost(string, optional, tag="3")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="4")]
        pub address: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="5")]
        pub url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="6")]
        pub jpeg_thumbnail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PollOption {
        #[prost(string, optional, tag="1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub hash: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PollVoteSnapshot {
        #[prost(message, optional, tag="1")]
        pub option: ::core::option::Option<PollOption>,
        #[prost(int32, optional, tag="2")]
        pub option_vote_count: ::core::option::Option<i32>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PollVotesSnapshot {
        #[prost(message, repeated, tag="1")]
        pub poll_votes: ::prost::alloc::vec::Vec<PollVoteSnapshot>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum PollContentType {
        Unknown = 0,
        Text = 1,
        Image = 2,
    }
    impl PollContentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Text => "TEXT",
                Self::Image => "IMAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "TEXT" => Some(Self::Text),
                "IMAGE" => Some(Self::Image),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRowOpaqueData {
    #[prost(message, optional, tag="1")]
    pub current_msg: ::core::option::Option<MsgOpaqueData>,
    #[prost(message, optional, tag="2")]
    pub quoted_msg: ::core::option::Option<MsgOpaqueData>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NoiseCertificate {
    #[prost(bytes="vec", optional, tag="1")]
    pub details: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="2")]
    pub signature: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `NoiseCertificate`.
pub mod noise_certificate {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Details {
        #[prost(uint32, optional, tag="1")]
        pub serial: ::core::option::Option<u32>,
        #[prost(string, optional, tag="2")]
        pub issuer: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint64, optional, tag="3")]
        pub expires: ::core::option::Option<u64>,
        #[prost(string, optional, tag="4")]
        pub subject: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="5")]
        pub key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationMessageInfo {
    #[prost(message, optional, tag="1")]
    pub key: ::core::option::Option<MessageKey>,
    #[prost(message, optional, tag="2")]
    pub message: ::core::option::Option<Message>,
    #[prost(uint64, optional, tag="3")]
    pub message_timestamp: ::core::option::Option<u64>,
    #[prost(string, optional, tag="4")]
    pub participant: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotificationSettings {
    #[prost(string, optional, tag="1")]
    pub message_vibrate: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub message_popup: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub message_light: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="4")]
    pub low_priority_notifications: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="5")]
    pub reactions_muted: ::core::option::Option<bool>,
    #[prost(string, optional, tag="6")]
    pub call_vibrate: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PairingRequest {
    #[prost(bytes="vec", optional, tag="1")]
    pub companion_public_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="2")]
    pub companion_identity_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="3")]
    pub adv_secret: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PastParticipant {
    #[prost(string, optional, tag="1")]
    pub user_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration="past_participant::LeaveReason", optional, tag="2")]
    pub leave_reason: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag="3")]
    pub leave_ts: ::core::option::Option<u64>,
}
/// Nested message and enum types in `PastParticipant`.
pub mod past_participant {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum LeaveReason {
        Left = 0,
        Removed = 1,
    }
    impl LeaveReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Left => "LEFT",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LEFT" => Some(Self::Left),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PastParticipants {
    #[prost(string, optional, tag="1")]
    pub group_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="2")]
    pub past_participants: ::prost::alloc::vec::Vec<PastParticipant>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PatchDebugData {
    #[prost(bytes="vec", optional, tag="1")]
    pub current_lthash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="2")]
    pub new_lthash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="3")]
    pub patch_version: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="4")]
    pub collection_name: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="5")]
    pub first_four_bytes_from_a_hash_of_snapshot_mac_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="6")]
    pub new_lthash_subtract: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag="7")]
    pub number_add: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="8")]
    pub number_remove: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="9")]
    pub number_override: ::core::option::Option<i32>,
    #[prost(enumeration="patch_debug_data::Platform", optional, tag="10")]
    pub sender_platform: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="11")]
    pub is_sender_primary: ::core::option::Option<bool>,
}
/// Nested message and enum types in `PatchDebugData`.
pub mod patch_debug_data {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Platform {
        Android = 0,
        Smba = 1,
        Iphone = 2,
        Smbi = 3,
        Web = 4,
        Uwp = 5,
        Darwin = 6,
        Ipad = 7,
        Wearos = 8,
    }
    impl Platform {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Android => "ANDROID",
                Self::Smba => "SMBA",
                Self::Iphone => "IPHONE",
                Self::Smbi => "SMBI",
                Self::Web => "WEB",
                Self::Uwp => "UWP",
                Self::Darwin => "DARWIN",
                Self::Ipad => "IPAD",
                Self::Wearos => "WEAROS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ANDROID" => Some(Self::Android),
                "SMBA" => Some(Self::Smba),
                "IPHONE" => Some(Self::Iphone),
                "SMBI" => Some(Self::Smbi),
                "WEB" => Some(Self::Web),
                "UWP" => Some(Self::Uwp),
                "DARWIN" => Some(Self::Darwin),
                "IPAD" => Some(Self::Ipad),
                "WEAROS" => Some(Self::Wearos),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PaymentBackground {
    #[prost(string, optional, tag="1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag="2")]
    pub file_length: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="3")]
    pub width: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub height: ::core::option::Option<u32>,
    #[prost(string, optional, tag="5")]
    pub mimetype: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(fixed32, optional, tag="6")]
    pub placeholder_argb: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag="7")]
    pub text_argb: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag="8")]
    pub subtext_argb: ::core::option::Option<u32>,
    #[prost(message, optional, tag="9")]
    pub media_data: ::core::option::Option<payment_background::MediaData>,
    #[prost(enumeration="payment_background::Type", optional, tag="10")]
    pub r#type: ::core::option::Option<i32>,
}
/// Nested message and enum types in `PaymentBackground`.
pub mod payment_background {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct MediaData {
        #[prost(bytes="vec", optional, tag="1")]
        pub media_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(int64, optional, tag="2")]
        pub media_key_timestamp: ::core::option::Option<i64>,
        #[prost(bytes="vec", optional, tag="3")]
        pub file_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="4")]
        pub file_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="5")]
        pub direct_path: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Unknown = 0,
        Default = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Default => "DEFAULT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "DEFAULT" => Some(Self::Default),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PaymentInfo {
    #[prost(enumeration="payment_info::Currency", optional, tag="1")]
    pub currency_deprecated: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag="2")]
    pub amount1000: ::core::option::Option<u64>,
    #[prost(string, optional, tag="3")]
    pub receiver_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration="payment_info::Status", optional, tag="4")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag="5")]
    pub transaction_timestamp: ::core::option::Option<u64>,
    #[prost(message, optional, tag="6")]
    pub request_message_key: ::core::option::Option<MessageKey>,
    #[prost(uint64, optional, tag="7")]
    pub expiry_timestamp: ::core::option::Option<u64>,
    #[prost(bool, optional, tag="8")]
    pub futureproofed: ::core::option::Option<bool>,
    #[prost(string, optional, tag="9")]
    pub currency: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration="payment_info::TxnStatus", optional, tag="10")]
    pub txn_status: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="11")]
    pub use_novi_fiat_format: ::core::option::Option<bool>,
    #[prost(message, optional, tag="12")]
    pub primary_amount: ::core::option::Option<Money>,
    #[prost(message, optional, tag="13")]
    pub exchange_amount: ::core::option::Option<Money>,
}
/// Nested message and enum types in `PaymentInfo`.
pub mod payment_info {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Currency {
        UnknownCurrency = 0,
        Inr = 1,
    }
    impl Currency {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownCurrency => "UNKNOWN_CURRENCY",
                Self::Inr => "INR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_CURRENCY" => Some(Self::UnknownCurrency),
                "INR" => Some(Self::Inr),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Status {
        UnknownStatus = 0,
        Processing = 1,
        Sent = 2,
        NeedToAccept = 3,
        Complete = 4,
        CouldNotComplete = 5,
        Refunded = 6,
        Expired = 7,
        Rejected = 8,
        Cancelled = 9,
        WaitingForPayer = 10,
        Waiting = 11,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownStatus => "UNKNOWN_STATUS",
                Self::Processing => "PROCESSING",
                Self::Sent => "SENT",
                Self::NeedToAccept => "NEED_TO_ACCEPT",
                Self::Complete => "COMPLETE",
                Self::CouldNotComplete => "COULD_NOT_COMPLETE",
                Self::Refunded => "REFUNDED",
                Self::Expired => "EXPIRED",
                Self::Rejected => "REJECTED",
                Self::Cancelled => "CANCELLED",
                Self::WaitingForPayer => "WAITING_FOR_PAYER",
                Self::Waiting => "WAITING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_STATUS" => Some(Self::UnknownStatus),
                "PROCESSING" => Some(Self::Processing),
                "SENT" => Some(Self::Sent),
                "NEED_TO_ACCEPT" => Some(Self::NeedToAccept),
                "COMPLETE" => Some(Self::Complete),
                "COULD_NOT_COMPLETE" => Some(Self::CouldNotComplete),
                "REFUNDED" => Some(Self::Refunded),
                "EXPIRED" => Some(Self::Expired),
                "REJECTED" => Some(Self::Rejected),
                "CANCELLED" => Some(Self::Cancelled),
                "WAITING_FOR_PAYER" => Some(Self::WaitingForPayer),
                "WAITING" => Some(Self::Waiting),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum TxnStatus {
        Unknown = 0,
        PendingSetup = 1,
        PendingReceiverSetup = 2,
        Init = 3,
        Success = 4,
        Completed = 5,
        Failed = 6,
        FailedRisk = 7,
        FailedProcessing = 8,
        FailedReceiverProcessing = 9,
        FailedDa = 10,
        FailedDaFinal = 11,
        RefundedTxn = 12,
        RefundFailed = 13,
        RefundFailedProcessing = 14,
        RefundFailedDa = 15,
        ExpiredTxn = 16,
        AuthCanceled = 17,
        AuthCancelFailedProcessing = 18,
        AuthCancelFailed = 19,
        CollectInit = 20,
        CollectSuccess = 21,
        CollectFailed = 22,
        CollectFailedRisk = 23,
        CollectRejected = 24,
        CollectExpired = 25,
        CollectCanceled = 26,
        CollectCancelling = 27,
        InReview = 28,
        ReversalSuccess = 29,
        ReversalPending = 30,
        RefundPending = 31,
    }
    impl TxnStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::PendingSetup => "PENDING_SETUP",
                Self::PendingReceiverSetup => "PENDING_RECEIVER_SETUP",
                Self::Init => "INIT",
                Self::Success => "SUCCESS",
                Self::Completed => "COMPLETED",
                Self::Failed => "FAILED",
                Self::FailedRisk => "FAILED_RISK",
                Self::FailedProcessing => "FAILED_PROCESSING",
                Self::FailedReceiverProcessing => "FAILED_RECEIVER_PROCESSING",
                Self::FailedDa => "FAILED_DA",
                Self::FailedDaFinal => "FAILED_DA_FINAL",
                Self::RefundedTxn => "REFUNDED_TXN",
                Self::RefundFailed => "REFUND_FAILED",
                Self::RefundFailedProcessing => "REFUND_FAILED_PROCESSING",
                Self::RefundFailedDa => "REFUND_FAILED_DA",
                Self::ExpiredTxn => "EXPIRED_TXN",
                Self::AuthCanceled => "AUTH_CANCELED",
                Self::AuthCancelFailedProcessing => "AUTH_CANCEL_FAILED_PROCESSING",
                Self::AuthCancelFailed => "AUTH_CANCEL_FAILED",
                Self::CollectInit => "COLLECT_INIT",
                Self::CollectSuccess => "COLLECT_SUCCESS",
                Self::CollectFailed => "COLLECT_FAILED",
                Self::CollectFailedRisk => "COLLECT_FAILED_RISK",
                Self::CollectRejected => "COLLECT_REJECTED",
                Self::CollectExpired => "COLLECT_EXPIRED",
                Self::CollectCanceled => "COLLECT_CANCELED",
                Self::CollectCancelling => "COLLECT_CANCELLING",
                Self::InReview => "IN_REVIEW",
                Self::ReversalSuccess => "REVERSAL_SUCCESS",
                Self::ReversalPending => "REVERSAL_PENDING",
                Self::RefundPending => "REFUND_PENDING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING_SETUP" => Some(Self::PendingSetup),
                "PENDING_RECEIVER_SETUP" => Some(Self::PendingReceiverSetup),
                "INIT" => Some(Self::Init),
                "SUCCESS" => Some(Self::Success),
                "COMPLETED" => Some(Self::Completed),
                "FAILED" => Some(Self::Failed),
                "FAILED_RISK" => Some(Self::FailedRisk),
                "FAILED_PROCESSING" => Some(Self::FailedProcessing),
                "FAILED_RECEIVER_PROCESSING" => Some(Self::FailedReceiverProcessing),
                "FAILED_DA" => Some(Self::FailedDa),
                "FAILED_DA_FINAL" => Some(Self::FailedDaFinal),
                "REFUNDED_TXN" => Some(Self::RefundedTxn),
                "REFUND_FAILED" => Some(Self::RefundFailed),
                "REFUND_FAILED_PROCESSING" => Some(Self::RefundFailedProcessing),
                "REFUND_FAILED_DA" => Some(Self::RefundFailedDa),
                "EXPIRED_TXN" => Some(Self::ExpiredTxn),
                "AUTH_CANCELED" => Some(Self::AuthCanceled),
                "AUTH_CANCEL_FAILED_PROCESSING" => Some(Self::AuthCancelFailedProcessing),
                "AUTH_CANCEL_FAILED" => Some(Self::AuthCancelFailed),
                "COLLECT_INIT" => Some(Self::CollectInit),
                "COLLECT_SUCCESS" => Some(Self::CollectSuccess),
                "COLLECT_FAILED" => Some(Self::CollectFailed),
                "COLLECT_FAILED_RISK" => Some(Self::CollectFailedRisk),
                "COLLECT_REJECTED" => Some(Self::CollectRejected),
                "COLLECT_EXPIRED" => Some(Self::CollectExpired),
                "COLLECT_CANCELED" => Some(Self::CollectCanceled),
                "COLLECT_CANCELLING" => Some(Self::CollectCancelling),
                "IN_REVIEW" => Some(Self::InReview),
                "REVERSAL_SUCCESS" => Some(Self::ReversalSuccess),
                "REVERSAL_PENDING" => Some(Self::ReversalPending),
                "REFUND_PENDING" => Some(Self::RefundPending),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PhoneNumberToLidMapping {
    #[prost(string, optional, tag="1")]
    pub pn_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub lid_jid: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PhotoChange {
    #[prost(bytes="vec", optional, tag="1")]
    pub old_photo: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="2")]
    pub new_photo: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag="3")]
    pub new_photo_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PinInChat {
    #[prost(enumeration="pin_in_chat::Type", optional, tag="1")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(message, optional, tag="2")]
    pub key: ::core::option::Option<MessageKey>,
    #[prost(int64, optional, tag="3")]
    pub sender_timestamp_ms: ::core::option::Option<i64>,
    #[prost(int64, optional, tag="4")]
    pub server_timestamp_ms: ::core::option::Option<i64>,
    #[prost(message, optional, tag="5")]
    pub message_add_on_context_info: ::core::option::Option<MessageAddOnContextInfo>,
}
/// Nested message and enum types in `PinInChat`.
pub mod pin_in_chat {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        UnknownType = 0,
        PinForAll = 1,
        UnpinForAll = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownType => "UNKNOWN_TYPE",
                Self::PinForAll => "PIN_FOR_ALL",
                Self::UnpinForAll => "UNPIN_FOR_ALL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_TYPE" => Some(Self::UnknownType),
                "PIN_FOR_ALL" => Some(Self::PinForAll),
                "UNPIN_FOR_ALL" => Some(Self::UnpinForAll),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Point {
    #[prost(int32, optional, tag="1")]
    pub x_deprecated: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub y_deprecated: ::core::option::Option<i32>,
    #[prost(double, optional, tag="3")]
    pub x: ::core::option::Option<f64>,
    #[prost(double, optional, tag="4")]
    pub y: ::core::option::Option<f64>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PollAdditionalMetadata {
    #[prost(bool, optional, tag="1")]
    pub poll_invalidated: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PollEncValue {
    #[prost(bytes="vec", optional, tag="1")]
    pub enc_payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="2")]
    pub enc_iv: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PollUpdate {
    #[prost(message, optional, tag="1")]
    pub poll_update_message_key: ::core::option::Option<MessageKey>,
    #[prost(message, optional, tag="2")]
    pub vote: ::core::option::Option<message::PollVoteMessage>,
    #[prost(int64, optional, tag="3")]
    pub sender_timestamp_ms: ::core::option::Option<i64>,
    #[prost(int64, optional, tag="4")]
    pub server_timestamp_ms: ::core::option::Option<i64>,
    #[prost(bool, optional, tag="5")]
    pub unread: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PreKeyRecordStructure {
    #[prost(uint32, optional, tag="1")]
    pub id: ::core::option::Option<u32>,
    #[prost(bytes="vec", optional, tag="2")]
    pub public_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="3")]
    pub private_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PreKeySignalMessage {
    #[prost(uint32, optional, tag="5")]
    pub registration_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="1")]
    pub pre_key_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub signed_pre_key_id: ::core::option::Option<u32>,
    #[prost(bytes="vec", optional, tag="2")]
    pub base_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="3")]
    pub identity_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="4")]
    pub message: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PremiumMessageInfo {
    #[prost(string, optional, tag="1")]
    pub server_campaign_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PrimaryEphemeralIdentity {
    #[prost(bytes="vec", optional, tag="1")]
    pub public_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="2")]
    pub nonce: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProcessedVideo {
    #[prost(string, optional, tag="1")]
    pub direct_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="vec", optional, tag="2")]
    pub file_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag="3")]
    pub height: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub width: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="5")]
    pub file_length: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="6")]
    pub bitrate: ::core::option::Option<u32>,
    #[prost(enumeration="processed_video::VideoQuality", optional, tag="7")]
    pub quality: ::core::option::Option<i32>,
    #[prost(string, repeated, tag="8")]
    pub capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ProcessedVideo`.
pub mod processed_video {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum VideoQuality {
        Undefined = 0,
        Low = 1,
        Mid = 2,
        High = 3,
    }
    impl VideoQuality {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Undefined => "UNDEFINED",
                Self::Low => "LOW",
                Self::Mid => "MID",
                Self::High => "HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED" => Some(Self::Undefined),
                "LOW" => Some(Self::Low),
                "MID" => Some(Self::Mid),
                "HIGH" => Some(Self::High),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProloguePayload {
    #[prost(bytes="vec", optional, tag="1")]
    pub companion_ephemeral_identity: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag="2")]
    pub commitment: ::core::option::Option<CompanionCommitment>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Pushname {
    #[prost(string, optional, tag="1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub pushname: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Reaction {
    #[prost(message, optional, tag="1")]
    pub key: ::core::option::Option<MessageKey>,
    #[prost(string, optional, tag="2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub grouping_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag="4")]
    pub sender_timestamp_ms: ::core::option::Option<i64>,
    #[prost(bool, optional, tag="5")]
    pub unread: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecentEmojiWeight {
    #[prost(string, optional, tag="1")]
    pub emoji: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag="2")]
    pub weight: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordStructure {
    #[prost(message, optional, tag="1")]
    pub current_session: ::core::option::Option<SessionStructure>,
    #[prost(message, repeated, tag="2")]
    pub previous_sessions: ::prost::alloc::vec::Vec<SessionStructure>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Reportable {
    #[prost(uint32, optional, tag="1")]
    pub min_version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub max_version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub not_reportable_min_version: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="4")]
    pub never: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReportingTokenInfo {
    #[prost(bytes="vec", optional, tag="1")]
    pub reporting_tag: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SenderKeyDistributionMessage {
    #[prost(uint32, optional, tag="1")]
    pub id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub iteration: ::core::option::Option<u32>,
    #[prost(bytes="vec", optional, tag="3")]
    pub chain_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="4")]
    pub signing_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SenderKeyMessage {
    #[prost(uint32, optional, tag="1")]
    pub id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub iteration: ::core::option::Option<u32>,
    #[prost(bytes="vec", optional, tag="3")]
    pub ciphertext: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SenderKeyRecordStructure {
    #[prost(message, repeated, tag="1")]
    pub sender_key_states: ::prost::alloc::vec::Vec<SenderKeyStateStructure>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SenderKeyStateStructure {
    #[prost(uint32, optional, tag="1")]
    pub sender_key_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag="2")]
    pub sender_chain_key: ::core::option::Option<sender_key_state_structure::SenderChainKey>,
    #[prost(message, optional, tag="3")]
    pub sender_signing_key: ::core::option::Option<sender_key_state_structure::SenderSigningKey>,
    #[prost(message, repeated, tag="4")]
    pub sender_message_keys: ::prost::alloc::vec::Vec<sender_key_state_structure::SenderMessageKey>,
}
/// Nested message and enum types in `SenderKeyStateStructure`.
pub mod sender_key_state_structure {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SenderChainKey {
        #[prost(uint32, optional, tag="1")]
        pub iteration: ::core::option::Option<u32>,
        #[prost(bytes="vec", optional, tag="2")]
        pub seed: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SenderMessageKey {
        #[prost(uint32, optional, tag="1")]
        pub iteration: ::core::option::Option<u32>,
        #[prost(bytes="vec", optional, tag="2")]
        pub seed: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SenderSigningKey {
        #[prost(bytes="vec", optional, tag="1")]
        pub public: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="2")]
        pub private: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServerErrorReceipt {
    #[prost(string, optional, tag="1")]
    pub stanza_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionStructure {
    #[prost(uint32, optional, tag="1")]
    pub session_version: ::core::option::Option<u32>,
    #[prost(bytes="vec", optional, tag="2")]
    pub local_identity_public: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="3")]
    pub remote_identity_public: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="4")]
    pub root_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag="5")]
    pub previous_counter: ::core::option::Option<u32>,
    #[prost(message, optional, tag="6")]
    pub sender_chain: ::core::option::Option<session_structure::Chain>,
    #[prost(message, repeated, tag="7")]
    pub receiver_chains: ::prost::alloc::vec::Vec<session_structure::Chain>,
    #[prost(message, optional, tag="8")]
    pub pending_key_exchange: ::core::option::Option<session_structure::PendingKeyExchange>,
    #[prost(message, optional, tag="9")]
    pub pending_pre_key: ::core::option::Option<session_structure::PendingPreKey>,
    #[prost(uint32, optional, tag="10")]
    pub remote_registration_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="11")]
    pub local_registration_id: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="12")]
    pub needs_refresh: ::core::option::Option<bool>,
    #[prost(bytes="vec", optional, tag="13")]
    pub alice_base_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `SessionStructure`.
pub mod session_structure {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Chain {
        #[prost(bytes="vec", optional, tag="1")]
        pub sender_ratchet_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="2")]
        pub sender_ratchet_key_private: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(message, optional, tag="3")]
        pub chain_key: ::core::option::Option<chain::ChainKey>,
        #[prost(message, repeated, tag="4")]
        pub message_keys: ::prost::alloc::vec::Vec<chain::MessageKey>,
    }
    /// Nested message and enum types in `Chain`.
    pub mod chain {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ChainKey {
            #[prost(uint32, optional, tag="1")]
            pub index: ::core::option::Option<u32>,
            #[prost(bytes="vec", optional, tag="2")]
            pub key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        }
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct MessageKey {
            #[prost(uint32, optional, tag="1")]
            pub index: ::core::option::Option<u32>,
            #[prost(bytes="vec", optional, tag="2")]
            pub cipher_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
            #[prost(bytes="vec", optional, tag="3")]
            pub mac_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
            #[prost(bytes="vec", optional, tag="4")]
            pub iv: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PendingKeyExchange {
        #[prost(uint32, optional, tag="1")]
        pub sequence: ::core::option::Option<u32>,
        #[prost(bytes="vec", optional, tag="2")]
        pub local_base_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="3")]
        pub local_base_key_private: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="4")]
        pub local_ratchet_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="5")]
        pub local_ratchet_key_private: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="7")]
        pub local_identity_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="8")]
        pub local_identity_key_private: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PendingPreKey {
        #[prost(uint32, optional, tag="1")]
        pub pre_key_id: ::core::option::Option<u32>,
        #[prost(int32, optional, tag="3")]
        pub signed_pre_key_id: ::core::option::Option<i32>,
        #[prost(bytes="vec", optional, tag="2")]
        pub base_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignalMessage {
    #[prost(bytes="vec", optional, tag="1")]
    pub ratchet_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag="2")]
    pub counter: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub previous_counter: ::core::option::Option<u32>,
    #[prost(bytes="vec", optional, tag="4")]
    pub ciphertext: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignedPreKeyRecordStructure {
    #[prost(uint32, optional, tag="1")]
    pub id: ::core::option::Option<u32>,
    #[prost(bytes="vec", optional, tag="2")]
    pub public_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="3")]
    pub private_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="4")]
    pub signature: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(fixed64, optional, tag="5")]
    pub timestamp: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatusMentionMessage {
    #[prost(message, optional, tag="1")]
    pub quoted_status: ::core::option::Option<Message>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatusPsa {
    #[prost(uint64, required, tag="44")]
    pub campaign_id: u64,
    #[prost(uint64, optional, tag="45")]
    pub campaign_expiration_timestamp: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StickerMetadata {
    #[prost(string, optional, tag="1")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="vec", optional, tag="2")]
    pub file_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="3")]
    pub file_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="4")]
    pub media_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag="5")]
    pub mimetype: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="6")]
    pub height: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="7")]
    pub width: ::core::option::Option<u32>,
    #[prost(string, optional, tag="8")]
    pub direct_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag="9")]
    pub file_length: ::core::option::Option<u64>,
    #[prost(float, optional, tag="10")]
    pub weight: ::core::option::Option<f32>,
    #[prost(int64, optional, tag="11")]
    pub last_sticker_sent_ts: ::core::option::Option<i64>,
    #[prost(bool, optional, tag="12")]
    pub is_lottie: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncActionData {
    #[prost(bytes="vec", optional, tag="1")]
    pub index: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag="2")]
    pub value: ::core::option::Option<SyncActionValue>,
    #[prost(bytes="vec", optional, tag="3")]
    pub padding: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag="4")]
    pub version: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncActionValue {
    #[prost(int64, optional, tag="1")]
    pub timestamp: ::core::option::Option<i64>,
    #[prost(message, optional, tag="2")]
    pub star_action: ::core::option::Option<sync_action_value::StarAction>,
    #[prost(message, optional, tag="3")]
    pub contact_action: ::core::option::Option<sync_action_value::ContactAction>,
    #[prost(message, optional, tag="4")]
    pub mute_action: ::core::option::Option<sync_action_value::MuteAction>,
    #[prost(message, optional, tag="5")]
    pub pin_action: ::core::option::Option<sync_action_value::PinAction>,
    #[prost(message, optional, tag="6")]
    pub security_notification_setting: ::core::option::Option<sync_action_value::SecurityNotificationSetting>,
    #[prost(message, optional, tag="7")]
    pub push_name_setting: ::core::option::Option<sync_action_value::PushNameSetting>,
    #[prost(message, optional, tag="8")]
    pub quick_reply_action: ::core::option::Option<sync_action_value::QuickReplyAction>,
    #[prost(message, optional, tag="11")]
    pub recent_emoji_weights_action: ::core::option::Option<sync_action_value::RecentEmojiWeightsAction>,
    #[prost(message, optional, tag="14")]
    pub label_edit_action: ::core::option::Option<sync_action_value::LabelEditAction>,
    #[prost(message, optional, tag="15")]
    pub label_association_action: ::core::option::Option<sync_action_value::LabelAssociationAction>,
    #[prost(message, optional, tag="16")]
    pub locale_setting: ::core::option::Option<sync_action_value::LocaleSetting>,
    #[prost(message, optional, tag="17")]
    pub archive_chat_action: ::core::option::Option<sync_action_value::ArchiveChatAction>,
    #[prost(message, optional, tag="18")]
    pub delete_message_for_me_action: ::core::option::Option<sync_action_value::DeleteMessageForMeAction>,
    #[prost(message, optional, tag="19")]
    pub key_expiration: ::core::option::Option<sync_action_value::KeyExpiration>,
    #[prost(message, optional, tag="20")]
    pub mark_chat_as_read_action: ::core::option::Option<sync_action_value::MarkChatAsReadAction>,
    #[prost(message, optional, tag="21")]
    pub clear_chat_action: ::core::option::Option<sync_action_value::ClearChatAction>,
    #[prost(message, optional, tag="22")]
    pub delete_chat_action: ::core::option::Option<sync_action_value::DeleteChatAction>,
    #[prost(message, optional, tag="23")]
    pub unarchive_chats_setting: ::core::option::Option<sync_action_value::UnarchiveChatsSetting>,
    #[prost(message, optional, tag="24")]
    pub primary_feature: ::core::option::Option<sync_action_value::PrimaryFeature>,
    #[prost(message, optional, tag="26")]
    pub android_unsupported_actions: ::core::option::Option<sync_action_value::AndroidUnsupportedActions>,
    #[prost(message, optional, tag="27")]
    pub agent_action: ::core::option::Option<sync_action_value::AgentAction>,
    #[prost(message, optional, tag="28")]
    pub subscription_action: ::core::option::Option<sync_action_value::SubscriptionAction>,
    #[prost(message, optional, tag="29")]
    pub user_status_mute_action: ::core::option::Option<sync_action_value::UserStatusMuteAction>,
    #[prost(message, optional, tag="30")]
    pub time_format_action: ::core::option::Option<sync_action_value::TimeFormatAction>,
    #[prost(message, optional, tag="31")]
    pub nux_action: ::core::option::Option<sync_action_value::NuxAction>,
    #[prost(message, optional, tag="32")]
    pub primary_version_action: ::core::option::Option<sync_action_value::PrimaryVersionAction>,
    #[prost(message, optional, tag="33")]
    pub sticker_action: ::core::option::Option<sync_action_value::StickerAction>,
    #[prost(message, optional, tag="34")]
    pub remove_recent_sticker_action: ::core::option::Option<sync_action_value::RemoveRecentStickerAction>,
    #[prost(message, optional, tag="35")]
    pub chat_assignment: ::core::option::Option<sync_action_value::ChatAssignmentAction>,
    #[prost(message, optional, tag="36")]
    pub chat_assignment_opened_status: ::core::option::Option<sync_action_value::ChatAssignmentOpenedStatusAction>,
    #[prost(message, optional, tag="37")]
    pub pn_for_lid_chat_action: ::core::option::Option<sync_action_value::PnForLidChatAction>,
    #[prost(message, optional, tag="38")]
    pub marketing_message_action: ::core::option::Option<sync_action_value::MarketingMessageAction>,
    #[prost(message, optional, tag="39")]
    pub marketing_message_broadcast_action: ::core::option::Option<sync_action_value::MarketingMessageBroadcastAction>,
    #[prost(message, optional, tag="40")]
    pub external_web_beta_action: ::core::option::Option<sync_action_value::ExternalWebBetaAction>,
    #[prost(message, optional, tag="41")]
    pub privacy_setting_relay_all_calls: ::core::option::Option<sync_action_value::PrivacySettingRelayAllCalls>,
    #[prost(message, optional, tag="42")]
    pub call_log_action: ::core::option::Option<sync_action_value::CallLogAction>,
    #[prost(message, optional, tag="44")]
    pub status_privacy: ::core::option::Option<sync_action_value::StatusPrivacyAction>,
    #[prost(message, optional, tag="45")]
    pub bot_welcome_request_action: ::core::option::Option<sync_action_value::BotWelcomeRequestAction>,
    #[prost(message, optional, tag="46")]
    pub delete_individual_call_log: ::core::option::Option<sync_action_value::DeleteIndividualCallLogAction>,
    #[prost(message, optional, tag="47")]
    pub label_reordering_action: ::core::option::Option<sync_action_value::LabelReorderingAction>,
    #[prost(message, optional, tag="48")]
    pub payment_info_action: ::core::option::Option<sync_action_value::PaymentInfoAction>,
    #[prost(message, optional, tag="49")]
    pub custom_payment_methods_action: ::core::option::Option<sync_action_value::CustomPaymentMethodsAction>,
    #[prost(message, optional, tag="50")]
    pub lock_chat_action: ::core::option::Option<sync_action_value::LockChatAction>,
    #[prost(message, optional, tag="51")]
    pub chat_lock_settings: ::core::option::Option<ChatLockSettings>,
    #[prost(message, optional, tag="52")]
    pub wamo_user_identifier_action: ::core::option::Option<sync_action_value::WamoUserIdentifierAction>,
    #[prost(message, optional, tag="53")]
    pub privacy_setting_disable_link_previews_action: ::core::option::Option<sync_action_value::PrivacySettingDisableLinkPreviewsAction>,
    #[prost(message, optional, tag="54")]
    pub device_capabilities: ::core::option::Option<DeviceCapabilities>,
    #[prost(message, optional, tag="55")]
    pub note_edit_action: ::core::option::Option<sync_action_value::NoteEditAction>,
    #[prost(message, optional, tag="56")]
    pub favorites_action: ::core::option::Option<sync_action_value::FavoritesAction>,
    #[prost(message, optional, tag="57")]
    pub merchant_payment_partner_action: ::core::option::Option<sync_action_value::MerchantPaymentPartnerAction>,
    #[prost(message, optional, tag="58")]
    pub waffle_account_link_state_action: ::core::option::Option<sync_action_value::WaffleAccountLinkStateAction>,
    #[prost(message, optional, tag="59")]
    pub username_chat_start_mode: ::core::option::Option<sync_action_value::UsernameChatStartModeAction>,
    #[prost(message, optional, tag="60")]
    pub notification_activity_setting_action: ::core::option::Option<sync_action_value::NotificationActivitySettingAction>,
    #[prost(message, optional, tag="61")]
    pub lid_contact_action: ::core::option::Option<sync_action_value::LidContactAction>,
    #[prost(message, optional, tag="62")]
    pub ctwa_per_customer_data_sharing_action: ::core::option::Option<sync_action_value::CtwaPerCustomerDataSharingAction>,
    #[prost(message, optional, tag="63")]
    pub payment_tos_action: ::core::option::Option<sync_action_value::PaymentTosAction>,
}
/// Nested message and enum types in `SyncActionValue`.
pub mod sync_action_value {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AgentAction {
        #[prost(string, optional, tag="1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag="2")]
        pub device_id: ::core::option::Option<i32>,
        #[prost(bool, optional, tag="3")]
        pub is_deleted: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AndroidUnsupportedActions {
        #[prost(bool, optional, tag="1")]
        pub allowed: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ArchiveChatAction {
        #[prost(bool, optional, tag="1")]
        pub archived: ::core::option::Option<bool>,
        #[prost(message, optional, tag="2")]
        pub message_range: ::core::option::Option<SyncActionMessageRange>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BotWelcomeRequestAction {
        #[prost(bool, optional, tag="1")]
        pub is_sent: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CallLogAction {
        #[prost(message, optional, tag="1")]
        pub call_log_record: ::core::option::Option<super::CallLogRecord>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ChatAssignmentAction {
        #[prost(string, optional, tag="1")]
        pub device_agent_id: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ChatAssignmentOpenedStatusAction {
        #[prost(bool, optional, tag="1")]
        pub chat_opened: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClearChatAction {
        #[prost(message, optional, tag="1")]
        pub message_range: ::core::option::Option<SyncActionMessageRange>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ContactAction {
        #[prost(string, optional, tag="1")]
        pub full_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub first_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="3")]
        pub lid_jid: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag="4")]
        pub save_on_primary_addressbook: ::core::option::Option<bool>,
        #[prost(string, optional, tag="5")]
        pub pn_jid: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="6")]
        pub username: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct CtwaPerCustomerDataSharingAction {
        #[prost(bool, optional, tag="1")]
        pub is_ctwa_per_customer_data_sharing_enabled: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CustomPaymentMethod {
        #[prost(string, required, tag="1")]
        pub credential_id: ::prost::alloc::string::String,
        #[prost(string, required, tag="2")]
        pub country: ::prost::alloc::string::String,
        #[prost(string, required, tag="3")]
        pub r#type: ::prost::alloc::string::String,
        #[prost(message, repeated, tag="4")]
        pub metadata: ::prost::alloc::vec::Vec<CustomPaymentMethodMetadata>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct CustomPaymentMethodMetadata {
        #[prost(string, required, tag="1")]
        pub key: ::prost::alloc::string::String,
        #[prost(string, required, tag="2")]
        pub value: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CustomPaymentMethodsAction {
        #[prost(message, repeated, tag="1")]
        pub custom_payment_methods: ::prost::alloc::vec::Vec<CustomPaymentMethod>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeleteChatAction {
        #[prost(message, optional, tag="1")]
        pub message_range: ::core::option::Option<SyncActionMessageRange>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DeleteIndividualCallLogAction {
        #[prost(string, optional, tag="1")]
        pub peer_jid: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag="2")]
        pub is_incoming: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DeleteMessageForMeAction {
        #[prost(bool, optional, tag="1")]
        pub delete_media: ::core::option::Option<bool>,
        #[prost(int64, optional, tag="2")]
        pub message_timestamp: ::core::option::Option<i64>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ExternalWebBetaAction {
        #[prost(bool, optional, tag="1")]
        pub is_opt_in: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FavoritesAction {
        #[prost(message, repeated, tag="1")]
        pub favorites: ::prost::alloc::vec::Vec<favorites_action::Favorite>,
    }
    /// Nested message and enum types in `FavoritesAction`.
    pub mod favorites_action {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Favorite {
            #[prost(string, optional, tag="1")]
            pub id: ::core::option::Option<::prost::alloc::string::String>,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct KeyExpiration {
        #[prost(int32, optional, tag="1")]
        pub expired_key_epoch: ::core::option::Option<i32>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct LabelAssociationAction {
        #[prost(bool, optional, tag="1")]
        pub labeled: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct LabelEditAction {
        #[prost(string, optional, tag="1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag="2")]
        pub color: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="3")]
        pub predefined_id: ::core::option::Option<i32>,
        #[prost(bool, optional, tag="4")]
        pub deleted: ::core::option::Option<bool>,
        #[prost(int32, optional, tag="5")]
        pub order_index: ::core::option::Option<i32>,
        #[prost(bool, optional, tag="6")]
        pub is_active: ::core::option::Option<bool>,
        #[prost(enumeration="label_edit_action::ListType", optional, tag="7")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(bool, optional, tag="8")]
        pub is_immutable: ::core::option::Option<bool>,
    }
    /// Nested message and enum types in `LabelEditAction`.
    pub mod label_edit_action {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum ListType {
            None = 0,
            Unread = 1,
            Groups = 2,
            Favorites = 3,
            Predefined = 4,
            Custom = 5,
            Community = 6,
            ServerAssigned = 7,
        }
        impl ListType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::None => "NONE",
                    Self::Unread => "UNREAD",
                    Self::Groups => "GROUPS",
                    Self::Favorites => "FAVORITES",
                    Self::Predefined => "PREDEFINED",
                    Self::Custom => "CUSTOM",
                    Self::Community => "COMMUNITY",
                    Self::ServerAssigned => "SERVER_ASSIGNED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NONE" => Some(Self::None),
                    "UNREAD" => Some(Self::Unread),
                    "GROUPS" => Some(Self::Groups),
                    "FAVORITES" => Some(Self::Favorites),
                    "PREDEFINED" => Some(Self::Predefined),
                    "CUSTOM" => Some(Self::Custom),
                    "COMMUNITY" => Some(Self::Community),
                    "SERVER_ASSIGNED" => Some(Self::ServerAssigned),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct LabelReorderingAction {
        #[prost(int32, repeated, packed="false", tag="1")]
        pub sorted_label_ids: ::prost::alloc::vec::Vec<i32>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct LidContactAction {
        #[prost(string, optional, tag="1")]
        pub full_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub first_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="3")]
        pub username: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag="4")]
        pub save_on_primary_addressbook: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct LocaleSetting {
        #[prost(string, optional, tag="1")]
        pub locale: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct LockChatAction {
        #[prost(bool, optional, tag="1")]
        pub locked: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MarkChatAsReadAction {
        #[prost(bool, optional, tag="1")]
        pub read: ::core::option::Option<bool>,
        #[prost(message, optional, tag="2")]
        pub message_range: ::core::option::Option<SyncActionMessageRange>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct MarketingMessageAction {
        #[prost(string, optional, tag="1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub message: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration="marketing_message_action::MarketingMessagePrototypeType", optional, tag="3")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(int64, optional, tag="4")]
        pub created_at: ::core::option::Option<i64>,
        #[prost(int64, optional, tag="5")]
        pub last_sent_at: ::core::option::Option<i64>,
        #[prost(bool, optional, tag="6")]
        pub is_deleted: ::core::option::Option<bool>,
        #[prost(string, optional, tag="7")]
        pub media_id: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `MarketingMessageAction`.
    pub mod marketing_message_action {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum MarketingMessagePrototypeType {
            Personalized = 0,
        }
        impl MarketingMessagePrototypeType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Personalized => "PERSONALIZED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PERSONALIZED" => Some(Self::Personalized),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct MarketingMessageBroadcastAction {
        #[prost(int32, optional, tag="1")]
        pub replied_count: ::core::option::Option<i32>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct MerchantPaymentPartnerAction {
        #[prost(enumeration="merchant_payment_partner_action::Status", required, tag="1")]
        pub status: i32,
        #[prost(string, required, tag="2")]
        pub country: ::prost::alloc::string::String,
        #[prost(string, optional, tag="3")]
        pub gateway_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="4")]
        pub credential_id: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `MerchantPaymentPartnerAction`.
    pub mod merchant_payment_partner_action {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum Status {
            Active = 0,
            Inactive = 1,
        }
        impl Status {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Active => "ACTIVE",
                    Self::Inactive => "INACTIVE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ACTIVE" => Some(Self::Active),
                    "INACTIVE" => Some(Self::Inactive),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct MuteAction {
        #[prost(bool, optional, tag="1")]
        pub muted: ::core::option::Option<bool>,
        #[prost(int64, optional, tag="2")]
        pub mute_end_timestamp: ::core::option::Option<i64>,
        #[prost(bool, optional, tag="3")]
        pub auto_muted: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct NoteEditAction {
        #[prost(enumeration="note_edit_action::NoteType", optional, tag="1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag="2")]
        pub chat_jid: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int64, optional, tag="3")]
        pub created_at: ::core::option::Option<i64>,
        #[prost(bool, optional, tag="4")]
        pub deleted: ::core::option::Option<bool>,
        #[prost(string, optional, tag="5")]
        pub unstructured_content: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `NoteEditAction`.
    pub mod note_edit_action {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum NoteType {
            Unstructured = 1,
            Structured = 2,
        }
        impl NoteType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unstructured => "UNSTRUCTURED",
                    Self::Structured => "STRUCTURED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSTRUCTURED" => Some(Self::Unstructured),
                    "STRUCTURED" => Some(Self::Structured),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct NotificationActivitySettingAction {
        #[prost(enumeration="notification_activity_setting_action::NotificationActivitySetting", optional, tag="1")]
        pub notification_activity_setting: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `NotificationActivitySettingAction`.
    pub mod notification_activity_setting_action {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum NotificationActivitySetting {
            DefaultAllMessages = 0,
            AllMessages = 1,
            Highlights = 2,
            DefaultHighlights = 3,
        }
        impl NotificationActivitySetting {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::DefaultAllMessages => "DEFAULT_ALL_MESSAGES",
                    Self::AllMessages => "ALL_MESSAGES",
                    Self::Highlights => "HIGHLIGHTS",
                    Self::DefaultHighlights => "DEFAULT_HIGHLIGHTS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DEFAULT_ALL_MESSAGES" => Some(Self::DefaultAllMessages),
                    "ALL_MESSAGES" => Some(Self::AllMessages),
                    "HIGHLIGHTS" => Some(Self::Highlights),
                    "DEFAULT_HIGHLIGHTS" => Some(Self::DefaultHighlights),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct NuxAction {
        #[prost(bool, optional, tag="1")]
        pub acknowledged: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PaymentInfoAction {
        #[prost(string, optional, tag="1")]
        pub cpi: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PaymentTosAction {
        #[prost(enumeration="payment_tos_action::PaymentNotice", required, tag="1")]
        pub payment_notice: i32,
        #[prost(bool, required, tag="2")]
        pub accepted: bool,
    }
    /// Nested message and enum types in `PaymentTosAction`.
    pub mod payment_tos_action {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum PaymentNotice {
            BrPayPrivacyPolicy = 0,
        }
        impl PaymentNotice {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::BrPayPrivacyPolicy => "BR_PAY_PRIVACY_POLICY",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "BR_PAY_PRIVACY_POLICY" => Some(Self::BrPayPrivacyPolicy),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PinAction {
        #[prost(bool, optional, tag="1")]
        pub pinned: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PnForLidChatAction {
        #[prost(string, optional, tag="1")]
        pub pn_jid: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PrimaryFeature {
        #[prost(string, repeated, tag="1")]
        pub flags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PrimaryVersionAction {
        #[prost(string, optional, tag="1")]
        pub version: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PrivacySettingDisableLinkPreviewsAction {
        #[prost(bool, optional, tag="1")]
        pub is_previews_disabled: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PrivacySettingRelayAllCalls {
        #[prost(bool, optional, tag="1")]
        pub is_enabled: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PushNameSetting {
        #[prost(string, optional, tag="1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct QuickReplyAction {
        #[prost(string, optional, tag="1")]
        pub shortcut: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub message: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, repeated, tag="3")]
        pub keywords: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(int32, optional, tag="4")]
        pub count: ::core::option::Option<i32>,
        #[prost(bool, optional, tag="5")]
        pub deleted: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RecentEmojiWeightsAction {
        #[prost(message, repeated, tag="1")]
        pub weights: ::prost::alloc::vec::Vec<super::RecentEmojiWeight>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct RemoveRecentStickerAction {
        #[prost(int64, optional, tag="1")]
        pub last_sticker_sent_ts: ::core::option::Option<i64>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SecurityNotificationSetting {
        #[prost(bool, optional, tag="1")]
        pub show_notification: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct StarAction {
        #[prost(bool, optional, tag="1")]
        pub starred: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct StatusPrivacyAction {
        #[prost(enumeration="status_privacy_action::StatusDistributionMode", optional, tag="1")]
        pub mode: ::core::option::Option<i32>,
        #[prost(string, repeated, tag="2")]
        pub user_jid: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `StatusPrivacyAction`.
    pub mod status_privacy_action {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum StatusDistributionMode {
            AllowList = 0,
            DenyList = 1,
            Contacts = 2,
        }
        impl StatusDistributionMode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::AllowList => "ALLOW_LIST",
                    Self::DenyList => "DENY_LIST",
                    Self::Contacts => "CONTACTS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ALLOW_LIST" => Some(Self::AllowList),
                    "DENY_LIST" => Some(Self::DenyList),
                    "CONTACTS" => Some(Self::Contacts),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct StickerAction {
        #[prost(string, optional, tag="1")]
        pub url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="vec", optional, tag="2")]
        pub file_enc_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes="vec", optional, tag="3")]
        pub media_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag="4")]
        pub mimetype: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag="5")]
        pub height: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="6")]
        pub width: ::core::option::Option<u32>,
        #[prost(string, optional, tag="7")]
        pub direct_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint64, optional, tag="8")]
        pub file_length: ::core::option::Option<u64>,
        #[prost(bool, optional, tag="9")]
        pub is_favorite: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag="10")]
        pub device_id_hint: ::core::option::Option<u32>,
        #[prost(bool, optional, tag="11")]
        pub is_lottie: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SubscriptionAction {
        #[prost(bool, optional, tag="1")]
        pub is_deactivated: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="2")]
        pub is_auto_renewing: ::core::option::Option<bool>,
        #[prost(int64, optional, tag="3")]
        pub expiration_date: ::core::option::Option<i64>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SyncActionMessage {
        #[prost(message, optional, tag="1")]
        pub key: ::core::option::Option<super::MessageKey>,
        #[prost(int64, optional, tag="2")]
        pub timestamp: ::core::option::Option<i64>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SyncActionMessageRange {
        #[prost(int64, optional, tag="1")]
        pub last_message_timestamp: ::core::option::Option<i64>,
        #[prost(int64, optional, tag="2")]
        pub last_system_message_timestamp: ::core::option::Option<i64>,
        #[prost(message, repeated, tag="3")]
        pub messages: ::prost::alloc::vec::Vec<SyncActionMessage>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct TimeFormatAction {
        #[prost(bool, optional, tag="1")]
        pub is_twenty_four_hour_format_enabled: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct UnarchiveChatsSetting {
        #[prost(bool, optional, tag="1")]
        pub unarchive_chats: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct UserStatusMuteAction {
        #[prost(bool, optional, tag="1")]
        pub muted: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct UsernameChatStartModeAction {
        #[prost(enumeration="username_chat_start_mode_action::ChatStartMode", optional, tag="1")]
        pub chat_start_mode: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `UsernameChatStartModeAction`.
    pub mod username_chat_start_mode_action {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum ChatStartMode {
            Lid = 1,
            Pn = 2,
        }
        impl ChatStartMode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Lid => "LID",
                    Self::Pn => "PN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "LID" => Some(Self::Lid),
                    "PN" => Some(Self::Pn),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct WaffleAccountLinkStateAction {
        #[prost(enumeration="waffle_account_link_state_action::AccountLinkState", optional, tag="2")]
        pub link_state: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `WaffleAccountLinkStateAction`.
    pub mod waffle_account_link_state_action {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum AccountLinkState {
            Active = 0,
        }
        impl AccountLinkState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Active => "ACTIVE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ACTIVE" => Some(Self::Active),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct WamoUserIdentifierAction {
        #[prost(string, optional, tag="1")]
        pub identifier: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncdIndex {
    #[prost(bytes="vec", optional, tag="1")]
    pub blob: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncdMutation {
    #[prost(enumeration="syncd_mutation::SyncdOperation", optional, tag="1")]
    pub operation: ::core::option::Option<i32>,
    #[prost(message, optional, tag="2")]
    pub record: ::core::option::Option<SyncdRecord>,
}
/// Nested message and enum types in `SyncdMutation`.
pub mod syncd_mutation {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SyncdOperation {
        Set = 0,
        Remove = 1,
    }
    impl SyncdOperation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Set => "SET",
                Self::Remove => "REMOVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SET" => Some(Self::Set),
                "REMOVE" => Some(Self::Remove),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncdMutations {
    #[prost(message, repeated, tag="1")]
    pub mutations: ::prost::alloc::vec::Vec<SyncdMutation>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncdPatch {
    #[prost(message, optional, tag="1")]
    pub version: ::core::option::Option<SyncdVersion>,
    #[prost(message, repeated, tag="2")]
    pub mutations: ::prost::alloc::vec::Vec<SyncdMutation>,
    #[prost(message, optional, tag="3")]
    pub external_mutations: ::core::option::Option<ExternalBlobReference>,
    #[prost(bytes="vec", optional, tag="4")]
    pub snapshot_mac: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="5")]
    pub patch_mac: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag="6")]
    pub key_id: ::core::option::Option<KeyId>,
    #[prost(message, optional, tag="7")]
    pub exit_code: ::core::option::Option<ExitCode>,
    #[prost(uint32, optional, tag="8")]
    pub device_index: ::core::option::Option<u32>,
    #[prost(bytes="vec", optional, tag="9")]
    pub client_debug_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncdRecord {
    #[prost(message, optional, tag="1")]
    pub index: ::core::option::Option<SyncdIndex>,
    #[prost(message, optional, tag="2")]
    pub value: ::core::option::Option<SyncdValue>,
    #[prost(message, optional, tag="3")]
    pub key_id: ::core::option::Option<KeyId>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncdSnapshot {
    #[prost(message, optional, tag="1")]
    pub version: ::core::option::Option<SyncdVersion>,
    #[prost(message, repeated, tag="2")]
    pub records: ::prost::alloc::vec::Vec<SyncdRecord>,
    #[prost(bytes="vec", optional, tag="3")]
    pub mac: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag="4")]
    pub key_id: ::core::option::Option<KeyId>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncdValue {
    #[prost(bytes="vec", optional, tag="1")]
    pub blob: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncdVersion {
    #[prost(uint64, optional, tag="1")]
    pub version: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TapLinkAction {
    #[prost(string, optional, tag="1")]
    pub title: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub tap_url: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplateButton {
    #[prost(uint32, optional, tag="4")]
    pub index: ::core::option::Option<u32>,
    #[prost(oneof="template_button::Button", tags="1, 2, 3")]
    pub button: ::core::option::Option<template_button::Button>,
}
/// Nested message and enum types in `TemplateButton`.
pub mod template_button {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CallButton {
        #[prost(message, optional, tag="1")]
        pub display_text: ::core::option::Option<super::message::HighlyStructuredMessage>,
        #[prost(message, optional, tag="2")]
        pub phone_number: ::core::option::Option<super::message::HighlyStructuredMessage>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QuickReplyButton {
        #[prost(message, optional, tag="1")]
        pub display_text: ::core::option::Option<super::message::HighlyStructuredMessage>,
        #[prost(string, optional, tag="2")]
        pub id: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UrlButton {
        #[prost(message, optional, tag="1")]
        pub display_text: ::core::option::Option<super::message::HighlyStructuredMessage>,
        #[prost(message, optional, tag="2")]
        pub url: ::core::option::Option<super::message::HighlyStructuredMessage>,
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Button {
        #[prost(message, tag="1")]
        QuickReplyButton(QuickReplyButton),
        #[prost(message, tag="2")]
        UrlButton(UrlButton),
        #[prost(message, tag="3")]
        CallButton(CallButton),
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlTrackingMap {
    #[prost(message, repeated, tag="1")]
    pub url_tracking_map_elements: ::prost::alloc::vec::Vec<url_tracking_map::UrlTrackingMapElement>,
}
/// Nested message and enum types in `UrlTrackingMap`.
pub mod url_tracking_map {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct UrlTrackingMapElement {
        #[prost(string, optional, tag="1")]
        pub original_url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub unconsented_users_url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="3")]
        pub consented_users_url: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag="4")]
        pub card_index: ::core::option::Option<u32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserPassword {
    #[prost(enumeration="user_password::Encoding", optional, tag="1")]
    pub encoding: ::core::option::Option<i32>,
    #[prost(enumeration="user_password::Transformer", optional, tag="2")]
    pub transformer: ::core::option::Option<i32>,
    #[prost(message, repeated, tag="3")]
    pub transformer_arg: ::prost::alloc::vec::Vec<user_password::TransformerArg>,
    #[prost(bytes="vec", optional, tag="4")]
    pub transformed_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `UserPassword`.
pub mod user_password {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct TransformerArg {
        #[prost(string, optional, tag="1")]
        pub key: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, tag="2")]
        pub value: ::core::option::Option<transformer_arg::Value>,
    }
    /// Nested message and enum types in `TransformerArg`.
    pub mod transformer_arg {
        #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Value {
            #[prost(oneof="value::Value", tags="1, 2")]
            pub value: ::core::option::Option<value::Value>,
        }
        /// Nested message and enum types in `Value`.
        pub mod value {
            #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
            pub enum Value {
                #[prost(bytes, tag="1")]
                AsBlob(::prost::alloc::vec::Vec<u8>),
                #[prost(uint32, tag="2")]
                AsUnsignedInteger(u32),
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Encoding {
        Utf8 = 0,
        Utf8Broken = 1,
    }
    impl Encoding {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Utf8 => "UTF8",
                Self::Utf8Broken => "UTF8_BROKEN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UTF8" => Some(Self::Utf8),
                "UTF8_BROKEN" => Some(Self::Utf8Broken),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Transformer {
        None = 0,
        Pbkdf2HmacSha512 = 1,
        Pbkdf2HmacSha384 = 2,
    }
    impl Transformer {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Pbkdf2HmacSha512 => "PBKDF2_HMAC_SHA512",
                Self::Pbkdf2HmacSha384 => "PBKDF2_HMAC_SHA384",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "PBKDF2_HMAC_SHA512" => Some(Self::Pbkdf2HmacSha512),
                "PBKDF2_HMAC_SHA384" => Some(Self::Pbkdf2HmacSha384),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserReceipt {
    #[prost(string, required, tag="1")]
    pub user_jid: ::prost::alloc::string::String,
    #[prost(int64, optional, tag="2")]
    pub receipt_timestamp: ::core::option::Option<i64>,
    #[prost(int64, optional, tag="3")]
    pub read_timestamp: ::core::option::Option<i64>,
    #[prost(int64, optional, tag="4")]
    pub played_timestamp: ::core::option::Option<i64>,
    #[prost(string, repeated, tag="5")]
    pub pending_device_jid: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="6")]
    pub delivered_device_jid: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VerifiedNameCertificate {
    #[prost(bytes="vec", optional, tag="1")]
    pub details: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="2")]
    pub signature: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="3")]
    pub server_signature: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `VerifiedNameCertificate`.
pub mod verified_name_certificate {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Details {
        #[prost(uint64, optional, tag="1")]
        pub serial: ::core::option::Option<u64>,
        #[prost(string, optional, tag="2")]
        pub issuer: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="4")]
        pub verified_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="8")]
        pub localized_names: ::prost::alloc::vec::Vec<super::LocalizedName>,
        #[prost(uint64, optional, tag="10")]
        pub issue_time: ::core::option::Option<u64>,
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WallpaperSettings {
    #[prost(string, optional, tag="1")]
    pub filename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="2")]
    pub opacity: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WebFeatures {
    #[prost(enumeration="web_features::Flag", optional, tag="1")]
    pub labels_display: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="2")]
    pub voip_individual_outgoing: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="3")]
    pub groups_v3: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="4")]
    pub groups_v3_create: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="5")]
    pub change_number_v2: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="6")]
    pub query_status_v3_thumbnail: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="7")]
    pub live_locations: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="8")]
    pub query_vname: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="9")]
    pub voip_individual_incoming: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="10")]
    pub quick_replies_query: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="11")]
    pub payments: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="12")]
    pub sticker_pack_query: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="13")]
    pub live_locations_final: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="14")]
    pub labels_edit: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="15")]
    pub media_upload: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="18")]
    pub media_upload_rich_quick_replies: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="19")]
    pub vname_v2: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="20")]
    pub video_playback_url: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="21")]
    pub status_ranking: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="22")]
    pub voip_individual_video: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="23")]
    pub third_party_stickers: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="24")]
    pub frequently_forwarded_setting: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="25")]
    pub groups_v4_join_permission: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="26")]
    pub recent_stickers: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="27")]
    pub catalog: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="28")]
    pub starred_stickers: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="29")]
    pub voip_group_call: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="30")]
    pub template_message: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="31")]
    pub template_message_interactivity: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="32")]
    pub ephemeral_messages: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="33")]
    pub e2_e_notification_sync: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="34")]
    pub recent_stickers_v2: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="36")]
    pub recent_stickers_v3: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="37")]
    pub user_notice: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="39")]
    pub support: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="40")]
    pub group_uii_cleanup: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="41")]
    pub group_dogfooding_internal_only: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="42")]
    pub settings_sync: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="43")]
    pub archive_v2: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="44")]
    pub ephemeral_allow_group_members: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="45")]
    pub ephemeral24_h_duration: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="46")]
    pub md_force_upgrade: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="47")]
    pub disappearing_mode: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="48")]
    pub external_md_opt_in_available: ::core::option::Option<i32>,
    #[prost(enumeration="web_features::Flag", optional, tag="49")]
    pub no_delete_message_time_limit: ::core::option::Option<i32>,
}
/// Nested message and enum types in `WebFeatures`.
pub mod web_features {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Flag {
        NotStarted = 0,
        ForceUpgrade = 1,
        Development = 2,
        Production = 3,
    }
    impl Flag {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::NotStarted => "NOT_STARTED",
                Self::ForceUpgrade => "FORCE_UPGRADE",
                Self::Development => "DEVELOPMENT",
                Self::Production => "PRODUCTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NOT_STARTED" => Some(Self::NotStarted),
                "FORCE_UPGRADE" => Some(Self::ForceUpgrade),
                "DEVELOPMENT" => Some(Self::Development),
                "PRODUCTION" => Some(Self::Production),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebMessageInfo {
    #[prost(message, required, tag="1")]
    pub key: MessageKey,
    #[prost(message, optional, tag="2")]
    pub message: ::core::option::Option<Message>,
    #[prost(uint64, optional, tag="3")]
    pub message_timestamp: ::core::option::Option<u64>,
    #[prost(enumeration="web_message_info::Status", optional, tag="4")]
    pub status: ::core::option::Option<i32>,
    #[prost(string, optional, tag="5")]
    pub participant: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag="6")]
    pub message_c2s_timestamp: ::core::option::Option<u64>,
    #[prost(bool, optional, tag="16")]
    pub ignore: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="17")]
    pub starred: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="18")]
    pub broadcast: ::core::option::Option<bool>,
    #[prost(string, optional, tag="19")]
    pub push_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="vec", optional, tag="20")]
    pub media_ciphertext_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag="21")]
    pub multicast: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="22")]
    pub url_text: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="23")]
    pub url_number: ::core::option::Option<bool>,
    #[prost(enumeration="web_message_info::StubType", optional, tag="24")]
    pub message_stub_type: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="25")]
    pub clear_media: ::core::option::Option<bool>,
    #[prost(string, repeated, tag="26")]
    pub message_stub_parameters: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="27")]
    pub duration: ::core::option::Option<u32>,
    #[prost(string, repeated, tag="28")]
    pub labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag="29")]
    pub payment_info: ::core::option::Option<PaymentInfo>,
    #[prost(message, optional, tag="30")]
    pub final_live_location: ::core::option::Option<message::LiveLocationMessage>,
    #[prost(message, optional, tag="31")]
    pub quoted_payment_info: ::core::option::Option<PaymentInfo>,
    #[prost(uint64, optional, tag="32")]
    pub ephemeral_start_timestamp: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="33")]
    pub ephemeral_duration: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="34")]
    pub ephemeral_off_to_on: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="35")]
    pub ephemeral_out_of_sync: ::core::option::Option<bool>,
    #[prost(enumeration="web_message_info::BizPrivacyStatus", optional, tag="36")]
    pub biz_privacy_status: ::core::option::Option<i32>,
    #[prost(string, optional, tag="37")]
    pub verified_biz_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="38")]
    pub media_data: ::core::option::Option<MediaData>,
    #[prost(message, optional, tag="39")]
    pub photo_change: ::core::option::Option<PhotoChange>,
    #[prost(message, repeated, tag="40")]
    pub user_receipt: ::prost::alloc::vec::Vec<UserReceipt>,
    #[prost(message, repeated, tag="41")]
    pub reactions: ::prost::alloc::vec::Vec<Reaction>,
    #[prost(message, optional, tag="42")]
    pub quoted_sticker_data: ::core::option::Option<MediaData>,
    #[prost(bytes="vec", optional, tag="43")]
    pub futureproof_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag="44")]
    pub status_psa: ::core::option::Option<StatusPsa>,
    #[prost(message, repeated, tag="45")]
    pub poll_updates: ::prost::alloc::vec::Vec<PollUpdate>,
    #[prost(message, optional, tag="46")]
    pub poll_additional_metadata: ::core::option::Option<PollAdditionalMetadata>,
    #[prost(string, optional, tag="47")]
    pub agent_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="48")]
    pub status_already_viewed: ::core::option::Option<bool>,
    #[prost(bytes="vec", optional, tag="49")]
    pub message_secret: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag="50")]
    pub keep_in_chat: ::core::option::Option<KeepInChat>,
    #[prost(string, optional, tag="51")]
    pub original_self_author_user_jid_string: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag="52")]
    pub revoke_message_timestamp: ::core::option::Option<u64>,
    #[prost(message, optional, tag="54")]
    pub pin_in_chat: ::core::option::Option<PinInChat>,
    #[prost(message, optional, tag="55")]
    pub premium_message_info: ::core::option::Option<PremiumMessageInfo>,
    #[prost(bool, optional, tag="56")]
    pub is1_p_biz_bot_message: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="57")]
    pub is_group_history_message: ::core::option::Option<bool>,
    #[prost(string, optional, tag="58")]
    pub bot_message_invoker_jid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="59")]
    pub comment_metadata: ::core::option::Option<CommentMetadata>,
    #[prost(message, repeated, tag="61")]
    pub event_responses: ::prost::alloc::vec::Vec<EventResponse>,
    #[prost(message, optional, tag="62")]
    pub reporting_token_info: ::core::option::Option<ReportingTokenInfo>,
    #[prost(uint64, optional, tag="63")]
    pub newsletter_server_id: ::core::option::Option<u64>,
    #[prost(message, optional, tag="64")]
    pub event_additional_metadata: ::core::option::Option<EventAdditionalMetadata>,
    #[prost(bool, optional, tag="65")]
    pub is_mentioned_in_status: ::core::option::Option<bool>,
    #[prost(string, repeated, tag="66")]
    pub status_mentions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag="67")]
    pub target_message_id: ::core::option::Option<MessageKey>,
    #[prost(message, repeated, tag="68")]
    pub message_add_ons: ::prost::alloc::vec::Vec<MessageAddOn>,
    #[prost(message, optional, tag="69")]
    pub status_mention_message_info: ::core::option::Option<StatusMentionMessage>,
    #[prost(bool, optional, tag="70")]
    pub is_support_ai_message: ::core::option::Option<bool>,
    #[prost(string, repeated, tag="71")]
    pub status_mention_sources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="72")]
    pub support_ai_citations: ::prost::alloc::vec::Vec<Citation>,
    #[prost(string, optional, tag="73")]
    pub bot_target_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `WebMessageInfo`.
pub mod web_message_info {
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum BizPrivacyStatus {
        E2ee = 0,
        Fb = 2,
        Bsp = 1,
        BspAndFb = 3,
    }
    impl BizPrivacyStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::E2ee => "E2EE",
                Self::Fb => "FB",
                Self::Bsp => "BSP",
                Self::BspAndFb => "BSP_AND_FB",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "E2EE" => Some(Self::E2ee),
                "FB" => Some(Self::Fb),
                "BSP" => Some(Self::Bsp),
                "BSP_AND_FB" => Some(Self::BspAndFb),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Status {
        Error = 0,
        Pending = 1,
        ServerAck = 2,
        DeliveryAck = 3,
        Read = 4,
        Played = 5,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Error => "ERROR",
                Self::Pending => "PENDING",
                Self::ServerAck => "SERVER_ACK",
                Self::DeliveryAck => "DELIVERY_ACK",
                Self::Read => "READ",
                Self::Played => "PLAYED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ERROR" => Some(Self::Error),
                "PENDING" => Some(Self::Pending),
                "SERVER_ACK" => Some(Self::ServerAck),
                "DELIVERY_ACK" => Some(Self::DeliveryAck),
                "READ" => Some(Self::Read),
                "PLAYED" => Some(Self::Played),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum StubType {
        Unknown = 0,
        Revoke = 1,
        Ciphertext = 2,
        Futureproof = 3,
        NonVerifiedTransition = 4,
        UnverifiedTransition = 5,
        VerifiedTransition = 6,
        VerifiedLowUnknown = 7,
        VerifiedHigh = 8,
        VerifiedInitialUnknown = 9,
        VerifiedInitialLow = 10,
        VerifiedInitialHigh = 11,
        VerifiedTransitionAnyToNone = 12,
        VerifiedTransitionAnyToHigh = 13,
        VerifiedTransitionHighToLow = 14,
        VerifiedTransitionHighToUnknown = 15,
        VerifiedTransitionUnknownToLow = 16,
        VerifiedTransitionLowToUnknown = 17,
        VerifiedTransitionNoneToLow = 18,
        VerifiedTransitionNoneToUnknown = 19,
        GroupCreate = 20,
        GroupChangeSubject = 21,
        GroupChangeIcon = 22,
        GroupChangeInviteLink = 23,
        GroupChangeDescription = 24,
        GroupChangeRestrict = 25,
        GroupChangeAnnounce = 26,
        GroupParticipantAdd = 27,
        GroupParticipantRemove = 28,
        GroupParticipantPromote = 29,
        GroupParticipantDemote = 30,
        GroupParticipantInvite = 31,
        GroupParticipantLeave = 32,
        GroupParticipantChangeNumber = 33,
        BroadcastCreate = 34,
        BroadcastAdd = 35,
        BroadcastRemove = 36,
        GenericNotification = 37,
        E2eIdentityChanged = 38,
        E2eEncrypted = 39,
        CallMissedVoice = 40,
        CallMissedVideo = 41,
        IndividualChangeNumber = 42,
        GroupDelete = 43,
        GroupAnnounceModeMessageBounce = 44,
        CallMissedGroupVoice = 45,
        CallMissedGroupVideo = 46,
        PaymentCiphertext = 47,
        PaymentFutureproof = 48,
        PaymentTransactionStatusUpdateFailed = 49,
        PaymentTransactionStatusUpdateRefunded = 50,
        PaymentTransactionStatusUpdateRefundFailed = 51,
        PaymentTransactionStatusReceiverPendingSetup = 52,
        PaymentTransactionStatusReceiverSuccessAfterHiccup = 53,
        PaymentActionAccountSetupReminder = 54,
        PaymentActionSendPaymentReminder = 55,
        PaymentActionSendPaymentInvitation = 56,
        PaymentActionRequestDeclined = 57,
        PaymentActionRequestExpired = 58,
        PaymentActionRequestCancelled = 59,
        BizVerifiedTransitionTopToBottom = 60,
        BizVerifiedTransitionBottomToTop = 61,
        BizIntroTop = 62,
        BizIntroBottom = 63,
        BizNameChange = 64,
        BizMoveToConsumerApp = 65,
        BizTwoTierMigrationTop = 66,
        BizTwoTierMigrationBottom = 67,
        Oversized = 68,
        GroupChangeNoFrequentlyForwarded = 69,
        GroupV4AddInviteSent = 70,
        GroupParticipantAddRequestJoin = 71,
        ChangeEphemeralSetting = 72,
        E2eDeviceChanged = 73,
        ViewedOnce = 74,
        E2eEncryptedNow = 75,
        BlueMsgBspFbToBspPremise = 76,
        BlueMsgBspFbToSelfFb = 77,
        BlueMsgBspFbToSelfPremise = 78,
        BlueMsgBspFbUnverified = 79,
        BlueMsgBspFbUnverifiedToSelfPremiseVerified = 80,
        BlueMsgBspFbVerified = 81,
        BlueMsgBspFbVerifiedToSelfPremiseUnverified = 82,
        BlueMsgBspPremiseToSelfPremise = 83,
        BlueMsgBspPremiseUnverified = 84,
        BlueMsgBspPremiseUnverifiedToSelfPremiseVerified = 85,
        BlueMsgBspPremiseVerified = 86,
        BlueMsgBspPremiseVerifiedToSelfPremiseUnverified = 87,
        BlueMsgConsumerToBspFbUnverified = 88,
        BlueMsgConsumerToBspPremiseUnverified = 89,
        BlueMsgConsumerToSelfFbUnverified = 90,
        BlueMsgConsumerToSelfPremiseUnverified = 91,
        BlueMsgSelfFbToBspPremise = 92,
        BlueMsgSelfFbToSelfPremise = 93,
        BlueMsgSelfFbUnverified = 94,
        BlueMsgSelfFbUnverifiedToSelfPremiseVerified = 95,
        BlueMsgSelfFbVerified = 96,
        BlueMsgSelfFbVerifiedToSelfPremiseUnverified = 97,
        BlueMsgSelfPremiseToBspPremise = 98,
        BlueMsgSelfPremiseUnverified = 99,
        BlueMsgSelfPremiseVerified = 100,
        BlueMsgToBspFb = 101,
        BlueMsgToConsumer = 102,
        BlueMsgToSelfFb = 103,
        BlueMsgUnverifiedToBspFbVerified = 104,
        BlueMsgUnverifiedToBspPremiseVerified = 105,
        BlueMsgUnverifiedToSelfFbVerified = 106,
        BlueMsgUnverifiedToVerified = 107,
        BlueMsgVerifiedToBspFbUnverified = 108,
        BlueMsgVerifiedToBspPremiseUnverified = 109,
        BlueMsgVerifiedToSelfFbUnverified = 110,
        BlueMsgVerifiedToUnverified = 111,
        BlueMsgBspFbUnverifiedToBspPremiseVerified = 112,
        BlueMsgBspFbUnverifiedToSelfFbVerified = 113,
        BlueMsgBspFbVerifiedToBspPremiseUnverified = 114,
        BlueMsgBspFbVerifiedToSelfFbUnverified = 115,
        BlueMsgSelfFbUnverifiedToBspPremiseVerified = 116,
        BlueMsgSelfFbVerifiedToBspPremiseUnverified = 117,
        E2eIdentityUnavailable = 118,
        GroupCreating = 119,
        GroupCreateFailed = 120,
        GroupBounced = 121,
        BlockContact = 122,
        EphemeralSettingNotApplied = 123,
        SyncFailed = 124,
        Syncing = 125,
        BizPrivacyModeInitFb = 126,
        BizPrivacyModeInitBsp = 127,
        BizPrivacyModeToFb = 128,
        BizPrivacyModeToBsp = 129,
        DisappearingMode = 130,
        E2eDeviceFetchFailed = 131,
        AdminRevoke = 132,
        GroupInviteLinkGrowthLocked = 133,
        CommunityLinkParentGroup = 134,
        CommunityLinkSiblingGroup = 135,
        CommunityLinkSubGroup = 136,
        CommunityUnlinkParentGroup = 137,
        CommunityUnlinkSiblingGroup = 138,
        CommunityUnlinkSubGroup = 139,
        GroupParticipantAccept = 140,
        GroupParticipantLinkedGroupJoin = 141,
        CommunityCreate = 142,
        EphemeralKeepInChat = 143,
        GroupMembershipJoinApprovalRequest = 144,
        GroupMembershipJoinApprovalMode = 145,
        IntegrityUnlinkParentGroup = 146,
        CommunityParticipantPromote = 147,
        CommunityParticipantDemote = 148,
        CommunityParentGroupDeleted = 149,
        CommunityLinkParentGroupMembershipApproval = 150,
        GroupParticipantJoinedGroupAndParentGroup = 151,
        MaskedThreadCreated = 152,
        MaskedThreadUnmasked = 153,
        BizChatAssignment = 154,
        ChatPsa = 155,
        ChatPollCreationMessage = 156,
        CagMaskedThreadCreated = 157,
        CommunityParentGroupSubjectChanged = 158,
        CagInviteAutoAdd = 159,
        BizChatAssignmentUnassign = 160,
        CagInviteAutoJoined = 161,
        ScheduledCallStartMessage = 162,
        CommunityInviteRich = 163,
        CommunityInviteAutoAddRich = 164,
        SubGroupInviteRich = 165,
        SubGroupParticipantAddRich = 166,
        CommunityLinkParentGroupRich = 167,
        CommunityParticipantAddRich = 168,
        SilencedUnknownCallerAudio = 169,
        SilencedUnknownCallerVideo = 170,
        GroupMemberAddMode = 171,
        GroupMembershipJoinApprovalRequestNonAdminAdd = 172,
        CommunityChangeDescription = 173,
        SenderInvite = 174,
        ReceiverInvite = 175,
        CommunityAllowMemberAddedGroups = 176,
        PinnedMessageInChat = 177,
        PaymentInviteSetupInviter = 178,
        PaymentInviteSetupInviteeReceiveOnly = 179,
        PaymentInviteSetupInviteeSendAndReceive = 180,
        LinkedGroupCallStart = 181,
        ReportToAdminEnabledStatus = 182,
        EmptySubgroupCreate = 183,
        ScheduledCallCancel = 184,
        SubgroupAdminTriggeredAutoAddRich = 185,
        GroupChangeRecentHistorySharing = 186,
        PaidMessageServerCampaignId = 187,
        GeneralChatCreate = 188,
        GeneralChatAdd = 189,
        GeneralChatAutoAddDisabled = 190,
        SuggestedSubgroupAnnounce = 191,
        BizBot1pMessagingEnabled = 192,
        ChangeUsername = 193,
        BizCoexPrivacyInitSelf = 194,
        BizCoexPrivacyTransitionSelf = 195,
        SupportAiEducation = 196,
        BizBot3pMessagingEnabled = 197,
        ReminderSetupMessage = 198,
        ReminderSentMessage = 199,
        ReminderCancelMessage = 200,
        BizCoexPrivacyInit = 201,
        BizCoexPrivacyTransition = 202,
        GroupDeactivated = 203,
        CommunityDeactivateSiblingGroup = 204,
        EventUpdated = 205,
        EventCanceled = 206,
        CommunityOwnerUpdated = 207,
        CommunitySubGroupVisibilityHidden = 208,
        CapiGroupNe2eeSystemMessage = 209,
        StatusMention = 210,
        UserControlsSystemMessage = 211,
        SupportSystemMessage = 212,
        ChangeLid = 213,
        BizCustomer3pdDataSharingOptInMessage = 214,
        BizCustomer3pdDataSharingOptOutMessage = 215,
        ChangeLimitSharing = 216,
        GroupMemberLinkMode = 217,
        BizAutomaticallyLabeledChatSystemMessage = 218,
    }
    impl StubType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Revoke => "REVOKE",
                Self::Ciphertext => "CIPHERTEXT",
                Self::Futureproof => "FUTUREPROOF",
                Self::NonVerifiedTransition => "NON_VERIFIED_TRANSITION",
                Self::UnverifiedTransition => "UNVERIFIED_TRANSITION",
                Self::VerifiedTransition => "VERIFIED_TRANSITION",
                Self::VerifiedLowUnknown => "VERIFIED_LOW_UNKNOWN",
                Self::VerifiedHigh => "VERIFIED_HIGH",
                Self::VerifiedInitialUnknown => "VERIFIED_INITIAL_UNKNOWN",
                Self::VerifiedInitialLow => "VERIFIED_INITIAL_LOW",
                Self::VerifiedInitialHigh => "VERIFIED_INITIAL_HIGH",
                Self::VerifiedTransitionAnyToNone => "VERIFIED_TRANSITION_ANY_TO_NONE",
                Self::VerifiedTransitionAnyToHigh => "VERIFIED_TRANSITION_ANY_TO_HIGH",
                Self::VerifiedTransitionHighToLow => "VERIFIED_TRANSITION_HIGH_TO_LOW",
                Self::VerifiedTransitionHighToUnknown => "VERIFIED_TRANSITION_HIGH_TO_UNKNOWN",
                Self::VerifiedTransitionUnknownToLow => "VERIFIED_TRANSITION_UNKNOWN_TO_LOW",
                Self::VerifiedTransitionLowToUnknown => "VERIFIED_TRANSITION_LOW_TO_UNKNOWN",
                Self::VerifiedTransitionNoneToLow => "VERIFIED_TRANSITION_NONE_TO_LOW",
                Self::VerifiedTransitionNoneToUnknown => "VERIFIED_TRANSITION_NONE_TO_UNKNOWN",
                Self::GroupCreate => "GROUP_CREATE",
                Self::GroupChangeSubject => "GROUP_CHANGE_SUBJECT",
                Self::GroupChangeIcon => "GROUP_CHANGE_ICON",
                Self::GroupChangeInviteLink => "GROUP_CHANGE_INVITE_LINK",
                Self::GroupChangeDescription => "GROUP_CHANGE_DESCRIPTION",
                Self::GroupChangeRestrict => "GROUP_CHANGE_RESTRICT",
                Self::GroupChangeAnnounce => "GROUP_CHANGE_ANNOUNCE",
                Self::GroupParticipantAdd => "GROUP_PARTICIPANT_ADD",
                Self::GroupParticipantRemove => "GROUP_PARTICIPANT_REMOVE",
                Self::GroupParticipantPromote => "GROUP_PARTICIPANT_PROMOTE",
                Self::GroupParticipantDemote => "GROUP_PARTICIPANT_DEMOTE",
                Self::GroupParticipantInvite => "GROUP_PARTICIPANT_INVITE",
                Self::GroupParticipantLeave => "GROUP_PARTICIPANT_LEAVE",
                Self::GroupParticipantChangeNumber => "GROUP_PARTICIPANT_CHANGE_NUMBER",
                Self::BroadcastCreate => "BROADCAST_CREATE",
                Self::BroadcastAdd => "BROADCAST_ADD",
                Self::BroadcastRemove => "BROADCAST_REMOVE",
                Self::GenericNotification => "GENERIC_NOTIFICATION",
                Self::E2eIdentityChanged => "E2E_IDENTITY_CHANGED",
                Self::E2eEncrypted => "E2E_ENCRYPTED",
                Self::CallMissedVoice => "CALL_MISSED_VOICE",
                Self::CallMissedVideo => "CALL_MISSED_VIDEO",
                Self::IndividualChangeNumber => "INDIVIDUAL_CHANGE_NUMBER",
                Self::GroupDelete => "GROUP_DELETE",
                Self::GroupAnnounceModeMessageBounce => "GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE",
                Self::CallMissedGroupVoice => "CALL_MISSED_GROUP_VOICE",
                Self::CallMissedGroupVideo => "CALL_MISSED_GROUP_VIDEO",
                Self::PaymentCiphertext => "PAYMENT_CIPHERTEXT",
                Self::PaymentFutureproof => "PAYMENT_FUTUREPROOF",
                Self::PaymentTransactionStatusUpdateFailed => "PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED",
                Self::PaymentTransactionStatusUpdateRefunded => "PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED",
                Self::PaymentTransactionStatusUpdateRefundFailed => "PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED",
                Self::PaymentTransactionStatusReceiverPendingSetup => "PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP",
                Self::PaymentTransactionStatusReceiverSuccessAfterHiccup => "PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP",
                Self::PaymentActionAccountSetupReminder => "PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER",
                Self::PaymentActionSendPaymentReminder => "PAYMENT_ACTION_SEND_PAYMENT_REMINDER",
                Self::PaymentActionSendPaymentInvitation => "PAYMENT_ACTION_SEND_PAYMENT_INVITATION",
                Self::PaymentActionRequestDeclined => "PAYMENT_ACTION_REQUEST_DECLINED",
                Self::PaymentActionRequestExpired => "PAYMENT_ACTION_REQUEST_EXPIRED",
                Self::PaymentActionRequestCancelled => "PAYMENT_ACTION_REQUEST_CANCELLED",
                Self::BizVerifiedTransitionTopToBottom => "BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM",
                Self::BizVerifiedTransitionBottomToTop => "BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP",
                Self::BizIntroTop => "BIZ_INTRO_TOP",
                Self::BizIntroBottom => "BIZ_INTRO_BOTTOM",
                Self::BizNameChange => "BIZ_NAME_CHANGE",
                Self::BizMoveToConsumerApp => "BIZ_MOVE_TO_CONSUMER_APP",
                Self::BizTwoTierMigrationTop => "BIZ_TWO_TIER_MIGRATION_TOP",
                Self::BizTwoTierMigrationBottom => "BIZ_TWO_TIER_MIGRATION_BOTTOM",
                Self::Oversized => "OVERSIZED",
                Self::GroupChangeNoFrequentlyForwarded => "GROUP_CHANGE_NO_FREQUENTLY_FORWARDED",
                Self::GroupV4AddInviteSent => "GROUP_V4_ADD_INVITE_SENT",
                Self::GroupParticipantAddRequestJoin => "GROUP_PARTICIPANT_ADD_REQUEST_JOIN",
                Self::ChangeEphemeralSetting => "CHANGE_EPHEMERAL_SETTING",
                Self::E2eDeviceChanged => "E2E_DEVICE_CHANGED",
                Self::ViewedOnce => "VIEWED_ONCE",
                Self::E2eEncryptedNow => "E2E_ENCRYPTED_NOW",
                Self::BlueMsgBspFbToBspPremise => "BLUE_MSG_BSP_FB_TO_BSP_PREMISE",
                Self::BlueMsgBspFbToSelfFb => "BLUE_MSG_BSP_FB_TO_SELF_FB",
                Self::BlueMsgBspFbToSelfPremise => "BLUE_MSG_BSP_FB_TO_SELF_PREMISE",
                Self::BlueMsgBspFbUnverified => "BLUE_MSG_BSP_FB_UNVERIFIED",
                Self::BlueMsgBspFbUnverifiedToSelfPremiseVerified => "BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED",
                Self::BlueMsgBspFbVerified => "BLUE_MSG_BSP_FB_VERIFIED",
                Self::BlueMsgBspFbVerifiedToSelfPremiseUnverified => "BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED",
                Self::BlueMsgBspPremiseToSelfPremise => "BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE",
                Self::BlueMsgBspPremiseUnverified => "BLUE_MSG_BSP_PREMISE_UNVERIFIED",
                Self::BlueMsgBspPremiseUnverifiedToSelfPremiseVerified => "BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED",
                Self::BlueMsgBspPremiseVerified => "BLUE_MSG_BSP_PREMISE_VERIFIED",
                Self::BlueMsgBspPremiseVerifiedToSelfPremiseUnverified => "BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED",
                Self::BlueMsgConsumerToBspFbUnverified => "BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED",
                Self::BlueMsgConsumerToBspPremiseUnverified => "BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED",
                Self::BlueMsgConsumerToSelfFbUnverified => "BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED",
                Self::BlueMsgConsumerToSelfPremiseUnverified => "BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED",
                Self::BlueMsgSelfFbToBspPremise => "BLUE_MSG_SELF_FB_TO_BSP_PREMISE",
                Self::BlueMsgSelfFbToSelfPremise => "BLUE_MSG_SELF_FB_TO_SELF_PREMISE",
                Self::BlueMsgSelfFbUnverified => "BLUE_MSG_SELF_FB_UNVERIFIED",
                Self::BlueMsgSelfFbUnverifiedToSelfPremiseVerified => "BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED",
                Self::BlueMsgSelfFbVerified => "BLUE_MSG_SELF_FB_VERIFIED",
                Self::BlueMsgSelfFbVerifiedToSelfPremiseUnverified => "BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED",
                Self::BlueMsgSelfPremiseToBspPremise => "BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE",
                Self::BlueMsgSelfPremiseUnverified => "BLUE_MSG_SELF_PREMISE_UNVERIFIED",
                Self::BlueMsgSelfPremiseVerified => "BLUE_MSG_SELF_PREMISE_VERIFIED",
                Self::BlueMsgToBspFb => "BLUE_MSG_TO_BSP_FB",
                Self::BlueMsgToConsumer => "BLUE_MSG_TO_CONSUMER",
                Self::BlueMsgToSelfFb => "BLUE_MSG_TO_SELF_FB",
                Self::BlueMsgUnverifiedToBspFbVerified => "BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED",
                Self::BlueMsgUnverifiedToBspPremiseVerified => "BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED",
                Self::BlueMsgUnverifiedToSelfFbVerified => "BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED",
                Self::BlueMsgUnverifiedToVerified => "BLUE_MSG_UNVERIFIED_TO_VERIFIED",
                Self::BlueMsgVerifiedToBspFbUnverified => "BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED",
                Self::BlueMsgVerifiedToBspPremiseUnverified => "BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED",
                Self::BlueMsgVerifiedToSelfFbUnverified => "BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED",
                Self::BlueMsgVerifiedToUnverified => "BLUE_MSG_VERIFIED_TO_UNVERIFIED",
                Self::BlueMsgBspFbUnverifiedToBspPremiseVerified => "BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED",
                Self::BlueMsgBspFbUnverifiedToSelfFbVerified => "BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED",
                Self::BlueMsgBspFbVerifiedToBspPremiseUnverified => "BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED",
                Self::BlueMsgBspFbVerifiedToSelfFbUnverified => "BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED",
                Self::BlueMsgSelfFbUnverifiedToBspPremiseVerified => "BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED",
                Self::BlueMsgSelfFbVerifiedToBspPremiseUnverified => "BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED",
                Self::E2eIdentityUnavailable => "E2E_IDENTITY_UNAVAILABLE",
                Self::GroupCreating => "GROUP_CREATING",
                Self::GroupCreateFailed => "GROUP_CREATE_FAILED",
                Self::GroupBounced => "GROUP_BOUNCED",
                Self::BlockContact => "BLOCK_CONTACT",
                Self::EphemeralSettingNotApplied => "EPHEMERAL_SETTING_NOT_APPLIED",
                Self::SyncFailed => "SYNC_FAILED",
                Self::Syncing => "SYNCING",
                Self::BizPrivacyModeInitFb => "BIZ_PRIVACY_MODE_INIT_FB",
                Self::BizPrivacyModeInitBsp => "BIZ_PRIVACY_MODE_INIT_BSP",
                Self::BizPrivacyModeToFb => "BIZ_PRIVACY_MODE_TO_FB",
                Self::BizPrivacyModeToBsp => "BIZ_PRIVACY_MODE_TO_BSP",
                Self::DisappearingMode => "DISAPPEARING_MODE",
                Self::E2eDeviceFetchFailed => "E2E_DEVICE_FETCH_FAILED",
                Self::AdminRevoke => "ADMIN_REVOKE",
                Self::GroupInviteLinkGrowthLocked => "GROUP_INVITE_LINK_GROWTH_LOCKED",
                Self::CommunityLinkParentGroup => "COMMUNITY_LINK_PARENT_GROUP",
                Self::CommunityLinkSiblingGroup => "COMMUNITY_LINK_SIBLING_GROUP",
                Self::CommunityLinkSubGroup => "COMMUNITY_LINK_SUB_GROUP",
                Self::CommunityUnlinkParentGroup => "COMMUNITY_UNLINK_PARENT_GROUP",
                Self::CommunityUnlinkSiblingGroup => "COMMUNITY_UNLINK_SIBLING_GROUP",
                Self::CommunityUnlinkSubGroup => "COMMUNITY_UNLINK_SUB_GROUP",
                Self::GroupParticipantAccept => "GROUP_PARTICIPANT_ACCEPT",
                Self::GroupParticipantLinkedGroupJoin => "GROUP_PARTICIPANT_LINKED_GROUP_JOIN",
                Self::CommunityCreate => "COMMUNITY_CREATE",
                Self::EphemeralKeepInChat => "EPHEMERAL_KEEP_IN_CHAT",
                Self::GroupMembershipJoinApprovalRequest => "GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST",
                Self::GroupMembershipJoinApprovalMode => "GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE",
                Self::IntegrityUnlinkParentGroup => "INTEGRITY_UNLINK_PARENT_GROUP",
                Self::CommunityParticipantPromote => "COMMUNITY_PARTICIPANT_PROMOTE",
                Self::CommunityParticipantDemote => "COMMUNITY_PARTICIPANT_DEMOTE",
                Self::CommunityParentGroupDeleted => "COMMUNITY_PARENT_GROUP_DELETED",
                Self::CommunityLinkParentGroupMembershipApproval => "COMMUNITY_LINK_PARENT_GROUP_MEMBERSHIP_APPROVAL",
                Self::GroupParticipantJoinedGroupAndParentGroup => "GROUP_PARTICIPANT_JOINED_GROUP_AND_PARENT_GROUP",
                Self::MaskedThreadCreated => "MASKED_THREAD_CREATED",
                Self::MaskedThreadUnmasked => "MASKED_THREAD_UNMASKED",
                Self::BizChatAssignment => "BIZ_CHAT_ASSIGNMENT",
                Self::ChatPsa => "CHAT_PSA",
                Self::ChatPollCreationMessage => "CHAT_POLL_CREATION_MESSAGE",
                Self::CagMaskedThreadCreated => "CAG_MASKED_THREAD_CREATED",
                Self::CommunityParentGroupSubjectChanged => "COMMUNITY_PARENT_GROUP_SUBJECT_CHANGED",
                Self::CagInviteAutoAdd => "CAG_INVITE_AUTO_ADD",
                Self::BizChatAssignmentUnassign => "BIZ_CHAT_ASSIGNMENT_UNASSIGN",
                Self::CagInviteAutoJoined => "CAG_INVITE_AUTO_JOINED",
                Self::ScheduledCallStartMessage => "SCHEDULED_CALL_START_MESSAGE",
                Self::CommunityInviteRich => "COMMUNITY_INVITE_RICH",
                Self::CommunityInviteAutoAddRich => "COMMUNITY_INVITE_AUTO_ADD_RICH",
                Self::SubGroupInviteRich => "SUB_GROUP_INVITE_RICH",
                Self::SubGroupParticipantAddRich => "SUB_GROUP_PARTICIPANT_ADD_RICH",
                Self::CommunityLinkParentGroupRich => "COMMUNITY_LINK_PARENT_GROUP_RICH",
                Self::CommunityParticipantAddRich => "COMMUNITY_PARTICIPANT_ADD_RICH",
                Self::SilencedUnknownCallerAudio => "SILENCED_UNKNOWN_CALLER_AUDIO",
                Self::SilencedUnknownCallerVideo => "SILENCED_UNKNOWN_CALLER_VIDEO",
                Self::GroupMemberAddMode => "GROUP_MEMBER_ADD_MODE",
                Self::GroupMembershipJoinApprovalRequestNonAdminAdd => "GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST_NON_ADMIN_ADD",
                Self::CommunityChangeDescription => "COMMUNITY_CHANGE_DESCRIPTION",
                Self::SenderInvite => "SENDER_INVITE",
                Self::ReceiverInvite => "RECEIVER_INVITE",
                Self::CommunityAllowMemberAddedGroups => "COMMUNITY_ALLOW_MEMBER_ADDED_GROUPS",
                Self::PinnedMessageInChat => "PINNED_MESSAGE_IN_CHAT",
                Self::PaymentInviteSetupInviter => "PAYMENT_INVITE_SETUP_INVITER",
                Self::PaymentInviteSetupInviteeReceiveOnly => "PAYMENT_INVITE_SETUP_INVITEE_RECEIVE_ONLY",
                Self::PaymentInviteSetupInviteeSendAndReceive => "PAYMENT_INVITE_SETUP_INVITEE_SEND_AND_RECEIVE",
                Self::LinkedGroupCallStart => "LINKED_GROUP_CALL_START",
                Self::ReportToAdminEnabledStatus => "REPORT_TO_ADMIN_ENABLED_STATUS",
                Self::EmptySubgroupCreate => "EMPTY_SUBGROUP_CREATE",
                Self::ScheduledCallCancel => "SCHEDULED_CALL_CANCEL",
                Self::SubgroupAdminTriggeredAutoAddRich => "SUBGROUP_ADMIN_TRIGGERED_AUTO_ADD_RICH",
                Self::GroupChangeRecentHistorySharing => "GROUP_CHANGE_RECENT_HISTORY_SHARING",
                Self::PaidMessageServerCampaignId => "PAID_MESSAGE_SERVER_CAMPAIGN_ID",
                Self::GeneralChatCreate => "GENERAL_CHAT_CREATE",
                Self::GeneralChatAdd => "GENERAL_CHAT_ADD",
                Self::GeneralChatAutoAddDisabled => "GENERAL_CHAT_AUTO_ADD_DISABLED",
                Self::SuggestedSubgroupAnnounce => "SUGGESTED_SUBGROUP_ANNOUNCE",
                Self::BizBot1pMessagingEnabled => "BIZ_BOT_1P_MESSAGING_ENABLED",
                Self::ChangeUsername => "CHANGE_USERNAME",
                Self::BizCoexPrivacyInitSelf => "BIZ_COEX_PRIVACY_INIT_SELF",
                Self::BizCoexPrivacyTransitionSelf => "BIZ_COEX_PRIVACY_TRANSITION_SELF",
                Self::SupportAiEducation => "SUPPORT_AI_EDUCATION",
                Self::BizBot3pMessagingEnabled => "BIZ_BOT_3P_MESSAGING_ENABLED",
                Self::ReminderSetupMessage => "REMINDER_SETUP_MESSAGE",
                Self::ReminderSentMessage => "REMINDER_SENT_MESSAGE",
                Self::ReminderCancelMessage => "REMINDER_CANCEL_MESSAGE",
                Self::BizCoexPrivacyInit => "BIZ_COEX_PRIVACY_INIT",
                Self::BizCoexPrivacyTransition => "BIZ_COEX_PRIVACY_TRANSITION",
                Self::GroupDeactivated => "GROUP_DEACTIVATED",
                Self::CommunityDeactivateSiblingGroup => "COMMUNITY_DEACTIVATE_SIBLING_GROUP",
                Self::EventUpdated => "EVENT_UPDATED",
                Self::EventCanceled => "EVENT_CANCELED",
                Self::CommunityOwnerUpdated => "COMMUNITY_OWNER_UPDATED",
                Self::CommunitySubGroupVisibilityHidden => "COMMUNITY_SUB_GROUP_VISIBILITY_HIDDEN",
                Self::CapiGroupNe2eeSystemMessage => "CAPI_GROUP_NE2EE_SYSTEM_MESSAGE",
                Self::StatusMention => "STATUS_MENTION",
                Self::UserControlsSystemMessage => "USER_CONTROLS_SYSTEM_MESSAGE",
                Self::SupportSystemMessage => "SUPPORT_SYSTEM_MESSAGE",
                Self::ChangeLid => "CHANGE_LID",
                Self::BizCustomer3pdDataSharingOptInMessage => "BIZ_CUSTOMER_3PD_DATA_SHARING_OPT_IN_MESSAGE",
                Self::BizCustomer3pdDataSharingOptOutMessage => "BIZ_CUSTOMER_3PD_DATA_SHARING_OPT_OUT_MESSAGE",
                Self::ChangeLimitSharing => "CHANGE_LIMIT_SHARING",
                Self::GroupMemberLinkMode => "GROUP_MEMBER_LINK_MODE",
                Self::BizAutomaticallyLabeledChatSystemMessage => "BIZ_AUTOMATICALLY_LABELED_CHAT_SYSTEM_MESSAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "REVOKE" => Some(Self::Revoke),
                "CIPHERTEXT" => Some(Self::Ciphertext),
                "FUTUREPROOF" => Some(Self::Futureproof),
                "NON_VERIFIED_TRANSITION" => Some(Self::NonVerifiedTransition),
                "UNVERIFIED_TRANSITION" => Some(Self::UnverifiedTransition),
                "VERIFIED_TRANSITION" => Some(Self::VerifiedTransition),
                "VERIFIED_LOW_UNKNOWN" => Some(Self::VerifiedLowUnknown),
                "VERIFIED_HIGH" => Some(Self::VerifiedHigh),
                "VERIFIED_INITIAL_UNKNOWN" => Some(Self::VerifiedInitialUnknown),
                "VERIFIED_INITIAL_LOW" => Some(Self::VerifiedInitialLow),
                "VERIFIED_INITIAL_HIGH" => Some(Self::VerifiedInitialHigh),
                "VERIFIED_TRANSITION_ANY_TO_NONE" => Some(Self::VerifiedTransitionAnyToNone),
                "VERIFIED_TRANSITION_ANY_TO_HIGH" => Some(Self::VerifiedTransitionAnyToHigh),
                "VERIFIED_TRANSITION_HIGH_TO_LOW" => Some(Self::VerifiedTransitionHighToLow),
                "VERIFIED_TRANSITION_HIGH_TO_UNKNOWN" => Some(Self::VerifiedTransitionHighToUnknown),
                "VERIFIED_TRANSITION_UNKNOWN_TO_LOW" => Some(Self::VerifiedTransitionUnknownToLow),
                "VERIFIED_TRANSITION_LOW_TO_UNKNOWN" => Some(Self::VerifiedTransitionLowToUnknown),
                "VERIFIED_TRANSITION_NONE_TO_LOW" => Some(Self::VerifiedTransitionNoneToLow),
                "VERIFIED_TRANSITION_NONE_TO_UNKNOWN" => Some(Self::VerifiedTransitionNoneToUnknown),
                "GROUP_CREATE" => Some(Self::GroupCreate),
                "GROUP_CHANGE_SUBJECT" => Some(Self::GroupChangeSubject),
                "GROUP_CHANGE_ICON" => Some(Self::GroupChangeIcon),
                "GROUP_CHANGE_INVITE_LINK" => Some(Self::GroupChangeInviteLink),
                "GROUP_CHANGE_DESCRIPTION" => Some(Self::GroupChangeDescription),
                "GROUP_CHANGE_RESTRICT" => Some(Self::GroupChangeRestrict),
                "GROUP_CHANGE_ANNOUNCE" => Some(Self::GroupChangeAnnounce),
                "GROUP_PARTICIPANT_ADD" => Some(Self::GroupParticipantAdd),
                "GROUP_PARTICIPANT_REMOVE" => Some(Self::GroupParticipantRemove),
                "GROUP_PARTICIPANT_PROMOTE" => Some(Self::GroupParticipantPromote),
                "GROUP_PARTICIPANT_DEMOTE" => Some(Self::GroupParticipantDemote),
                "GROUP_PARTICIPANT_INVITE" => Some(Self::GroupParticipantInvite),
                "GROUP_PARTICIPANT_LEAVE" => Some(Self::GroupParticipantLeave),
                "GROUP_PARTICIPANT_CHANGE_NUMBER" => Some(Self::GroupParticipantChangeNumber),
                "BROADCAST_CREATE" => Some(Self::BroadcastCreate),
                "BROADCAST_ADD" => Some(Self::BroadcastAdd),
                "BROADCAST_REMOVE" => Some(Self::BroadcastRemove),
                "GENERIC_NOTIFICATION" => Some(Self::GenericNotification),
                "E2E_IDENTITY_CHANGED" => Some(Self::E2eIdentityChanged),
                "E2E_ENCRYPTED" => Some(Self::E2eEncrypted),
                "CALL_MISSED_VOICE" => Some(Self::CallMissedVoice),
                "CALL_MISSED_VIDEO" => Some(Self::CallMissedVideo),
                "INDIVIDUAL_CHANGE_NUMBER" => Some(Self::IndividualChangeNumber),
                "GROUP_DELETE" => Some(Self::GroupDelete),
                "GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE" => Some(Self::GroupAnnounceModeMessageBounce),
                "CALL_MISSED_GROUP_VOICE" => Some(Self::CallMissedGroupVoice),
                "CALL_MISSED_GROUP_VIDEO" => Some(Self::CallMissedGroupVideo),
                "PAYMENT_CIPHERTEXT" => Some(Self::PaymentCiphertext),
                "PAYMENT_FUTUREPROOF" => Some(Self::PaymentFutureproof),
                "PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED" => Some(Self::PaymentTransactionStatusUpdateFailed),
                "PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED" => Some(Self::PaymentTransactionStatusUpdateRefunded),
                "PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED" => Some(Self::PaymentTransactionStatusUpdateRefundFailed),
                "PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP" => Some(Self::PaymentTransactionStatusReceiverPendingSetup),
                "PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP" => Some(Self::PaymentTransactionStatusReceiverSuccessAfterHiccup),
                "PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER" => Some(Self::PaymentActionAccountSetupReminder),
                "PAYMENT_ACTION_SEND_PAYMENT_REMINDER" => Some(Self::PaymentActionSendPaymentReminder),
                "PAYMENT_ACTION_SEND_PAYMENT_INVITATION" => Some(Self::PaymentActionSendPaymentInvitation),
                "PAYMENT_ACTION_REQUEST_DECLINED" => Some(Self::PaymentActionRequestDeclined),
                "PAYMENT_ACTION_REQUEST_EXPIRED" => Some(Self::PaymentActionRequestExpired),
                "PAYMENT_ACTION_REQUEST_CANCELLED" => Some(Self::PaymentActionRequestCancelled),
                "BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM" => Some(Self::BizVerifiedTransitionTopToBottom),
                "BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP" => Some(Self::BizVerifiedTransitionBottomToTop),
                "BIZ_INTRO_TOP" => Some(Self::BizIntroTop),
                "BIZ_INTRO_BOTTOM" => Some(Self::BizIntroBottom),
                "BIZ_NAME_CHANGE" => Some(Self::BizNameChange),
                "BIZ_MOVE_TO_CONSUMER_APP" => Some(Self::BizMoveToConsumerApp),
                "BIZ_TWO_TIER_MIGRATION_TOP" => Some(Self::BizTwoTierMigrationTop),
                "BIZ_TWO_TIER_MIGRATION_BOTTOM" => Some(Self::BizTwoTierMigrationBottom),
                "OVERSIZED" => Some(Self::Oversized),
                "GROUP_CHANGE_NO_FREQUENTLY_FORWARDED" => Some(Self::GroupChangeNoFrequentlyForwarded),
                "GROUP_V4_ADD_INVITE_SENT" => Some(Self::GroupV4AddInviteSent),
                "GROUP_PARTICIPANT_ADD_REQUEST_JOIN" => Some(Self::GroupParticipantAddRequestJoin),
                "CHANGE_EPHEMERAL_SETTING" => Some(Self::ChangeEphemeralSetting),
                "E2E_DEVICE_CHANGED" => Some(Self::E2eDeviceChanged),
                "VIEWED_ONCE" => Some(Self::ViewedOnce),
                "E2E_ENCRYPTED_NOW" => Some(Self::E2eEncryptedNow),
                "BLUE_MSG_BSP_FB_TO_BSP_PREMISE" => Some(Self::BlueMsgBspFbToBspPremise),
                "BLUE_MSG_BSP_FB_TO_SELF_FB" => Some(Self::BlueMsgBspFbToSelfFb),
                "BLUE_MSG_BSP_FB_TO_SELF_PREMISE" => Some(Self::BlueMsgBspFbToSelfPremise),
                "BLUE_MSG_BSP_FB_UNVERIFIED" => Some(Self::BlueMsgBspFbUnverified),
                "BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED" => Some(Self::BlueMsgBspFbUnverifiedToSelfPremiseVerified),
                "BLUE_MSG_BSP_FB_VERIFIED" => Some(Self::BlueMsgBspFbVerified),
                "BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED" => Some(Self::BlueMsgBspFbVerifiedToSelfPremiseUnverified),
                "BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE" => Some(Self::BlueMsgBspPremiseToSelfPremise),
                "BLUE_MSG_BSP_PREMISE_UNVERIFIED" => Some(Self::BlueMsgBspPremiseUnverified),
                "BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED" => Some(Self::BlueMsgBspPremiseUnverifiedToSelfPremiseVerified),
                "BLUE_MSG_BSP_PREMISE_VERIFIED" => Some(Self::BlueMsgBspPremiseVerified),
                "BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED" => Some(Self::BlueMsgBspPremiseVerifiedToSelfPremiseUnverified),
                "BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED" => Some(Self::BlueMsgConsumerToBspFbUnverified),
                "BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED" => Some(Self::BlueMsgConsumerToBspPremiseUnverified),
                "BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED" => Some(Self::BlueMsgConsumerToSelfFbUnverified),
                "BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED" => Some(Self::BlueMsgConsumerToSelfPremiseUnverified),
                "BLUE_MSG_SELF_FB_TO_BSP_PREMISE" => Some(Self::BlueMsgSelfFbToBspPremise),
                "BLUE_MSG_SELF_FB_TO_SELF_PREMISE" => Some(Self::BlueMsgSelfFbToSelfPremise),
                "BLUE_MSG_SELF_FB_UNVERIFIED" => Some(Self::BlueMsgSelfFbUnverified),
                "BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED" => Some(Self::BlueMsgSelfFbUnverifiedToSelfPremiseVerified),
                "BLUE_MSG_SELF_FB_VERIFIED" => Some(Self::BlueMsgSelfFbVerified),
                "BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED" => Some(Self::BlueMsgSelfFbVerifiedToSelfPremiseUnverified),
                "BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE" => Some(Self::BlueMsgSelfPremiseToBspPremise),
                "BLUE_MSG_SELF_PREMISE_UNVERIFIED" => Some(Self::BlueMsgSelfPremiseUnverified),
                "BLUE_MSG_SELF_PREMISE_VERIFIED" => Some(Self::BlueMsgSelfPremiseVerified),
                "BLUE_MSG_TO_BSP_FB" => Some(Self::BlueMsgToBspFb),
                "BLUE_MSG_TO_CONSUMER" => Some(Self::BlueMsgToConsumer),
                "BLUE_MSG_TO_SELF_FB" => Some(Self::BlueMsgToSelfFb),
                "BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED" => Some(Self::BlueMsgUnverifiedToBspFbVerified),
                "BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED" => Some(Self::BlueMsgUnverifiedToBspPremiseVerified),
                "BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED" => Some(Self::BlueMsgUnverifiedToSelfFbVerified),
                "BLUE_MSG_UNVERIFIED_TO_VERIFIED" => Some(Self::BlueMsgUnverifiedToVerified),
                "BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED" => Some(Self::BlueMsgVerifiedToBspFbUnverified),
                "BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED" => Some(Self::BlueMsgVerifiedToBspPremiseUnverified),
                "BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED" => Some(Self::BlueMsgVerifiedToSelfFbUnverified),
                "BLUE_MSG_VERIFIED_TO_UNVERIFIED" => Some(Self::BlueMsgVerifiedToUnverified),
                "BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED" => Some(Self::BlueMsgBspFbUnverifiedToBspPremiseVerified),
                "BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED" => Some(Self::BlueMsgBspFbUnverifiedToSelfFbVerified),
                "BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED" => Some(Self::BlueMsgBspFbVerifiedToBspPremiseUnverified),
                "BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED" => Some(Self::BlueMsgBspFbVerifiedToSelfFbUnverified),
                "BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED" => Some(Self::BlueMsgSelfFbUnverifiedToBspPremiseVerified),
                "BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED" => Some(Self::BlueMsgSelfFbVerifiedToBspPremiseUnverified),
                "E2E_IDENTITY_UNAVAILABLE" => Some(Self::E2eIdentityUnavailable),
                "GROUP_CREATING" => Some(Self::GroupCreating),
                "GROUP_CREATE_FAILED" => Some(Self::GroupCreateFailed),
                "GROUP_BOUNCED" => Some(Self::GroupBounced),
                "BLOCK_CONTACT" => Some(Self::BlockContact),
                "EPHEMERAL_SETTING_NOT_APPLIED" => Some(Self::EphemeralSettingNotApplied),
                "SYNC_FAILED" => Some(Self::SyncFailed),
                "SYNCING" => Some(Self::Syncing),
                "BIZ_PRIVACY_MODE_INIT_FB" => Some(Self::BizPrivacyModeInitFb),
                "BIZ_PRIVACY_MODE_INIT_BSP" => Some(Self::BizPrivacyModeInitBsp),
                "BIZ_PRIVACY_MODE_TO_FB" => Some(Self::BizPrivacyModeToFb),
                "BIZ_PRIVACY_MODE_TO_BSP" => Some(Self::BizPrivacyModeToBsp),
                "DISAPPEARING_MODE" => Some(Self::DisappearingMode),
                "E2E_DEVICE_FETCH_FAILED" => Some(Self::E2eDeviceFetchFailed),
                "ADMIN_REVOKE" => Some(Self::AdminRevoke),
                "GROUP_INVITE_LINK_GROWTH_LOCKED" => Some(Self::GroupInviteLinkGrowthLocked),
                "COMMUNITY_LINK_PARENT_GROUP" => Some(Self::CommunityLinkParentGroup),
                "COMMUNITY_LINK_SIBLING_GROUP" => Some(Self::CommunityLinkSiblingGroup),
                "COMMUNITY_LINK_SUB_GROUP" => Some(Self::CommunityLinkSubGroup),
                "COMMUNITY_UNLINK_PARENT_GROUP" => Some(Self::CommunityUnlinkParentGroup),
                "COMMUNITY_UNLINK_SIBLING_GROUP" => Some(Self::CommunityUnlinkSiblingGroup),
                "COMMUNITY_UNLINK_SUB_GROUP" => Some(Self::CommunityUnlinkSubGroup),
                "GROUP_PARTICIPANT_ACCEPT" => Some(Self::GroupParticipantAccept),
                "GROUP_PARTICIPANT_LINKED_GROUP_JOIN" => Some(Self::GroupParticipantLinkedGroupJoin),
                "COMMUNITY_CREATE" => Some(Self::CommunityCreate),
                "EPHEMERAL_KEEP_IN_CHAT" => Some(Self::EphemeralKeepInChat),
                "GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST" => Some(Self::GroupMembershipJoinApprovalRequest),
                "GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE" => Some(Self::GroupMembershipJoinApprovalMode),
                "INTEGRITY_UNLINK_PARENT_GROUP" => Some(Self::IntegrityUnlinkParentGroup),
                "COMMUNITY_PARTICIPANT_PROMOTE" => Some(Self::CommunityParticipantPromote),
                "COMMUNITY_PARTICIPANT_DEMOTE" => Some(Self::CommunityParticipantDemote),
                "COMMUNITY_PARENT_GROUP_DELETED" => Some(Self::CommunityParentGroupDeleted),
                "COMMUNITY_LINK_PARENT_GROUP_MEMBERSHIP_APPROVAL" => Some(Self::CommunityLinkParentGroupMembershipApproval),
                "GROUP_PARTICIPANT_JOINED_GROUP_AND_PARENT_GROUP" => Some(Self::GroupParticipantJoinedGroupAndParentGroup),
                "MASKED_THREAD_CREATED" => Some(Self::MaskedThreadCreated),
                "MASKED_THREAD_UNMASKED" => Some(Self::MaskedThreadUnmasked),
                "BIZ_CHAT_ASSIGNMENT" => Some(Self::BizChatAssignment),
                "CHAT_PSA" => Some(Self::ChatPsa),
                "CHAT_POLL_CREATION_MESSAGE" => Some(Self::ChatPollCreationMessage),
                "CAG_MASKED_THREAD_CREATED" => Some(Self::CagMaskedThreadCreated),
                "COMMUNITY_PARENT_GROUP_SUBJECT_CHANGED" => Some(Self::CommunityParentGroupSubjectChanged),
                "CAG_INVITE_AUTO_ADD" => Some(Self::CagInviteAutoAdd),
                "BIZ_CHAT_ASSIGNMENT_UNASSIGN" => Some(Self::BizChatAssignmentUnassign),
                "CAG_INVITE_AUTO_JOINED" => Some(Self::CagInviteAutoJoined),
                "SCHEDULED_CALL_START_MESSAGE" => Some(Self::ScheduledCallStartMessage),
                "COMMUNITY_INVITE_RICH" => Some(Self::CommunityInviteRich),
                "COMMUNITY_INVITE_AUTO_ADD_RICH" => Some(Self::CommunityInviteAutoAddRich),
                "SUB_GROUP_INVITE_RICH" => Some(Self::SubGroupInviteRich),
                "SUB_GROUP_PARTICIPANT_ADD_RICH" => Some(Self::SubGroupParticipantAddRich),
                "COMMUNITY_LINK_PARENT_GROUP_RICH" => Some(Self::CommunityLinkParentGroupRich),
                "COMMUNITY_PARTICIPANT_ADD_RICH" => Some(Self::CommunityParticipantAddRich),
                "SILENCED_UNKNOWN_CALLER_AUDIO" => Some(Self::SilencedUnknownCallerAudio),
                "SILENCED_UNKNOWN_CALLER_VIDEO" => Some(Self::SilencedUnknownCallerVideo),
                "GROUP_MEMBER_ADD_MODE" => Some(Self::GroupMemberAddMode),
                "GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST_NON_ADMIN_ADD" => Some(Self::GroupMembershipJoinApprovalRequestNonAdminAdd),
                "COMMUNITY_CHANGE_DESCRIPTION" => Some(Self::CommunityChangeDescription),
                "SENDER_INVITE" => Some(Self::SenderInvite),
                "RECEIVER_INVITE" => Some(Self::ReceiverInvite),
                "COMMUNITY_ALLOW_MEMBER_ADDED_GROUPS" => Some(Self::CommunityAllowMemberAddedGroups),
                "PINNED_MESSAGE_IN_CHAT" => Some(Self::PinnedMessageInChat),
                "PAYMENT_INVITE_SETUP_INVITER" => Some(Self::PaymentInviteSetupInviter),
                "PAYMENT_INVITE_SETUP_INVITEE_RECEIVE_ONLY" => Some(Self::PaymentInviteSetupInviteeReceiveOnly),
                "PAYMENT_INVITE_SETUP_INVITEE_SEND_AND_RECEIVE" => Some(Self::PaymentInviteSetupInviteeSendAndReceive),
                "LINKED_GROUP_CALL_START" => Some(Self::LinkedGroupCallStart),
                "REPORT_TO_ADMIN_ENABLED_STATUS" => Some(Self::ReportToAdminEnabledStatus),
                "EMPTY_SUBGROUP_CREATE" => Some(Self::EmptySubgroupCreate),
                "SCHEDULED_CALL_CANCEL" => Some(Self::ScheduledCallCancel),
                "SUBGROUP_ADMIN_TRIGGERED_AUTO_ADD_RICH" => Some(Self::SubgroupAdminTriggeredAutoAddRich),
                "GROUP_CHANGE_RECENT_HISTORY_SHARING" => Some(Self::GroupChangeRecentHistorySharing),
                "PAID_MESSAGE_SERVER_CAMPAIGN_ID" => Some(Self::PaidMessageServerCampaignId),
                "GENERAL_CHAT_CREATE" => Some(Self::GeneralChatCreate),
                "GENERAL_CHAT_ADD" => Some(Self::GeneralChatAdd),
                "GENERAL_CHAT_AUTO_ADD_DISABLED" => Some(Self::GeneralChatAutoAddDisabled),
                "SUGGESTED_SUBGROUP_ANNOUNCE" => Some(Self::SuggestedSubgroupAnnounce),
                "BIZ_BOT_1P_MESSAGING_ENABLED" => Some(Self::BizBot1pMessagingEnabled),
                "CHANGE_USERNAME" => Some(Self::ChangeUsername),
                "BIZ_COEX_PRIVACY_INIT_SELF" => Some(Self::BizCoexPrivacyInitSelf),
                "BIZ_COEX_PRIVACY_TRANSITION_SELF" => Some(Self::BizCoexPrivacyTransitionSelf),
                "SUPPORT_AI_EDUCATION" => Some(Self::SupportAiEducation),
                "BIZ_BOT_3P_MESSAGING_ENABLED" => Some(Self::BizBot3pMessagingEnabled),
                "REMINDER_SETUP_MESSAGE" => Some(Self::ReminderSetupMessage),
                "REMINDER_SENT_MESSAGE" => Some(Self::ReminderSentMessage),
                "REMINDER_CANCEL_MESSAGE" => Some(Self::ReminderCancelMessage),
                "BIZ_COEX_PRIVACY_INIT" => Some(Self::BizCoexPrivacyInit),
                "BIZ_COEX_PRIVACY_TRANSITION" => Some(Self::BizCoexPrivacyTransition),
                "GROUP_DEACTIVATED" => Some(Self::GroupDeactivated),
                "COMMUNITY_DEACTIVATE_SIBLING_GROUP" => Some(Self::CommunityDeactivateSiblingGroup),
                "EVENT_UPDATED" => Some(Self::EventUpdated),
                "EVENT_CANCELED" => Some(Self::EventCanceled),
                "COMMUNITY_OWNER_UPDATED" => Some(Self::CommunityOwnerUpdated),
                "COMMUNITY_SUB_GROUP_VISIBILITY_HIDDEN" => Some(Self::CommunitySubGroupVisibilityHidden),
                "CAPI_GROUP_NE2EE_SYSTEM_MESSAGE" => Some(Self::CapiGroupNe2eeSystemMessage),
                "STATUS_MENTION" => Some(Self::StatusMention),
                "USER_CONTROLS_SYSTEM_MESSAGE" => Some(Self::UserControlsSystemMessage),
                "SUPPORT_SYSTEM_MESSAGE" => Some(Self::SupportSystemMessage),
                "CHANGE_LID" => Some(Self::ChangeLid),
                "BIZ_CUSTOMER_3PD_DATA_SHARING_OPT_IN_MESSAGE" => Some(Self::BizCustomer3pdDataSharingOptInMessage),
                "BIZ_CUSTOMER_3PD_DATA_SHARING_OPT_OUT_MESSAGE" => Some(Self::BizCustomer3pdDataSharingOptOutMessage),
                "CHANGE_LIMIT_SHARING" => Some(Self::ChangeLimitSharing),
                "GROUP_MEMBER_LINK_MODE" => Some(Self::GroupMemberLinkMode),
                "BIZ_AUTOMATICALLY_LABELED_CHAT_SYSTEM_MESSAGE" => Some(Self::BizAutomaticallyLabeledChatSystemMessage),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebNotificationsInfo {
    #[prost(uint64, optional, tag="2")]
    pub timestamp: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="3")]
    pub unread_chats: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub notify_message_count: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="5")]
    pub notify_messages: ::prost::alloc::vec::Vec<WebMessageInfo>,
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AdvEncryptionType {
    E2ee = 0,
    Hosted = 1,
}
impl AdvEncryptionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::E2ee => "E2EE",
            Self::Hosted => "HOSTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "E2EE" => Some(Self::E2ee),
            "HOSTED" => Some(Self::Hosted),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BotMetricsEntryPoint {
    Favicon = 1,
    Chatlist = 2,
    AisearchNullStatePaperPlane = 3,
    AisearchNullStateSuggestion = 4,
    AisearchTypeAheadSuggestion = 5,
    AisearchTypeAheadPaperPlane = 6,
    AisearchTypeAheadResultChatlist = 7,
    AisearchTypeAheadResultMessages = 8,
    AivoiceSearchBar = 9,
    AivoiceFavicon = 10,
    Aistudio = 11,
    Deeplink = 12,
    Notification = 13,
    ProfileMessageButton = 14,
    Forward = 15,
    AppShortcut = 16,
    FfFamily = 17,
    AiTab = 18,
    AiHome = 19,
    AiDeeplinkImmersive = 20,
    AiDeeplink = 21,
    MetaAiChatShortcutAiStudio = 22,
    UgcChatShortcutAiStudio = 23,
    NewChatAiStudio = 24,
}
impl BotMetricsEntryPoint {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Favicon => "FAVICON",
            Self::Chatlist => "CHATLIST",
            Self::AisearchNullStatePaperPlane => "AISEARCH_NULL_STATE_PAPER_PLANE",
            Self::AisearchNullStateSuggestion => "AISEARCH_NULL_STATE_SUGGESTION",
            Self::AisearchTypeAheadSuggestion => "AISEARCH_TYPE_AHEAD_SUGGESTION",
            Self::AisearchTypeAheadPaperPlane => "AISEARCH_TYPE_AHEAD_PAPER_PLANE",
            Self::AisearchTypeAheadResultChatlist => "AISEARCH_TYPE_AHEAD_RESULT_CHATLIST",
            Self::AisearchTypeAheadResultMessages => "AISEARCH_TYPE_AHEAD_RESULT_MESSAGES",
            Self::AivoiceSearchBar => "AIVOICE_SEARCH_BAR",
            Self::AivoiceFavicon => "AIVOICE_FAVICON",
            Self::Aistudio => "AISTUDIO",
            Self::Deeplink => "DEEPLINK",
            Self::Notification => "NOTIFICATION",
            Self::ProfileMessageButton => "PROFILE_MESSAGE_BUTTON",
            Self::Forward => "FORWARD",
            Self::AppShortcut => "APP_SHORTCUT",
            Self::FfFamily => "FF_FAMILY",
            Self::AiTab => "AI_TAB",
            Self::AiHome => "AI_HOME",
            Self::AiDeeplinkImmersive => "AI_DEEPLINK_IMMERSIVE",
            Self::AiDeeplink => "AI_DEEPLINK",
            Self::MetaAiChatShortcutAiStudio => "META_AI_CHAT_SHORTCUT_AI_STUDIO",
            Self::UgcChatShortcutAiStudio => "UGC_CHAT_SHORTCUT_AI_STUDIO",
            Self::NewChatAiStudio => "NEW_CHAT_AI_STUDIO",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FAVICON" => Some(Self::Favicon),
            "CHATLIST" => Some(Self::Chatlist),
            "AISEARCH_NULL_STATE_PAPER_PLANE" => Some(Self::AisearchNullStatePaperPlane),
            "AISEARCH_NULL_STATE_SUGGESTION" => Some(Self::AisearchNullStateSuggestion),
            "AISEARCH_TYPE_AHEAD_SUGGESTION" => Some(Self::AisearchTypeAheadSuggestion),
            "AISEARCH_TYPE_AHEAD_PAPER_PLANE" => Some(Self::AisearchTypeAheadPaperPlane),
            "AISEARCH_TYPE_AHEAD_RESULT_CHATLIST" => Some(Self::AisearchTypeAheadResultChatlist),
            "AISEARCH_TYPE_AHEAD_RESULT_MESSAGES" => Some(Self::AisearchTypeAheadResultMessages),
            "AIVOICE_SEARCH_BAR" => Some(Self::AivoiceSearchBar),
            "AIVOICE_FAVICON" => Some(Self::AivoiceFavicon),
            "AISTUDIO" => Some(Self::Aistudio),
            "DEEPLINK" => Some(Self::Deeplink),
            "NOTIFICATION" => Some(Self::Notification),
            "PROFILE_MESSAGE_BUTTON" => Some(Self::ProfileMessageButton),
            "FORWARD" => Some(Self::Forward),
            "APP_SHORTCUT" => Some(Self::AppShortcut),
            "FF_FAMILY" => Some(Self::FfFamily),
            "AI_TAB" => Some(Self::AiTab),
            "AI_HOME" => Some(Self::AiHome),
            "AI_DEEPLINK_IMMERSIVE" => Some(Self::AiDeeplinkImmersive),
            "AI_DEEPLINK" => Some(Self::AiDeeplink),
            "META_AI_CHAT_SHORTCUT_AI_STUDIO" => Some(Self::MetaAiChatShortcutAiStudio),
            "UGC_CHAT_SHORTCUT_AI_STUDIO" => Some(Self::UgcChatShortcutAiStudio),
            "NEW_CHAT_AI_STUDIO" => Some(Self::NewChatAiStudio),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BotMetricsThreadEntryPoint {
    AiTabThread = 1,
    AiHomeThread = 2,
    AiDeeplinkImmersiveThread = 3,
    AiDeeplinkThread = 4,
}
impl BotMetricsThreadEntryPoint {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AiTabThread => "AI_TAB_THREAD",
            Self::AiHomeThread => "AI_HOME_THREAD",
            Self::AiDeeplinkImmersiveThread => "AI_DEEPLINK_IMMERSIVE_THREAD",
            Self::AiDeeplinkThread => "AI_DEEPLINK_THREAD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AI_TAB_THREAD" => Some(Self::AiTabThread),
            "AI_HOME_THREAD" => Some(Self::AiHomeThread),
            "AI_DEEPLINK_IMMERSIVE_THREAD" => Some(Self::AiDeeplinkImmersiveThread),
            "AI_DEEPLINK_THREAD" => Some(Self::AiDeeplinkThread),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BotSessionSource {
    None = 0,
    NullState = 1,
    Typeahead = 2,
    UserInput = 3,
    EmuFlash = 4,
    EmuFlashFollowup = 5,
    Voice = 6,
}
impl BotSessionSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "NONE",
            Self::NullState => "NULL_STATE",
            Self::Typeahead => "TYPEAHEAD",
            Self::UserInput => "USER_INPUT",
            Self::EmuFlash => "EMU_FLASH",
            Self::EmuFlashFollowup => "EMU_FLASH_FOLLOWUP",
            Self::Voice => "VOICE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NONE" => Some(Self::None),
            "NULL_STATE" => Some(Self::NullState),
            "TYPEAHEAD" => Some(Self::Typeahead),
            "USER_INPUT" => Some(Self::UserInput),
            "EMU_FLASH" => Some(Self::EmuFlash),
            "EMU_FLASH_FOLLOWUP" => Some(Self::EmuFlashFollowup),
            "VOICE" => Some(Self::Voice),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeepType {
    Unknown = 0,
    KeepForAll = 1,
    UndoKeepForAll = 2,
}
impl KeepType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "UNKNOWN",
            Self::KeepForAll => "KEEP_FOR_ALL",
            Self::UndoKeepForAll => "UNDO_KEEP_FOR_ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "KEEP_FOR_ALL" => Some(Self::KeepForAll),
            "UNDO_KEEP_FOR_ALL" => Some(Self::UndoKeepForAll),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MediaVisibility {
    Default = 0,
    Off = 1,
    On = 2,
}
impl MediaVisibility {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "DEFAULT",
            Self::Off => "OFF",
            Self::On => "ON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEFAULT" => Some(Self::Default),
            "OFF" => Some(Self::Off),
            "ON" => Some(Self::On),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, reflect_macros::Reflect)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PrivacySystemMessage {
    E2eeMsg = 1,
    Ne2eeSelf = 2,
    Ne2eeOther = 3,
}
impl PrivacySystemMessage {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::E2eeMsg => "E2EE_MSG",
            Self::Ne2eeSelf => "NE2EE_SELF",
            Self::Ne2eeOther => "NE2EE_OTHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "E2EE_MSG" => Some(Self::E2eeMsg),
            "NE2EE_SELF" => Some(Self::Ne2eeSelf),
            "NE2EE_OTHER" => Some(Self::Ne2eeOther),
            _ => None,
        }
    }
}
